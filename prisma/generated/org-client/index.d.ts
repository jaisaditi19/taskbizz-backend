
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Task
 * Master task model (template for recurring tasks)
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskCustomField
 * 
 */
export type TaskCustomField = $Result.DefaultSelection<Prisma.$TaskCustomFieldPayload>
/**
 * Model TaskCustomValue
 * 
 */
export type TaskCustomValue = $Result.DefaultSelection<Prisma.$TaskCustomValuePayload>
/**
 * Model TaskOccurrence
 * Individual task occurrences (pre-generated)
 */
export type TaskOccurrence = $Result.DefaultSelection<Prisma.$TaskOccurrencePayload>
/**
 * Model TaskAssignee
 * 
 */
export type TaskAssignee = $Result.DefaultSelection<Prisma.$TaskAssigneePayload>
/**
 * Model TaskOccurrenceAssignee
 * 
 */
export type TaskOccurrenceAssignee = $Result.DefaultSelection<Prisma.$TaskOccurrenceAssigneePayload>
/**
 * Model TaskAttachment
 * 
 */
export type TaskAttachment = $Result.DefaultSelection<Prisma.$TaskAttachmentPayload>
/**
 * Model TaskOccurrenceAttachment
 * Occurrence-specific attachments (optional - for files added to specific occurrences)
 */
export type TaskOccurrenceAttachment = $Result.DefaultSelection<Prisma.$TaskOccurrenceAttachmentPayload>
/**
 * Model CompletionLog
 * Keep for backward compatibility, but mainly for audit trails now
 */
export type CompletionLog = $Result.DefaultSelection<Prisma.$CompletionLogPayload>
/**
 * Model Reminder
 * Reminder queue table
 */
export type Reminder = $Result.DefaultSelection<Prisma.$ReminderPayload>
/**
 * Model CalendarEntry
 * 
 */
export type CalendarEntry = $Result.DefaultSelection<Prisma.$CalendarEntryPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model ConversationMember
 * 
 */
export type ConversationMember = $Result.DefaultSelection<Prisma.$ConversationMemberPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model MessageRead
 * 
 */
export type MessageRead = $Result.DefaultSelection<Prisma.$MessageReadPayload>
/**
 * Model DirectoryUser
 * 
 */
export type DirectoryUser = $Result.DefaultSelection<Prisma.$DirectoryUserPayload>
/**
 * Model EmailLog
 * 
 */
export type EmailLog = $Result.DefaultSelection<Prisma.$EmailLogPayload>
/**
 * Model LeaveRequest
 * 
 */
export type LeaveRequest = $Result.DefaultSelection<Prisma.$LeaveRequestPayload>
/**
 * Model License
 * 
 */
export type License = $Result.DefaultSelection<Prisma.$LicensePayload>
/**
 * Model LicenseAssignee
 * 
 */
export type LicenseAssignee = $Result.DefaultSelection<Prisma.$LicenseAssigneePayload>
/**
 * Model LicenseHistory
 * 
 */
export type LicenseHistory = $Result.DefaultSelection<Prisma.$LicenseHistoryPayload>
/**
 * Model LicenseAttachment
 * 
 */
export type LicenseAttachment = $Result.DefaultSelection<Prisma.$LicenseAttachmentPayload>
/**
 * Model ScheduledReminder
 * 
 */
export type ScheduledReminder = $Result.DefaultSelection<Prisma.$ScheduledReminderPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ClientStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type ClientStatus = (typeof ClientStatus)[keyof typeof ClientStatus]


export const TaskStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  ON_TRACK: 'ON_TRACK',
  DELAYED: 'DELAYED',
  IN_TESTING: 'IN_TESTING',
  ON_HOLD: 'ON_HOLD',
  APPROVED: 'APPROVED',
  CANCELLED: 'CANCELLED',
  PLANNING: 'PLANNING',
  COMPLETED: 'COMPLETED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const LogType: {
  COMPLETED: 'COMPLETED',
  SKIPPED: 'SKIPPED',
  RESCHEDULED: 'RESCHEDULED'
};

export type LogType = (typeof LogType)[keyof typeof LogType]


export const CalendarEntryType: {
  REMINDER: 'REMINDER',
  APPOINTMENT: 'APPOINTMENT'
};

export type CalendarEntryType = (typeof CalendarEntryType)[keyof typeof CalendarEntryType]


export const RecurrenceFreq: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY'
};

export type RecurrenceFreq = (typeof RecurrenceFreq)[keyof typeof RecurrenceFreq]


export const EmailStatus: {
  SENT: 'SENT',
  FAILED: 'FAILED',
  PENDING: 'PENDING'
};

export type EmailStatus = (typeof EmailStatus)[keyof typeof EmailStatus]


export const LeaveStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type LeaveStatus = (typeof LeaveStatus)[keyof typeof LeaveStatus]


export const LeaveType: {
  SICK: 'SICK',
  CASUAL: 'CASUAL',
  PLANNED: 'PLANNED',
  UNPAID: 'UNPAID'
};

export type LeaveType = (typeof LeaveType)[keyof typeof LeaveType]


export const LicenseStatus: {
  ACTIVE: 'ACTIVE',
  RENEWAL_DUE: 'RENEWAL_DUE',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type LicenseStatus = (typeof LicenseStatus)[keyof typeof LicenseStatus]


export const LicenseAssigneeRole: {
  OWNER: 'OWNER',
  WATCHER: 'WATCHER'
};

export type LicenseAssigneeRole = (typeof LicenseAssigneeRole)[keyof typeof LicenseAssigneeRole]


export const ReminderStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type ReminderStatus = (typeof ReminderStatus)[keyof typeof ReminderStatus]

}

export type ClientStatus = $Enums.ClientStatus

export const ClientStatus: typeof $Enums.ClientStatus

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type LogType = $Enums.LogType

export const LogType: typeof $Enums.LogType

export type CalendarEntryType = $Enums.CalendarEntryType

export const CalendarEntryType: typeof $Enums.CalendarEntryType

export type RecurrenceFreq = $Enums.RecurrenceFreq

export const RecurrenceFreq: typeof $Enums.RecurrenceFreq

export type EmailStatus = $Enums.EmailStatus

export const EmailStatus: typeof $Enums.EmailStatus

export type LeaveStatus = $Enums.LeaveStatus

export const LeaveStatus: typeof $Enums.LeaveStatus

export type LeaveType = $Enums.LeaveType

export const LeaveType: typeof $Enums.LeaveType

export type LicenseStatus = $Enums.LicenseStatus

export const LicenseStatus: typeof $Enums.LicenseStatus

export type LicenseAssigneeRole = $Enums.LicenseAssigneeRole

export const LicenseAssigneeRole: typeof $Enums.LicenseAssigneeRole

export type ReminderStatus = $Enums.ReminderStatus

export const ReminderStatus: typeof $Enums.ReminderStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Clients
 * const clients = await prisma.client.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Clients
   * const clients = await prisma.client.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskCustomField`: Exposes CRUD operations for the **TaskCustomField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskCustomFields
    * const taskCustomFields = await prisma.taskCustomField.findMany()
    * ```
    */
  get taskCustomField(): Prisma.TaskCustomFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskCustomValue`: Exposes CRUD operations for the **TaskCustomValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskCustomValues
    * const taskCustomValues = await prisma.taskCustomValue.findMany()
    * ```
    */
  get taskCustomValue(): Prisma.TaskCustomValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskOccurrence`: Exposes CRUD operations for the **TaskOccurrence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskOccurrences
    * const taskOccurrences = await prisma.taskOccurrence.findMany()
    * ```
    */
  get taskOccurrence(): Prisma.TaskOccurrenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskAssignee`: Exposes CRUD operations for the **TaskAssignee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAssignees
    * const taskAssignees = await prisma.taskAssignee.findMany()
    * ```
    */
  get taskAssignee(): Prisma.TaskAssigneeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskOccurrenceAssignee`: Exposes CRUD operations for the **TaskOccurrenceAssignee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskOccurrenceAssignees
    * const taskOccurrenceAssignees = await prisma.taskOccurrenceAssignee.findMany()
    * ```
    */
  get taskOccurrenceAssignee(): Prisma.TaskOccurrenceAssigneeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskAttachment`: Exposes CRUD operations for the **TaskAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskAttachments
    * const taskAttachments = await prisma.taskAttachment.findMany()
    * ```
    */
  get taskAttachment(): Prisma.TaskAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskOccurrenceAttachment`: Exposes CRUD operations for the **TaskOccurrenceAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskOccurrenceAttachments
    * const taskOccurrenceAttachments = await prisma.taskOccurrenceAttachment.findMany()
    * ```
    */
  get taskOccurrenceAttachment(): Prisma.TaskOccurrenceAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.completionLog`: Exposes CRUD operations for the **CompletionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompletionLogs
    * const completionLogs = await prisma.completionLog.findMany()
    * ```
    */
  get completionLog(): Prisma.CompletionLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reminder`: Exposes CRUD operations for the **Reminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reminders
    * const reminders = await prisma.reminder.findMany()
    * ```
    */
  get reminder(): Prisma.ReminderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarEntry`: Exposes CRUD operations for the **CalendarEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEntries
    * const calendarEntries = await prisma.calendarEntry.findMany()
    * ```
    */
  get calendarEntry(): Prisma.CalendarEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationMember`: Exposes CRUD operations for the **ConversationMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationMembers
    * const conversationMembers = await prisma.conversationMember.findMany()
    * ```
    */
  get conversationMember(): Prisma.ConversationMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageRead`: Exposes CRUD operations for the **MessageRead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageReads
    * const messageReads = await prisma.messageRead.findMany()
    * ```
    */
  get messageRead(): Prisma.MessageReadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.directoryUser`: Exposes CRUD operations for the **DirectoryUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DirectoryUsers
    * const directoryUsers = await prisma.directoryUser.findMany()
    * ```
    */
  get directoryUser(): Prisma.DirectoryUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailLog`: Exposes CRUD operations for the **EmailLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailLogs
    * const emailLogs = await prisma.emailLog.findMany()
    * ```
    */
  get emailLog(): Prisma.EmailLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaveRequest`: Exposes CRUD operations for the **LeaveRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveRequests
    * const leaveRequests = await prisma.leaveRequest.findMany()
    * ```
    */
  get leaveRequest(): Prisma.LeaveRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.license`: Exposes CRUD operations for the **License** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Licenses
    * const licenses = await prisma.license.findMany()
    * ```
    */
  get license(): Prisma.LicenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.licenseAssignee`: Exposes CRUD operations for the **LicenseAssignee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LicenseAssignees
    * const licenseAssignees = await prisma.licenseAssignee.findMany()
    * ```
    */
  get licenseAssignee(): Prisma.LicenseAssigneeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.licenseHistory`: Exposes CRUD operations for the **LicenseHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LicenseHistories
    * const licenseHistories = await prisma.licenseHistory.findMany()
    * ```
    */
  get licenseHistory(): Prisma.LicenseHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.licenseAttachment`: Exposes CRUD operations for the **LicenseAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LicenseAttachments
    * const licenseAttachments = await prisma.licenseAttachment.findMany()
    * ```
    */
  get licenseAttachment(): Prisma.LicenseAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduledReminder`: Exposes CRUD operations for the **ScheduledReminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledReminders
    * const scheduledReminders = await prisma.scheduledReminder.findMany()
    * ```
    */
  get scheduledReminder(): Prisma.ScheduledReminderDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Client: 'Client',
    Project: 'Project',
    Task: 'Task',
    TaskCustomField: 'TaskCustomField',
    TaskCustomValue: 'TaskCustomValue',
    TaskOccurrence: 'TaskOccurrence',
    TaskAssignee: 'TaskAssignee',
    TaskOccurrenceAssignee: 'TaskOccurrenceAssignee',
    TaskAttachment: 'TaskAttachment',
    TaskOccurrenceAttachment: 'TaskOccurrenceAttachment',
    CompletionLog: 'CompletionLog',
    Reminder: 'Reminder',
    CalendarEntry: 'CalendarEntry',
    Notification: 'Notification',
    Conversation: 'Conversation',
    ConversationMember: 'ConversationMember',
    Message: 'Message',
    MessageRead: 'MessageRead',
    DirectoryUser: 'DirectoryUser',
    EmailLog: 'EmailLog',
    LeaveRequest: 'LeaveRequest',
    License: 'License',
    LicenseAssignee: 'LicenseAssignee',
    LicenseHistory: 'LicenseHistory',
    LicenseAttachment: 'LicenseAttachment',
    ScheduledReminder: 'ScheduledReminder'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "client" | "project" | "task" | "taskCustomField" | "taskCustomValue" | "taskOccurrence" | "taskAssignee" | "taskOccurrenceAssignee" | "taskAttachment" | "taskOccurrenceAttachment" | "completionLog" | "reminder" | "calendarEntry" | "notification" | "conversation" | "conversationMember" | "message" | "messageRead" | "directoryUser" | "emailLog" | "leaveRequest" | "license" | "licenseAssignee" | "licenseHistory" | "licenseAttachment" | "scheduledReminder"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskCustomField: {
        payload: Prisma.$TaskCustomFieldPayload<ExtArgs>
        fields: Prisma.TaskCustomFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskCustomFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskCustomFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomFieldPayload>
          }
          findFirst: {
            args: Prisma.TaskCustomFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskCustomFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomFieldPayload>
          }
          findMany: {
            args: Prisma.TaskCustomFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomFieldPayload>[]
          }
          create: {
            args: Prisma.TaskCustomFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomFieldPayload>
          }
          createMany: {
            args: Prisma.TaskCustomFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCustomFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomFieldPayload>[]
          }
          delete: {
            args: Prisma.TaskCustomFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomFieldPayload>
          }
          update: {
            args: Prisma.TaskCustomFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomFieldPayload>
          }
          deleteMany: {
            args: Prisma.TaskCustomFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskCustomFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskCustomFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomFieldPayload>[]
          }
          upsert: {
            args: Prisma.TaskCustomFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomFieldPayload>
          }
          aggregate: {
            args: Prisma.TaskCustomFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskCustomField>
          }
          groupBy: {
            args: Prisma.TaskCustomFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskCustomFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCustomFieldCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCustomFieldCountAggregateOutputType> | number
          }
        }
      }
      TaskCustomValue: {
        payload: Prisma.$TaskCustomValuePayload<ExtArgs>
        fields: Prisma.TaskCustomValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskCustomValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskCustomValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>
          }
          findFirst: {
            args: Prisma.TaskCustomValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskCustomValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>
          }
          findMany: {
            args: Prisma.TaskCustomValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>[]
          }
          create: {
            args: Prisma.TaskCustomValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>
          }
          createMany: {
            args: Prisma.TaskCustomValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCustomValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>[]
          }
          delete: {
            args: Prisma.TaskCustomValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>
          }
          update: {
            args: Prisma.TaskCustomValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>
          }
          deleteMany: {
            args: Prisma.TaskCustomValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskCustomValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskCustomValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>[]
          }
          upsert: {
            args: Prisma.TaskCustomValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCustomValuePayload>
          }
          aggregate: {
            args: Prisma.TaskCustomValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskCustomValue>
          }
          groupBy: {
            args: Prisma.TaskCustomValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskCustomValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCustomValueCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCustomValueCountAggregateOutputType> | number
          }
        }
      }
      TaskOccurrence: {
        payload: Prisma.$TaskOccurrencePayload<ExtArgs>
        fields: Prisma.TaskOccurrenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskOccurrenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskOccurrenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrencePayload>
          }
          findFirst: {
            args: Prisma.TaskOccurrenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskOccurrenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrencePayload>
          }
          findMany: {
            args: Prisma.TaskOccurrenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrencePayload>[]
          }
          create: {
            args: Prisma.TaskOccurrenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrencePayload>
          }
          createMany: {
            args: Prisma.TaskOccurrenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskOccurrenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrencePayload>[]
          }
          delete: {
            args: Prisma.TaskOccurrenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrencePayload>
          }
          update: {
            args: Prisma.TaskOccurrenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrencePayload>
          }
          deleteMany: {
            args: Prisma.TaskOccurrenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskOccurrenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskOccurrenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrencePayload>[]
          }
          upsert: {
            args: Prisma.TaskOccurrenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrencePayload>
          }
          aggregate: {
            args: Prisma.TaskOccurrenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskOccurrence>
          }
          groupBy: {
            args: Prisma.TaskOccurrenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskOccurrenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskOccurrenceCountArgs<ExtArgs>
            result: $Utils.Optional<TaskOccurrenceCountAggregateOutputType> | number
          }
        }
      }
      TaskAssignee: {
        payload: Prisma.$TaskAssigneePayload<ExtArgs>
        fields: Prisma.TaskAssigneeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAssigneeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAssigneeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          findFirst: {
            args: Prisma.TaskAssigneeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAssigneeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          findMany: {
            args: Prisma.TaskAssigneeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
          }
          create: {
            args: Prisma.TaskAssigneeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          createMany: {
            args: Prisma.TaskAssigneeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAssigneeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
          }
          delete: {
            args: Prisma.TaskAssigneeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          update: {
            args: Prisma.TaskAssigneeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          deleteMany: {
            args: Prisma.TaskAssigneeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAssigneeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskAssigneeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>[]
          }
          upsert: {
            args: Prisma.TaskAssigneeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAssigneePayload>
          }
          aggregate: {
            args: Prisma.TaskAssigneeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAssignee>
          }
          groupBy: {
            args: Prisma.TaskAssigneeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAssigneeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAssigneeCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAssigneeCountAggregateOutputType> | number
          }
        }
      }
      TaskOccurrenceAssignee: {
        payload: Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>
        fields: Prisma.TaskOccurrenceAssigneeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskOccurrenceAssigneeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAssigneePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskOccurrenceAssigneeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAssigneePayload>
          }
          findFirst: {
            args: Prisma.TaskOccurrenceAssigneeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAssigneePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskOccurrenceAssigneeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAssigneePayload>
          }
          findMany: {
            args: Prisma.TaskOccurrenceAssigneeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAssigneePayload>[]
          }
          create: {
            args: Prisma.TaskOccurrenceAssigneeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAssigneePayload>
          }
          createMany: {
            args: Prisma.TaskOccurrenceAssigneeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskOccurrenceAssigneeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAssigneePayload>[]
          }
          delete: {
            args: Prisma.TaskOccurrenceAssigneeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAssigneePayload>
          }
          update: {
            args: Prisma.TaskOccurrenceAssigneeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAssigneePayload>
          }
          deleteMany: {
            args: Prisma.TaskOccurrenceAssigneeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskOccurrenceAssigneeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskOccurrenceAssigneeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAssigneePayload>[]
          }
          upsert: {
            args: Prisma.TaskOccurrenceAssigneeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAssigneePayload>
          }
          aggregate: {
            args: Prisma.TaskOccurrenceAssigneeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskOccurrenceAssignee>
          }
          groupBy: {
            args: Prisma.TaskOccurrenceAssigneeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskOccurrenceAssigneeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskOccurrenceAssigneeCountArgs<ExtArgs>
            result: $Utils.Optional<TaskOccurrenceAssigneeCountAggregateOutputType> | number
          }
        }
      }
      TaskAttachment: {
        payload: Prisma.$TaskAttachmentPayload<ExtArgs>
        fields: Prisma.TaskAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          findFirst: {
            args: Prisma.TaskAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          findMany: {
            args: Prisma.TaskAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>[]
          }
          create: {
            args: Prisma.TaskAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          createMany: {
            args: Prisma.TaskAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>[]
          }
          delete: {
            args: Prisma.TaskAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          update: {
            args: Prisma.TaskAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.TaskAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.TaskAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskAttachmentPayload>
          }
          aggregate: {
            args: Prisma.TaskAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskAttachment>
          }
          groupBy: {
            args: Prisma.TaskAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<TaskAttachmentCountAggregateOutputType> | number
          }
        }
      }
      TaskOccurrenceAttachment: {
        payload: Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>
        fields: Prisma.TaskOccurrenceAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskOccurrenceAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskOccurrenceAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAttachmentPayload>
          }
          findFirst: {
            args: Prisma.TaskOccurrenceAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskOccurrenceAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAttachmentPayload>
          }
          findMany: {
            args: Prisma.TaskOccurrenceAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAttachmentPayload>[]
          }
          create: {
            args: Prisma.TaskOccurrenceAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAttachmentPayload>
          }
          createMany: {
            args: Prisma.TaskOccurrenceAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskOccurrenceAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAttachmentPayload>[]
          }
          delete: {
            args: Prisma.TaskOccurrenceAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAttachmentPayload>
          }
          update: {
            args: Prisma.TaskOccurrenceAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.TaskOccurrenceAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskOccurrenceAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskOccurrenceAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.TaskOccurrenceAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOccurrenceAttachmentPayload>
          }
          aggregate: {
            args: Prisma.TaskOccurrenceAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskOccurrenceAttachment>
          }
          groupBy: {
            args: Prisma.TaskOccurrenceAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskOccurrenceAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskOccurrenceAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<TaskOccurrenceAttachmentCountAggregateOutputType> | number
          }
        }
      }
      CompletionLog: {
        payload: Prisma.$CompletionLogPayload<ExtArgs>
        fields: Prisma.CompletionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompletionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompletionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletionLogPayload>
          }
          findFirst: {
            args: Prisma.CompletionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompletionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletionLogPayload>
          }
          findMany: {
            args: Prisma.CompletionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletionLogPayload>[]
          }
          create: {
            args: Prisma.CompletionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletionLogPayload>
          }
          createMany: {
            args: Prisma.CompletionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompletionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletionLogPayload>[]
          }
          delete: {
            args: Prisma.CompletionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletionLogPayload>
          }
          update: {
            args: Prisma.CompletionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletionLogPayload>
          }
          deleteMany: {
            args: Prisma.CompletionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompletionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompletionLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletionLogPayload>[]
          }
          upsert: {
            args: Prisma.CompletionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletionLogPayload>
          }
          aggregate: {
            args: Prisma.CompletionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompletionLog>
          }
          groupBy: {
            args: Prisma.CompletionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompletionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompletionLogCountArgs<ExtArgs>
            result: $Utils.Optional<CompletionLogCountAggregateOutputType> | number
          }
        }
      }
      Reminder: {
        payload: Prisma.$ReminderPayload<ExtArgs>
        fields: Prisma.ReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          findFirst: {
            args: Prisma.ReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          findMany: {
            args: Prisma.ReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>[]
          }
          create: {
            args: Prisma.ReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          createMany: {
            args: Prisma.ReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReminderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>[]
          }
          delete: {
            args: Prisma.ReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          update: {
            args: Prisma.ReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          deleteMany: {
            args: Prisma.ReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReminderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>[]
          }
          upsert: {
            args: Prisma.ReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          aggregate: {
            args: Prisma.ReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReminder>
          }
          groupBy: {
            args: Prisma.ReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReminderCountArgs<ExtArgs>
            result: $Utils.Optional<ReminderCountAggregateOutputType> | number
          }
        }
      }
      CalendarEntry: {
        payload: Prisma.$CalendarEntryPayload<ExtArgs>
        fields: Prisma.CalendarEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>
          }
          findFirst: {
            args: Prisma.CalendarEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>
          }
          findMany: {
            args: Prisma.CalendarEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>[]
          }
          create: {
            args: Prisma.CalendarEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>
          }
          createMany: {
            args: Prisma.CalendarEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>[]
          }
          delete: {
            args: Prisma.CalendarEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>
          }
          update: {
            args: Prisma.CalendarEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalendarEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>[]
          }
          upsert: {
            args: Prisma.CalendarEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>
          }
          aggregate: {
            args: Prisma.CalendarEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEntry>
          }
          groupBy: {
            args: Prisma.CalendarEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEntryCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEntryCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      ConversationMember: {
        payload: Prisma.$ConversationMemberPayload<ExtArgs>
        fields: Prisma.ConversationMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemberPayload>
          }
          findFirst: {
            args: Prisma.ConversationMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemberPayload>
          }
          findMany: {
            args: Prisma.ConversationMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemberPayload>[]
          }
          create: {
            args: Prisma.ConversationMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemberPayload>
          }
          createMany: {
            args: Prisma.ConversationMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemberPayload>[]
          }
          delete: {
            args: Prisma.ConversationMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemberPayload>
          }
          update: {
            args: Prisma.ConversationMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemberPayload>
          }
          deleteMany: {
            args: Prisma.ConversationMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemberPayload>[]
          }
          upsert: {
            args: Prisma.ConversationMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMemberPayload>
          }
          aggregate: {
            args: Prisma.ConversationMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationMember>
          }
          groupBy: {
            args: Prisma.ConversationMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationMemberCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageRead: {
        payload: Prisma.$MessageReadPayload<ExtArgs>
        fields: Prisma.MessageReadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageReadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageReadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          findFirst: {
            args: Prisma.MessageReadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageReadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          findMany: {
            args: Prisma.MessageReadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
          }
          create: {
            args: Prisma.MessageReadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          createMany: {
            args: Prisma.MessageReadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageReadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
          }
          delete: {
            args: Prisma.MessageReadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          update: {
            args: Prisma.MessageReadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          deleteMany: {
            args: Prisma.MessageReadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageReadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageReadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
          }
          upsert: {
            args: Prisma.MessageReadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          aggregate: {
            args: Prisma.MessageReadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageRead>
          }
          groupBy: {
            args: Prisma.MessageReadGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageReadGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageReadCountArgs<ExtArgs>
            result: $Utils.Optional<MessageReadCountAggregateOutputType> | number
          }
        }
      }
      DirectoryUser: {
        payload: Prisma.$DirectoryUserPayload<ExtArgs>
        fields: Prisma.DirectoryUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DirectoryUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DirectoryUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryUserPayload>
          }
          findFirst: {
            args: Prisma.DirectoryUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DirectoryUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryUserPayload>
          }
          findMany: {
            args: Prisma.DirectoryUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryUserPayload>[]
          }
          create: {
            args: Prisma.DirectoryUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryUserPayload>
          }
          createMany: {
            args: Prisma.DirectoryUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DirectoryUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryUserPayload>[]
          }
          delete: {
            args: Prisma.DirectoryUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryUserPayload>
          }
          update: {
            args: Prisma.DirectoryUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryUserPayload>
          }
          deleteMany: {
            args: Prisma.DirectoryUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DirectoryUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DirectoryUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryUserPayload>[]
          }
          upsert: {
            args: Prisma.DirectoryUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectoryUserPayload>
          }
          aggregate: {
            args: Prisma.DirectoryUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDirectoryUser>
          }
          groupBy: {
            args: Prisma.DirectoryUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<DirectoryUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.DirectoryUserCountArgs<ExtArgs>
            result: $Utils.Optional<DirectoryUserCountAggregateOutputType> | number
          }
        }
      }
      EmailLog: {
        payload: Prisma.$EmailLogPayload<ExtArgs>
        fields: Prisma.EmailLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findFirst: {
            args: Prisma.EmailLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findMany: {
            args: Prisma.EmailLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          create: {
            args: Prisma.EmailLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          createMany: {
            args: Prisma.EmailLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          delete: {
            args: Prisma.EmailLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          update: {
            args: Prisma.EmailLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          deleteMany: {
            args: Prisma.EmailLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          upsert: {
            args: Prisma.EmailLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          aggregate: {
            args: Prisma.EmailLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailLog>
          }
          groupBy: {
            args: Prisma.EmailLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailLogCountArgs<ExtArgs>
            result: $Utils.Optional<EmailLogCountAggregateOutputType> | number
          }
        }
      }
      LeaveRequest: {
        payload: Prisma.$LeaveRequestPayload<ExtArgs>
        fields: Prisma.LeaveRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findFirst: {
            args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findMany: {
            args: Prisma.LeaveRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          create: {
            args: Prisma.LeaveRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          createMany: {
            args: Prisma.LeaveRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          delete: {
            args: Prisma.LeaveRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          update: {
            args: Prisma.LeaveRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          deleteMany: {
            args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          upsert: {
            args: Prisma.LeaveRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          aggregate: {
            args: Prisma.LeaveRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveRequest>
          }
          groupBy: {
            args: Prisma.LeaveRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveRequestCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestCountAggregateOutputType> | number
          }
        }
      }
      License: {
        payload: Prisma.$LicensePayload<ExtArgs>
        fields: Prisma.LicenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findFirst: {
            args: Prisma.LicenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findMany: {
            args: Prisma.LicenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          create: {
            args: Prisma.LicenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          createMany: {
            args: Prisma.LicenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LicenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          delete: {
            args: Prisma.LicenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          update: {
            args: Prisma.LicenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          deleteMany: {
            args: Prisma.LicenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LicenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          upsert: {
            args: Prisma.LicenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          aggregate: {
            args: Prisma.LicenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicense>
          }
          groupBy: {
            args: Prisma.LicenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicenseCountArgs<ExtArgs>
            result: $Utils.Optional<LicenseCountAggregateOutputType> | number
          }
        }
      }
      LicenseAssignee: {
        payload: Prisma.$LicenseAssigneePayload<ExtArgs>
        fields: Prisma.LicenseAssigneeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicenseAssigneeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAssigneePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicenseAssigneeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAssigneePayload>
          }
          findFirst: {
            args: Prisma.LicenseAssigneeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAssigneePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicenseAssigneeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAssigneePayload>
          }
          findMany: {
            args: Prisma.LicenseAssigneeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAssigneePayload>[]
          }
          create: {
            args: Prisma.LicenseAssigneeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAssigneePayload>
          }
          createMany: {
            args: Prisma.LicenseAssigneeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LicenseAssigneeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAssigneePayload>[]
          }
          delete: {
            args: Prisma.LicenseAssigneeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAssigneePayload>
          }
          update: {
            args: Prisma.LicenseAssigneeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAssigneePayload>
          }
          deleteMany: {
            args: Prisma.LicenseAssigneeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicenseAssigneeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LicenseAssigneeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAssigneePayload>[]
          }
          upsert: {
            args: Prisma.LicenseAssigneeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAssigneePayload>
          }
          aggregate: {
            args: Prisma.LicenseAssigneeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicenseAssignee>
          }
          groupBy: {
            args: Prisma.LicenseAssigneeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicenseAssigneeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicenseAssigneeCountArgs<ExtArgs>
            result: $Utils.Optional<LicenseAssigneeCountAggregateOutputType> | number
          }
        }
      }
      LicenseHistory: {
        payload: Prisma.$LicenseHistoryPayload<ExtArgs>
        fields: Prisma.LicenseHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicenseHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicenseHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseHistoryPayload>
          }
          findFirst: {
            args: Prisma.LicenseHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicenseHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseHistoryPayload>
          }
          findMany: {
            args: Prisma.LicenseHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseHistoryPayload>[]
          }
          create: {
            args: Prisma.LicenseHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseHistoryPayload>
          }
          createMany: {
            args: Prisma.LicenseHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LicenseHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseHistoryPayload>[]
          }
          delete: {
            args: Prisma.LicenseHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseHistoryPayload>
          }
          update: {
            args: Prisma.LicenseHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseHistoryPayload>
          }
          deleteMany: {
            args: Prisma.LicenseHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicenseHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LicenseHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseHistoryPayload>[]
          }
          upsert: {
            args: Prisma.LicenseHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseHistoryPayload>
          }
          aggregate: {
            args: Prisma.LicenseHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicenseHistory>
          }
          groupBy: {
            args: Prisma.LicenseHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicenseHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicenseHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<LicenseHistoryCountAggregateOutputType> | number
          }
        }
      }
      LicenseAttachment: {
        payload: Prisma.$LicenseAttachmentPayload<ExtArgs>
        fields: Prisma.LicenseAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicenseAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicenseAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAttachmentPayload>
          }
          findFirst: {
            args: Prisma.LicenseAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicenseAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAttachmentPayload>
          }
          findMany: {
            args: Prisma.LicenseAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAttachmentPayload>[]
          }
          create: {
            args: Prisma.LicenseAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAttachmentPayload>
          }
          createMany: {
            args: Prisma.LicenseAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LicenseAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAttachmentPayload>[]
          }
          delete: {
            args: Prisma.LicenseAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAttachmentPayload>
          }
          update: {
            args: Prisma.LicenseAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.LicenseAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicenseAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LicenseAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.LicenseAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenseAttachmentPayload>
          }
          aggregate: {
            args: Prisma.LicenseAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicenseAttachment>
          }
          groupBy: {
            args: Prisma.LicenseAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicenseAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicenseAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<LicenseAttachmentCountAggregateOutputType> | number
          }
        }
      }
      ScheduledReminder: {
        payload: Prisma.$ScheduledReminderPayload<ExtArgs>
        fields: Prisma.ScheduledReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReminderPayload>
          }
          findFirst: {
            args: Prisma.ScheduledReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReminderPayload>
          }
          findMany: {
            args: Prisma.ScheduledReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReminderPayload>[]
          }
          create: {
            args: Prisma.ScheduledReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReminderPayload>
          }
          createMany: {
            args: Prisma.ScheduledReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledReminderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReminderPayload>[]
          }
          delete: {
            args: Prisma.ScheduledReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReminderPayload>
          }
          update: {
            args: Prisma.ScheduledReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReminderPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduledReminderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReminderPayload>[]
          }
          upsert: {
            args: Prisma.ScheduledReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledReminderPayload>
          }
          aggregate: {
            args: Prisma.ScheduledReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledReminder>
          }
          groupBy: {
            args: Prisma.ScheduledReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledReminderCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledReminderCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    client?: ClientOmit
    project?: ProjectOmit
    task?: TaskOmit
    taskCustomField?: TaskCustomFieldOmit
    taskCustomValue?: TaskCustomValueOmit
    taskOccurrence?: TaskOccurrenceOmit
    taskAssignee?: TaskAssigneeOmit
    taskOccurrenceAssignee?: TaskOccurrenceAssigneeOmit
    taskAttachment?: TaskAttachmentOmit
    taskOccurrenceAttachment?: TaskOccurrenceAttachmentOmit
    completionLog?: CompletionLogOmit
    reminder?: ReminderOmit
    calendarEntry?: CalendarEntryOmit
    notification?: NotificationOmit
    conversation?: ConversationOmit
    conversationMember?: ConversationMemberOmit
    message?: MessageOmit
    messageRead?: MessageReadOmit
    directoryUser?: DirectoryUserOmit
    emailLog?: EmailLogOmit
    leaveRequest?: LeaveRequestOmit
    license?: LicenseOmit
    licenseAssignee?: LicenseAssigneeOmit
    licenseHistory?: LicenseHistoryOmit
    licenseAttachment?: LicenseAttachmentOmit
    scheduledReminder?: ScheduledReminderOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    tasks: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    assignees: number
    occurrences: number
    reminders: number
    attachments: number
    customValues: number
    emailLogs: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignees?: boolean | TaskCountOutputTypeCountAssigneesArgs
    occurrences?: boolean | TaskCountOutputTypeCountOccurrencesArgs
    reminders?: boolean | TaskCountOutputTypeCountRemindersArgs
    attachments?: boolean | TaskCountOutputTypeCountAttachmentsArgs
    customValues?: boolean | TaskCountOutputTypeCountCustomValuesArgs
    emailLogs?: boolean | TaskCountOutputTypeCountEmailLogsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssigneeWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountOccurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskOccurrenceWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAttachmentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCustomValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCustomValueWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountEmailLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
  }


  /**
   * Count Type TaskCustomFieldCountOutputType
   */

  export type TaskCustomFieldCountOutputType = {
    values: number
  }

  export type TaskCustomFieldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | TaskCustomFieldCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * TaskCustomFieldCountOutputType without action
   */
  export type TaskCustomFieldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomFieldCountOutputType
     */
    select?: TaskCustomFieldCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCustomFieldCountOutputType without action
   */
  export type TaskCustomFieldCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCustomValueWhereInput
  }


  /**
   * Count Type TaskOccurrenceCountOutputType
   */

  export type TaskOccurrenceCountOutputType = {
    assignees: number
    attachments: number
    emailLogs: number
  }

  export type TaskOccurrenceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignees?: boolean | TaskOccurrenceCountOutputTypeCountAssigneesArgs
    attachments?: boolean | TaskOccurrenceCountOutputTypeCountAttachmentsArgs
    emailLogs?: boolean | TaskOccurrenceCountOutputTypeCountEmailLogsArgs
  }

  // Custom InputTypes
  /**
   * TaskOccurrenceCountOutputType without action
   */
  export type TaskOccurrenceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceCountOutputType
     */
    select?: TaskOccurrenceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskOccurrenceCountOutputType without action
   */
  export type TaskOccurrenceCountOutputTypeCountAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskOccurrenceAssigneeWhereInput
  }

  /**
   * TaskOccurrenceCountOutputType without action
   */
  export type TaskOccurrenceCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskOccurrenceAttachmentWhereInput
  }

  /**
   * TaskOccurrenceCountOutputType without action
   */
  export type TaskOccurrenceCountOutputTypeCountEmailLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    members: number
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ConversationCountOutputTypeCountMembersArgs
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationMemberWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    reads: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reads?: boolean | MessageCountOutputTypeCountReadsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadWhereInput
  }


  /**
   * Count Type DirectoryUserCountOutputType
   */

  export type DirectoryUserCountOutputType = {
    members: number
    messagesSent: number
  }

  export type DirectoryUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | DirectoryUserCountOutputTypeCountMembersArgs
    messagesSent?: boolean | DirectoryUserCountOutputTypeCountMessagesSentArgs
  }

  // Custom InputTypes
  /**
   * DirectoryUserCountOutputType without action
   */
  export type DirectoryUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUserCountOutputType
     */
    select?: DirectoryUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DirectoryUserCountOutputType without action
   */
  export type DirectoryUserCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationMemberWhereInput
  }

  /**
   * DirectoryUserCountOutputType without action
   */
  export type DirectoryUserCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type LicenseCountOutputType
   */

  export type LicenseCountOutputType = {
    assignees: number
    histories: number
    attachments: number
    scheduledReminders: number
  }

  export type LicenseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignees?: boolean | LicenseCountOutputTypeCountAssigneesArgs
    histories?: boolean | LicenseCountOutputTypeCountHistoriesArgs
    attachments?: boolean | LicenseCountOutputTypeCountAttachmentsArgs
    scheduledReminders?: boolean | LicenseCountOutputTypeCountScheduledRemindersArgs
  }

  // Custom InputTypes
  /**
   * LicenseCountOutputType without action
   */
  export type LicenseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseCountOutputType
     */
    select?: LicenseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LicenseCountOutputType without action
   */
  export type LicenseCountOutputTypeCountAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseAssigneeWhereInput
  }

  /**
   * LicenseCountOutputType without action
   */
  export type LicenseCountOutputTypeCountHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseHistoryWhereInput
  }

  /**
   * LicenseCountOutputType without action
   */
  export type LicenseCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseAttachmentWhereInput
  }

  /**
   * LicenseCountOutputType without action
   */
  export type LicenseCountOutputTypeCountScheduledRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReminderWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    mobile: string | null
    email: string | null
    gstNumber: string | null
    panNumber: string | null
    address: string | null
    city: string | null
    state: string | null
    pincode: string | null
    clientCommunication: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.ClientStatus | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    mobile: string | null
    email: string | null
    gstNumber: string | null
    panNumber: string | null
    address: string | null
    city: string | null
    state: string | null
    pincode: string | null
    clientCommunication: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.ClientStatus | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    mobile: number
    email: number
    gstNumber: number
    panNumber: number
    address: number
    city: number
    state: number
    pincode: number
    clientCommunication: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    mobile?: true
    email?: true
    gstNumber?: true
    panNumber?: true
    address?: true
    city?: true
    state?: true
    pincode?: true
    clientCommunication?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    mobile?: true
    email?: true
    gstNumber?: true
    panNumber?: true
    address?: true
    city?: true
    state?: true
    pincode?: true
    clientCommunication?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    mobile?: true
    email?: true
    gstNumber?: true
    panNumber?: true
    address?: true
    city?: true
    state?: true
    pincode?: true
    clientCommunication?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    name: string
    mobile: string | null
    email: string | null
    gstNumber: string | null
    panNumber: string | null
    address: string | null
    city: string | null
    state: string | null
    pincode: string | null
    clientCommunication: boolean | null
    createdAt: Date
    updatedAt: Date
    status: $Enums.ClientStatus
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    mobile?: boolean
    email?: boolean
    gstNumber?: boolean
    panNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    clientCommunication?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    mobile?: boolean
    email?: boolean
    gstNumber?: boolean
    panNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    clientCommunication?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    mobile?: boolean
    email?: boolean
    gstNumber?: boolean
    panNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    clientCommunication?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    mobile?: boolean
    email?: boolean
    gstNumber?: boolean
    panNumber?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    clientCommunication?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "mobile" | "email" | "gstNumber" | "panNumber" | "address" | "city" | "state" | "pincode" | "clientCommunication" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["client"]>

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      mobile: string | null
      email: string | null
      gstNumber: string | null
      panNumber: string | null
      address: string | null
      city: string | null
      state: string | null
      pincode: string | null
      clientCommunication: boolean | null
      createdAt: Date
      updatedAt: Date
      status: $Enums.ClientStatus
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly mobile: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly gstNumber: FieldRef<"Client", 'String'>
    readonly panNumber: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly city: FieldRef<"Client", 'String'>
    readonly state: FieldRef<"Client", 'String'>
    readonly pincode: FieldRef<"Client", 'String'>
    readonly clientCommunication: FieldRef<"Client", 'Boolean'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
    readonly status: FieldRef<"Client", 'ClientStatus'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    head: string | null
    taskId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    head: string | null
    taskId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    head: number
    taskId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    head?: true
    taskId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    head?: true
    taskId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    head?: true
    taskId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    head: string | null
    taskId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    head?: boolean
    taskId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    head?: boolean
    taskId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    head?: boolean
    taskId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    head?: boolean
    taskId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "head" | "taskId" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      head: string | null
      taskId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly head: FieldRef<"Project", 'String'>
    readonly taskId: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    taskId: number | null
    clientMailSendCount: number | null
  }

  export type TaskSumAggregateOutputType = {
    taskId: number | null
    clientMailSendCount: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    taskId: number | null
    clientId: string | null
    projectId: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    dueDate: Date | null
    assignedToId: string | null
    priority: $Enums.Priority | null
    remarks: string | null
    status: $Enums.TaskStatus | null
    recurrenceRule: string | null
    recurrenceEndDate: Date | null
    isRecurring: boolean | null
    lastGeneratedUntil: Date | null
    retainSubtasks: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientMailSendCount: number | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    taskId: number | null
    clientId: string | null
    projectId: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    dueDate: Date | null
    assignedToId: string | null
    priority: $Enums.Priority | null
    remarks: string | null
    status: $Enums.TaskStatus | null
    recurrenceRule: string | null
    recurrenceEndDate: Date | null
    isRecurring: boolean | null
    lastGeneratedUntil: Date | null
    retainSubtasks: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientMailSendCount: number | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    taskId: number
    clientId: number
    projectId: number
    title: number
    description: number
    startDate: number
    dueDate: number
    assignedToId: number
    priority: number
    remarks: number
    status: number
    recurrenceRule: number
    recurrenceEndDate: number
    isRecurring: number
    lastGeneratedUntil: number
    retainSubtasks: number
    createdById: number
    createdAt: number
    updatedAt: number
    clientMailSendCount: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    taskId?: true
    clientMailSendCount?: true
  }

  export type TaskSumAggregateInputType = {
    taskId?: true
    clientMailSendCount?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    taskId?: true
    clientId?: true
    projectId?: true
    title?: true
    description?: true
    startDate?: true
    dueDate?: true
    assignedToId?: true
    priority?: true
    remarks?: true
    status?: true
    recurrenceRule?: true
    recurrenceEndDate?: true
    isRecurring?: true
    lastGeneratedUntil?: true
    retainSubtasks?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    clientMailSendCount?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    taskId?: true
    clientId?: true
    projectId?: true
    title?: true
    description?: true
    startDate?: true
    dueDate?: true
    assignedToId?: true
    priority?: true
    remarks?: true
    status?: true
    recurrenceRule?: true
    recurrenceEndDate?: true
    isRecurring?: true
    lastGeneratedUntil?: true
    retainSubtasks?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    clientMailSendCount?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    taskId?: true
    clientId?: true
    projectId?: true
    title?: true
    description?: true
    startDate?: true
    dueDate?: true
    assignedToId?: true
    priority?: true
    remarks?: true
    status?: true
    recurrenceRule?: true
    recurrenceEndDate?: true
    isRecurring?: true
    lastGeneratedUntil?: true
    retainSubtasks?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    clientMailSendCount?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    taskId: number
    clientId: string | null
    projectId: string | null
    title: string
    description: string | null
    startDate: Date
    dueDate: Date
    assignedToId: string | null
    priority: $Enums.Priority
    remarks: string | null
    status: $Enums.TaskStatus
    recurrenceRule: string | null
    recurrenceEndDate: Date | null
    isRecurring: boolean
    lastGeneratedUntil: Date | null
    retainSubtasks: boolean
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    clientMailSendCount: number
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    clientId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    dueDate?: boolean
    assignedToId?: boolean
    priority?: boolean
    remarks?: boolean
    status?: boolean
    recurrenceRule?: boolean
    recurrenceEndDate?: boolean
    isRecurring?: boolean
    lastGeneratedUntil?: boolean
    retainSubtasks?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientMailSendCount?: boolean
    assignees?: boolean | Task$assigneesArgs<ExtArgs>
    occurrences?: boolean | Task$occurrencesArgs<ExtArgs>
    reminders?: boolean | Task$remindersArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
    attachments?: boolean | Task$attachmentsArgs<ExtArgs>
    customValues?: boolean | Task$customValuesArgs<ExtArgs>
    emailLogs?: boolean | Task$emailLogsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    clientId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    dueDate?: boolean
    assignedToId?: boolean
    priority?: boolean
    remarks?: boolean
    status?: boolean
    recurrenceRule?: boolean
    recurrenceEndDate?: boolean
    isRecurring?: boolean
    lastGeneratedUntil?: boolean
    retainSubtasks?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientMailSendCount?: boolean
    project?: boolean | Task$projectArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    clientId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    dueDate?: boolean
    assignedToId?: boolean
    priority?: boolean
    remarks?: boolean
    status?: boolean
    recurrenceRule?: boolean
    recurrenceEndDate?: boolean
    isRecurring?: boolean
    lastGeneratedUntil?: boolean
    retainSubtasks?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientMailSendCount?: boolean
    project?: boolean | Task$projectArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    taskId?: boolean
    clientId?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    dueDate?: boolean
    assignedToId?: boolean
    priority?: boolean
    remarks?: boolean
    status?: boolean
    recurrenceRule?: boolean
    recurrenceEndDate?: boolean
    isRecurring?: boolean
    lastGeneratedUntil?: boolean
    retainSubtasks?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientMailSendCount?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "clientId" | "projectId" | "title" | "description" | "startDate" | "dueDate" | "assignedToId" | "priority" | "remarks" | "status" | "recurrenceRule" | "recurrenceEndDate" | "isRecurring" | "lastGeneratedUntil" | "retainSubtasks" | "createdById" | "createdAt" | "updatedAt" | "clientMailSendCount", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignees?: boolean | Task$assigneesArgs<ExtArgs>
    occurrences?: boolean | Task$occurrencesArgs<ExtArgs>
    reminders?: boolean | Task$remindersArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
    attachments?: boolean | Task$attachmentsArgs<ExtArgs>
    customValues?: boolean | Task$customValuesArgs<ExtArgs>
    emailLogs?: boolean | Task$emailLogsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Task$projectArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Task$projectArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      assignees: Prisma.$TaskAssigneePayload<ExtArgs>[]
      occurrences: Prisma.$TaskOccurrencePayload<ExtArgs>[]
      reminders: Prisma.$ReminderPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs> | null
      attachments: Prisma.$TaskAttachmentPayload<ExtArgs>[]
      customValues: Prisma.$TaskCustomValuePayload<ExtArgs>[]
      emailLogs: Prisma.$EmailLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: number
      clientId: string | null
      projectId: string | null
      title: string
      description: string | null
      startDate: Date
      dueDate: Date
      assignedToId: string | null
      priority: $Enums.Priority
      remarks: string | null
      status: $Enums.TaskStatus
      recurrenceRule: string | null
      recurrenceEndDate: Date | null
      isRecurring: boolean
      lastGeneratedUntil: Date | null
      retainSubtasks: boolean
      createdById: string | null
      createdAt: Date
      updatedAt: Date
      clientMailSendCount: number
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignees<T extends Task$assigneesArgs<ExtArgs> = {}>(args?: Subset<T, Task$assigneesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    occurrences<T extends Task$occurrencesArgs<ExtArgs> = {}>(args?: Subset<T, Task$occurrencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reminders<T extends Task$remindersArgs<ExtArgs> = {}>(args?: Subset<T, Task$remindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends Task$projectArgs<ExtArgs> = {}>(args?: Subset<T, Task$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Task$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customValues<T extends Task$customValuesArgs<ExtArgs> = {}>(args?: Subset<T, Task$customValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailLogs<T extends Task$emailLogsArgs<ExtArgs> = {}>(args?: Subset<T, Task$emailLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly taskId: FieldRef<"Task", 'Int'>
    readonly clientId: FieldRef<"Task", 'String'>
    readonly projectId: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly startDate: FieldRef<"Task", 'DateTime'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly assignedToId: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'Priority'>
    readonly remarks: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly recurrenceRule: FieldRef<"Task", 'String'>
    readonly recurrenceEndDate: FieldRef<"Task", 'DateTime'>
    readonly isRecurring: FieldRef<"Task", 'Boolean'>
    readonly lastGeneratedUntil: FieldRef<"Task", 'DateTime'>
    readonly retainSubtasks: FieldRef<"Task", 'Boolean'>
    readonly createdById: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly clientMailSendCount: FieldRef<"Task", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.assignees
   */
  export type Task$assigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    where?: TaskAssigneeWhereInput
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    cursor?: TaskAssigneeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * Task.occurrences
   */
  export type Task$occurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceInclude<ExtArgs> | null
    where?: TaskOccurrenceWhereInput
    orderBy?: TaskOccurrenceOrderByWithRelationInput | TaskOccurrenceOrderByWithRelationInput[]
    cursor?: TaskOccurrenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskOccurrenceScalarFieldEnum | TaskOccurrenceScalarFieldEnum[]
  }

  /**
   * Task.reminders
   */
  export type Task$remindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    where?: ReminderWhereInput
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    cursor?: ReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * Task.project
   */
  export type Task$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Task.attachments
   */
  export type Task$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    where?: TaskAttachmentWhereInput
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    cursor?: TaskAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * Task.customValues
   */
  export type Task$customValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    where?: TaskCustomValueWhereInput
    orderBy?: TaskCustomValueOrderByWithRelationInput | TaskCustomValueOrderByWithRelationInput[]
    cursor?: TaskCustomValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCustomValueScalarFieldEnum | TaskCustomValueScalarFieldEnum[]
  }

  /**
   * Task.emailLogs
   */
  export type Task$emailLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    cursor?: EmailLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskCustomField
   */

  export type AggregateTaskCustomField = {
    _count: TaskCustomFieldCountAggregateOutputType | null
    _min: TaskCustomFieldMinAggregateOutputType | null
    _max: TaskCustomFieldMaxAggregateOutputType | null
  }

  export type TaskCustomFieldMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    type: string | null
    createdAt: Date | null
  }

  export type TaskCustomFieldMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    type: string | null
    createdAt: Date | null
  }

  export type TaskCustomFieldCountAggregateOutputType = {
    id: number
    orgId: number
    name: number
    type: number
    options: number
    createdAt: number
    _all: number
  }


  export type TaskCustomFieldMinAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    type?: true
    createdAt?: true
  }

  export type TaskCustomFieldMaxAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    type?: true
    createdAt?: true
  }

  export type TaskCustomFieldCountAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    type?: true
    options?: true
    createdAt?: true
    _all?: true
  }

  export type TaskCustomFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCustomField to aggregate.
     */
    where?: TaskCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCustomFields to fetch.
     */
    orderBy?: TaskCustomFieldOrderByWithRelationInput | TaskCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskCustomFields
    **/
    _count?: true | TaskCustomFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskCustomFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskCustomFieldMaxAggregateInputType
  }

  export type GetTaskCustomFieldAggregateType<T extends TaskCustomFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskCustomField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskCustomField[P]>
      : GetScalarType<T[P], AggregateTaskCustomField[P]>
  }




  export type TaskCustomFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCustomFieldWhereInput
    orderBy?: TaskCustomFieldOrderByWithAggregationInput | TaskCustomFieldOrderByWithAggregationInput[]
    by: TaskCustomFieldScalarFieldEnum[] | TaskCustomFieldScalarFieldEnum
    having?: TaskCustomFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCustomFieldCountAggregateInputType | true
    _min?: TaskCustomFieldMinAggregateInputType
    _max?: TaskCustomFieldMaxAggregateInputType
  }

  export type TaskCustomFieldGroupByOutputType = {
    id: string
    orgId: string
    name: string
    type: string
    options: string[]
    createdAt: Date
    _count: TaskCustomFieldCountAggregateOutputType | null
    _min: TaskCustomFieldMinAggregateOutputType | null
    _max: TaskCustomFieldMaxAggregateOutputType | null
  }

  type GetTaskCustomFieldGroupByPayload<T extends TaskCustomFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskCustomFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskCustomFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskCustomFieldGroupByOutputType[P]>
            : GetScalarType<T[P], TaskCustomFieldGroupByOutputType[P]>
        }
      >
    >


  export type TaskCustomFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    type?: boolean
    options?: boolean
    createdAt?: boolean
    values?: boolean | TaskCustomField$valuesArgs<ExtArgs>
    _count?: boolean | TaskCustomFieldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCustomField"]>

  export type TaskCustomFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    type?: boolean
    options?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["taskCustomField"]>

  export type TaskCustomFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    type?: boolean
    options?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["taskCustomField"]>

  export type TaskCustomFieldSelectScalar = {
    id?: boolean
    orgId?: boolean
    name?: boolean
    type?: boolean
    options?: boolean
    createdAt?: boolean
  }

  export type TaskCustomFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "name" | "type" | "options" | "createdAt", ExtArgs["result"]["taskCustomField"]>
  export type TaskCustomFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | TaskCustomField$valuesArgs<ExtArgs>
    _count?: boolean | TaskCustomFieldCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskCustomFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TaskCustomFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaskCustomFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskCustomField"
    objects: {
      values: Prisma.$TaskCustomValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      name: string
      type: string
      options: string[]
      createdAt: Date
    }, ExtArgs["result"]["taskCustomField"]>
    composites: {}
  }

  type TaskCustomFieldGetPayload<S extends boolean | null | undefined | TaskCustomFieldDefaultArgs> = $Result.GetResult<Prisma.$TaskCustomFieldPayload, S>

  type TaskCustomFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskCustomFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCustomFieldCountAggregateInputType | true
    }

  export interface TaskCustomFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskCustomField'], meta: { name: 'TaskCustomField' } }
    /**
     * Find zero or one TaskCustomField that matches the filter.
     * @param {TaskCustomFieldFindUniqueArgs} args - Arguments to find a TaskCustomField
     * @example
     * // Get one TaskCustomField
     * const taskCustomField = await prisma.taskCustomField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskCustomFieldFindUniqueArgs>(args: SelectSubset<T, TaskCustomFieldFindUniqueArgs<ExtArgs>>): Prisma__TaskCustomFieldClient<$Result.GetResult<Prisma.$TaskCustomFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskCustomField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskCustomFieldFindUniqueOrThrowArgs} args - Arguments to find a TaskCustomField
     * @example
     * // Get one TaskCustomField
     * const taskCustomField = await prisma.taskCustomField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskCustomFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskCustomFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskCustomFieldClient<$Result.GetResult<Prisma.$TaskCustomFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskCustomField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomFieldFindFirstArgs} args - Arguments to find a TaskCustomField
     * @example
     * // Get one TaskCustomField
     * const taskCustomField = await prisma.taskCustomField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskCustomFieldFindFirstArgs>(args?: SelectSubset<T, TaskCustomFieldFindFirstArgs<ExtArgs>>): Prisma__TaskCustomFieldClient<$Result.GetResult<Prisma.$TaskCustomFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskCustomField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomFieldFindFirstOrThrowArgs} args - Arguments to find a TaskCustomField
     * @example
     * // Get one TaskCustomField
     * const taskCustomField = await prisma.taskCustomField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskCustomFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskCustomFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskCustomFieldClient<$Result.GetResult<Prisma.$TaskCustomFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskCustomFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskCustomFields
     * const taskCustomFields = await prisma.taskCustomField.findMany()
     * 
     * // Get first 10 TaskCustomFields
     * const taskCustomFields = await prisma.taskCustomField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskCustomFieldWithIdOnly = await prisma.taskCustomField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskCustomFieldFindManyArgs>(args?: SelectSubset<T, TaskCustomFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskCustomField.
     * @param {TaskCustomFieldCreateArgs} args - Arguments to create a TaskCustomField.
     * @example
     * // Create one TaskCustomField
     * const TaskCustomField = await prisma.taskCustomField.create({
     *   data: {
     *     // ... data to create a TaskCustomField
     *   }
     * })
     * 
     */
    create<T extends TaskCustomFieldCreateArgs>(args: SelectSubset<T, TaskCustomFieldCreateArgs<ExtArgs>>): Prisma__TaskCustomFieldClient<$Result.GetResult<Prisma.$TaskCustomFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskCustomFields.
     * @param {TaskCustomFieldCreateManyArgs} args - Arguments to create many TaskCustomFields.
     * @example
     * // Create many TaskCustomFields
     * const taskCustomField = await prisma.taskCustomField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCustomFieldCreateManyArgs>(args?: SelectSubset<T, TaskCustomFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskCustomFields and returns the data saved in the database.
     * @param {TaskCustomFieldCreateManyAndReturnArgs} args - Arguments to create many TaskCustomFields.
     * @example
     * // Create many TaskCustomFields
     * const taskCustomField = await prisma.taskCustomField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskCustomFields and only return the `id`
     * const taskCustomFieldWithIdOnly = await prisma.taskCustomField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCustomFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCustomFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskCustomField.
     * @param {TaskCustomFieldDeleteArgs} args - Arguments to delete one TaskCustomField.
     * @example
     * // Delete one TaskCustomField
     * const TaskCustomField = await prisma.taskCustomField.delete({
     *   where: {
     *     // ... filter to delete one TaskCustomField
     *   }
     * })
     * 
     */
    delete<T extends TaskCustomFieldDeleteArgs>(args: SelectSubset<T, TaskCustomFieldDeleteArgs<ExtArgs>>): Prisma__TaskCustomFieldClient<$Result.GetResult<Prisma.$TaskCustomFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskCustomField.
     * @param {TaskCustomFieldUpdateArgs} args - Arguments to update one TaskCustomField.
     * @example
     * // Update one TaskCustomField
     * const taskCustomField = await prisma.taskCustomField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskCustomFieldUpdateArgs>(args: SelectSubset<T, TaskCustomFieldUpdateArgs<ExtArgs>>): Prisma__TaskCustomFieldClient<$Result.GetResult<Prisma.$TaskCustomFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskCustomFields.
     * @param {TaskCustomFieldDeleteManyArgs} args - Arguments to filter TaskCustomFields to delete.
     * @example
     * // Delete a few TaskCustomFields
     * const { count } = await prisma.taskCustomField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskCustomFieldDeleteManyArgs>(args?: SelectSubset<T, TaskCustomFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskCustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskCustomFields
     * const taskCustomField = await prisma.taskCustomField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskCustomFieldUpdateManyArgs>(args: SelectSubset<T, TaskCustomFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskCustomFields and returns the data updated in the database.
     * @param {TaskCustomFieldUpdateManyAndReturnArgs} args - Arguments to update many TaskCustomFields.
     * @example
     * // Update many TaskCustomFields
     * const taskCustomField = await prisma.taskCustomField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskCustomFields and only return the `id`
     * const taskCustomFieldWithIdOnly = await prisma.taskCustomField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskCustomFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskCustomFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskCustomField.
     * @param {TaskCustomFieldUpsertArgs} args - Arguments to update or create a TaskCustomField.
     * @example
     * // Update or create a TaskCustomField
     * const taskCustomField = await prisma.taskCustomField.upsert({
     *   create: {
     *     // ... data to create a TaskCustomField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskCustomField we want to update
     *   }
     * })
     */
    upsert<T extends TaskCustomFieldUpsertArgs>(args: SelectSubset<T, TaskCustomFieldUpsertArgs<ExtArgs>>): Prisma__TaskCustomFieldClient<$Result.GetResult<Prisma.$TaskCustomFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskCustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomFieldCountArgs} args - Arguments to filter TaskCustomFields to count.
     * @example
     * // Count the number of TaskCustomFields
     * const count = await prisma.taskCustomField.count({
     *   where: {
     *     // ... the filter for the TaskCustomFields we want to count
     *   }
     * })
    **/
    count<T extends TaskCustomFieldCountArgs>(
      args?: Subset<T, TaskCustomFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCustomFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskCustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskCustomFieldAggregateArgs>(args: Subset<T, TaskCustomFieldAggregateArgs>): Prisma.PrismaPromise<GetTaskCustomFieldAggregateType<T>>

    /**
     * Group by TaskCustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskCustomFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskCustomFieldGroupByArgs['orderBy'] }
        : { orderBy?: TaskCustomFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskCustomFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskCustomFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskCustomField model
   */
  readonly fields: TaskCustomFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskCustomField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskCustomFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    values<T extends TaskCustomField$valuesArgs<ExtArgs> = {}>(args?: Subset<T, TaskCustomField$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskCustomField model
   */
  interface TaskCustomFieldFieldRefs {
    readonly id: FieldRef<"TaskCustomField", 'String'>
    readonly orgId: FieldRef<"TaskCustomField", 'String'>
    readonly name: FieldRef<"TaskCustomField", 'String'>
    readonly type: FieldRef<"TaskCustomField", 'String'>
    readonly options: FieldRef<"TaskCustomField", 'String[]'>
    readonly createdAt: FieldRef<"TaskCustomField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskCustomField findUnique
   */
  export type TaskCustomFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomField
     */
    select?: TaskCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomField
     */
    omit?: TaskCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomField to fetch.
     */
    where: TaskCustomFieldWhereUniqueInput
  }

  /**
   * TaskCustomField findUniqueOrThrow
   */
  export type TaskCustomFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomField
     */
    select?: TaskCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomField
     */
    omit?: TaskCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomField to fetch.
     */
    where: TaskCustomFieldWhereUniqueInput
  }

  /**
   * TaskCustomField findFirst
   */
  export type TaskCustomFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomField
     */
    select?: TaskCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomField
     */
    omit?: TaskCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomField to fetch.
     */
    where?: TaskCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCustomFields to fetch.
     */
    orderBy?: TaskCustomFieldOrderByWithRelationInput | TaskCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCustomFields.
     */
    cursor?: TaskCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCustomFields.
     */
    distinct?: TaskCustomFieldScalarFieldEnum | TaskCustomFieldScalarFieldEnum[]
  }

  /**
   * TaskCustomField findFirstOrThrow
   */
  export type TaskCustomFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomField
     */
    select?: TaskCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomField
     */
    omit?: TaskCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomField to fetch.
     */
    where?: TaskCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCustomFields to fetch.
     */
    orderBy?: TaskCustomFieldOrderByWithRelationInput | TaskCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCustomFields.
     */
    cursor?: TaskCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCustomFields.
     */
    distinct?: TaskCustomFieldScalarFieldEnum | TaskCustomFieldScalarFieldEnum[]
  }

  /**
   * TaskCustomField findMany
   */
  export type TaskCustomFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomField
     */
    select?: TaskCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomField
     */
    omit?: TaskCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomFields to fetch.
     */
    where?: TaskCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCustomFields to fetch.
     */
    orderBy?: TaskCustomFieldOrderByWithRelationInput | TaskCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskCustomFields.
     */
    cursor?: TaskCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCustomFields.
     */
    skip?: number
    distinct?: TaskCustomFieldScalarFieldEnum | TaskCustomFieldScalarFieldEnum[]
  }

  /**
   * TaskCustomField create
   */
  export type TaskCustomFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomField
     */
    select?: TaskCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomField
     */
    omit?: TaskCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskCustomField.
     */
    data: XOR<TaskCustomFieldCreateInput, TaskCustomFieldUncheckedCreateInput>
  }

  /**
   * TaskCustomField createMany
   */
  export type TaskCustomFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskCustomFields.
     */
    data: TaskCustomFieldCreateManyInput | TaskCustomFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskCustomField createManyAndReturn
   */
  export type TaskCustomFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomField
     */
    select?: TaskCustomFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomField
     */
    omit?: TaskCustomFieldOmit<ExtArgs> | null
    /**
     * The data used to create many TaskCustomFields.
     */
    data: TaskCustomFieldCreateManyInput | TaskCustomFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskCustomField update
   */
  export type TaskCustomFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomField
     */
    select?: TaskCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomField
     */
    omit?: TaskCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskCustomField.
     */
    data: XOR<TaskCustomFieldUpdateInput, TaskCustomFieldUncheckedUpdateInput>
    /**
     * Choose, which TaskCustomField to update.
     */
    where: TaskCustomFieldWhereUniqueInput
  }

  /**
   * TaskCustomField updateMany
   */
  export type TaskCustomFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskCustomFields.
     */
    data: XOR<TaskCustomFieldUpdateManyMutationInput, TaskCustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which TaskCustomFields to update
     */
    where?: TaskCustomFieldWhereInput
    /**
     * Limit how many TaskCustomFields to update.
     */
    limit?: number
  }

  /**
   * TaskCustomField updateManyAndReturn
   */
  export type TaskCustomFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomField
     */
    select?: TaskCustomFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomField
     */
    omit?: TaskCustomFieldOmit<ExtArgs> | null
    /**
     * The data used to update TaskCustomFields.
     */
    data: XOR<TaskCustomFieldUpdateManyMutationInput, TaskCustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which TaskCustomFields to update
     */
    where?: TaskCustomFieldWhereInput
    /**
     * Limit how many TaskCustomFields to update.
     */
    limit?: number
  }

  /**
   * TaskCustomField upsert
   */
  export type TaskCustomFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomField
     */
    select?: TaskCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomField
     */
    omit?: TaskCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskCustomField to update in case it exists.
     */
    where: TaskCustomFieldWhereUniqueInput
    /**
     * In case the TaskCustomField found by the `where` argument doesn't exist, create a new TaskCustomField with this data.
     */
    create: XOR<TaskCustomFieldCreateInput, TaskCustomFieldUncheckedCreateInput>
    /**
     * In case the TaskCustomField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskCustomFieldUpdateInput, TaskCustomFieldUncheckedUpdateInput>
  }

  /**
   * TaskCustomField delete
   */
  export type TaskCustomFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomField
     */
    select?: TaskCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomField
     */
    omit?: TaskCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomFieldInclude<ExtArgs> | null
    /**
     * Filter which TaskCustomField to delete.
     */
    where: TaskCustomFieldWhereUniqueInput
  }

  /**
   * TaskCustomField deleteMany
   */
  export type TaskCustomFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCustomFields to delete
     */
    where?: TaskCustomFieldWhereInput
    /**
     * Limit how many TaskCustomFields to delete.
     */
    limit?: number
  }

  /**
   * TaskCustomField.values
   */
  export type TaskCustomField$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    where?: TaskCustomValueWhereInput
    orderBy?: TaskCustomValueOrderByWithRelationInput | TaskCustomValueOrderByWithRelationInput[]
    cursor?: TaskCustomValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCustomValueScalarFieldEnum | TaskCustomValueScalarFieldEnum[]
  }

  /**
   * TaskCustomField without action
   */
  export type TaskCustomFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomField
     */
    select?: TaskCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomField
     */
    omit?: TaskCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomFieldInclude<ExtArgs> | null
  }


  /**
   * Model TaskCustomValue
   */

  export type AggregateTaskCustomValue = {
    _count: TaskCustomValueCountAggregateOutputType | null
    _min: TaskCustomValueMinAggregateOutputType | null
    _max: TaskCustomValueMaxAggregateOutputType | null
  }

  export type TaskCustomValueMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    fieldId: string | null
    value: string | null
  }

  export type TaskCustomValueMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    fieldId: string | null
    value: string | null
  }

  export type TaskCustomValueCountAggregateOutputType = {
    id: number
    taskId: number
    fieldId: number
    value: number
    _all: number
  }


  export type TaskCustomValueMinAggregateInputType = {
    id?: true
    taskId?: true
    fieldId?: true
    value?: true
  }

  export type TaskCustomValueMaxAggregateInputType = {
    id?: true
    taskId?: true
    fieldId?: true
    value?: true
  }

  export type TaskCustomValueCountAggregateInputType = {
    id?: true
    taskId?: true
    fieldId?: true
    value?: true
    _all?: true
  }

  export type TaskCustomValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCustomValue to aggregate.
     */
    where?: TaskCustomValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCustomValues to fetch.
     */
    orderBy?: TaskCustomValueOrderByWithRelationInput | TaskCustomValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskCustomValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCustomValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCustomValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskCustomValues
    **/
    _count?: true | TaskCustomValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskCustomValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskCustomValueMaxAggregateInputType
  }

  export type GetTaskCustomValueAggregateType<T extends TaskCustomValueAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskCustomValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskCustomValue[P]>
      : GetScalarType<T[P], AggregateTaskCustomValue[P]>
  }




  export type TaskCustomValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCustomValueWhereInput
    orderBy?: TaskCustomValueOrderByWithAggregationInput | TaskCustomValueOrderByWithAggregationInput[]
    by: TaskCustomValueScalarFieldEnum[] | TaskCustomValueScalarFieldEnum
    having?: TaskCustomValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCustomValueCountAggregateInputType | true
    _min?: TaskCustomValueMinAggregateInputType
    _max?: TaskCustomValueMaxAggregateInputType
  }

  export type TaskCustomValueGroupByOutputType = {
    id: string
    taskId: string
    fieldId: string
    value: string
    _count: TaskCustomValueCountAggregateOutputType | null
    _min: TaskCustomValueMinAggregateOutputType | null
    _max: TaskCustomValueMaxAggregateOutputType | null
  }

  type GetTaskCustomValueGroupByPayload<T extends TaskCustomValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskCustomValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskCustomValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskCustomValueGroupByOutputType[P]>
            : GetScalarType<T[P], TaskCustomValueGroupByOutputType[P]>
        }
      >
    >


  export type TaskCustomValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    fieldId?: boolean
    value?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    field?: boolean | TaskCustomFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCustomValue"]>

  export type TaskCustomValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    fieldId?: boolean
    value?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    field?: boolean | TaskCustomFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCustomValue"]>

  export type TaskCustomValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    fieldId?: boolean
    value?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    field?: boolean | TaskCustomFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCustomValue"]>

  export type TaskCustomValueSelectScalar = {
    id?: boolean
    taskId?: boolean
    fieldId?: boolean
    value?: boolean
  }

  export type TaskCustomValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "fieldId" | "value", ExtArgs["result"]["taskCustomValue"]>
  export type TaskCustomValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    field?: boolean | TaskCustomFieldDefaultArgs<ExtArgs>
  }
  export type TaskCustomValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    field?: boolean | TaskCustomFieldDefaultArgs<ExtArgs>
  }
  export type TaskCustomValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    field?: boolean | TaskCustomFieldDefaultArgs<ExtArgs>
  }

  export type $TaskCustomValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskCustomValue"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      field: Prisma.$TaskCustomFieldPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      fieldId: string
      value: string
    }, ExtArgs["result"]["taskCustomValue"]>
    composites: {}
  }

  type TaskCustomValueGetPayload<S extends boolean | null | undefined | TaskCustomValueDefaultArgs> = $Result.GetResult<Prisma.$TaskCustomValuePayload, S>

  type TaskCustomValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskCustomValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCustomValueCountAggregateInputType | true
    }

  export interface TaskCustomValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskCustomValue'], meta: { name: 'TaskCustomValue' } }
    /**
     * Find zero or one TaskCustomValue that matches the filter.
     * @param {TaskCustomValueFindUniqueArgs} args - Arguments to find a TaskCustomValue
     * @example
     * // Get one TaskCustomValue
     * const taskCustomValue = await prisma.taskCustomValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskCustomValueFindUniqueArgs>(args: SelectSubset<T, TaskCustomValueFindUniqueArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskCustomValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskCustomValueFindUniqueOrThrowArgs} args - Arguments to find a TaskCustomValue
     * @example
     * // Get one TaskCustomValue
     * const taskCustomValue = await prisma.taskCustomValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskCustomValueFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskCustomValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskCustomValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueFindFirstArgs} args - Arguments to find a TaskCustomValue
     * @example
     * // Get one TaskCustomValue
     * const taskCustomValue = await prisma.taskCustomValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskCustomValueFindFirstArgs>(args?: SelectSubset<T, TaskCustomValueFindFirstArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskCustomValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueFindFirstOrThrowArgs} args - Arguments to find a TaskCustomValue
     * @example
     * // Get one TaskCustomValue
     * const taskCustomValue = await prisma.taskCustomValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskCustomValueFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskCustomValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskCustomValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskCustomValues
     * const taskCustomValues = await prisma.taskCustomValue.findMany()
     * 
     * // Get first 10 TaskCustomValues
     * const taskCustomValues = await prisma.taskCustomValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskCustomValueWithIdOnly = await prisma.taskCustomValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskCustomValueFindManyArgs>(args?: SelectSubset<T, TaskCustomValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskCustomValue.
     * @param {TaskCustomValueCreateArgs} args - Arguments to create a TaskCustomValue.
     * @example
     * // Create one TaskCustomValue
     * const TaskCustomValue = await prisma.taskCustomValue.create({
     *   data: {
     *     // ... data to create a TaskCustomValue
     *   }
     * })
     * 
     */
    create<T extends TaskCustomValueCreateArgs>(args: SelectSubset<T, TaskCustomValueCreateArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskCustomValues.
     * @param {TaskCustomValueCreateManyArgs} args - Arguments to create many TaskCustomValues.
     * @example
     * // Create many TaskCustomValues
     * const taskCustomValue = await prisma.taskCustomValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCustomValueCreateManyArgs>(args?: SelectSubset<T, TaskCustomValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskCustomValues and returns the data saved in the database.
     * @param {TaskCustomValueCreateManyAndReturnArgs} args - Arguments to create many TaskCustomValues.
     * @example
     * // Create many TaskCustomValues
     * const taskCustomValue = await prisma.taskCustomValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskCustomValues and only return the `id`
     * const taskCustomValueWithIdOnly = await prisma.taskCustomValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCustomValueCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCustomValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskCustomValue.
     * @param {TaskCustomValueDeleteArgs} args - Arguments to delete one TaskCustomValue.
     * @example
     * // Delete one TaskCustomValue
     * const TaskCustomValue = await prisma.taskCustomValue.delete({
     *   where: {
     *     // ... filter to delete one TaskCustomValue
     *   }
     * })
     * 
     */
    delete<T extends TaskCustomValueDeleteArgs>(args: SelectSubset<T, TaskCustomValueDeleteArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskCustomValue.
     * @param {TaskCustomValueUpdateArgs} args - Arguments to update one TaskCustomValue.
     * @example
     * // Update one TaskCustomValue
     * const taskCustomValue = await prisma.taskCustomValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskCustomValueUpdateArgs>(args: SelectSubset<T, TaskCustomValueUpdateArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskCustomValues.
     * @param {TaskCustomValueDeleteManyArgs} args - Arguments to filter TaskCustomValues to delete.
     * @example
     * // Delete a few TaskCustomValues
     * const { count } = await prisma.taskCustomValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskCustomValueDeleteManyArgs>(args?: SelectSubset<T, TaskCustomValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskCustomValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskCustomValues
     * const taskCustomValue = await prisma.taskCustomValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskCustomValueUpdateManyArgs>(args: SelectSubset<T, TaskCustomValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskCustomValues and returns the data updated in the database.
     * @param {TaskCustomValueUpdateManyAndReturnArgs} args - Arguments to update many TaskCustomValues.
     * @example
     * // Update many TaskCustomValues
     * const taskCustomValue = await prisma.taskCustomValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskCustomValues and only return the `id`
     * const taskCustomValueWithIdOnly = await prisma.taskCustomValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskCustomValueUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskCustomValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskCustomValue.
     * @param {TaskCustomValueUpsertArgs} args - Arguments to update or create a TaskCustomValue.
     * @example
     * // Update or create a TaskCustomValue
     * const taskCustomValue = await prisma.taskCustomValue.upsert({
     *   create: {
     *     // ... data to create a TaskCustomValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskCustomValue we want to update
     *   }
     * })
     */
    upsert<T extends TaskCustomValueUpsertArgs>(args: SelectSubset<T, TaskCustomValueUpsertArgs<ExtArgs>>): Prisma__TaskCustomValueClient<$Result.GetResult<Prisma.$TaskCustomValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskCustomValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueCountArgs} args - Arguments to filter TaskCustomValues to count.
     * @example
     * // Count the number of TaskCustomValues
     * const count = await prisma.taskCustomValue.count({
     *   where: {
     *     // ... the filter for the TaskCustomValues we want to count
     *   }
     * })
    **/
    count<T extends TaskCustomValueCountArgs>(
      args?: Subset<T, TaskCustomValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCustomValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskCustomValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskCustomValueAggregateArgs>(args: Subset<T, TaskCustomValueAggregateArgs>): Prisma.PrismaPromise<GetTaskCustomValueAggregateType<T>>

    /**
     * Group by TaskCustomValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCustomValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskCustomValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskCustomValueGroupByArgs['orderBy'] }
        : { orderBy?: TaskCustomValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskCustomValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskCustomValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskCustomValue model
   */
  readonly fields: TaskCustomValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskCustomValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskCustomValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    field<T extends TaskCustomFieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskCustomFieldDefaultArgs<ExtArgs>>): Prisma__TaskCustomFieldClient<$Result.GetResult<Prisma.$TaskCustomFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskCustomValue model
   */
  interface TaskCustomValueFieldRefs {
    readonly id: FieldRef<"TaskCustomValue", 'String'>
    readonly taskId: FieldRef<"TaskCustomValue", 'String'>
    readonly fieldId: FieldRef<"TaskCustomValue", 'String'>
    readonly value: FieldRef<"TaskCustomValue", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskCustomValue findUnique
   */
  export type TaskCustomValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomValue to fetch.
     */
    where: TaskCustomValueWhereUniqueInput
  }

  /**
   * TaskCustomValue findUniqueOrThrow
   */
  export type TaskCustomValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomValue to fetch.
     */
    where: TaskCustomValueWhereUniqueInput
  }

  /**
   * TaskCustomValue findFirst
   */
  export type TaskCustomValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomValue to fetch.
     */
    where?: TaskCustomValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCustomValues to fetch.
     */
    orderBy?: TaskCustomValueOrderByWithRelationInput | TaskCustomValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCustomValues.
     */
    cursor?: TaskCustomValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCustomValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCustomValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCustomValues.
     */
    distinct?: TaskCustomValueScalarFieldEnum | TaskCustomValueScalarFieldEnum[]
  }

  /**
   * TaskCustomValue findFirstOrThrow
   */
  export type TaskCustomValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomValue to fetch.
     */
    where?: TaskCustomValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCustomValues to fetch.
     */
    orderBy?: TaskCustomValueOrderByWithRelationInput | TaskCustomValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCustomValues.
     */
    cursor?: TaskCustomValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCustomValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCustomValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCustomValues.
     */
    distinct?: TaskCustomValueScalarFieldEnum | TaskCustomValueScalarFieldEnum[]
  }

  /**
   * TaskCustomValue findMany
   */
  export type TaskCustomValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * Filter, which TaskCustomValues to fetch.
     */
    where?: TaskCustomValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCustomValues to fetch.
     */
    orderBy?: TaskCustomValueOrderByWithRelationInput | TaskCustomValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskCustomValues.
     */
    cursor?: TaskCustomValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCustomValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCustomValues.
     */
    skip?: number
    distinct?: TaskCustomValueScalarFieldEnum | TaskCustomValueScalarFieldEnum[]
  }

  /**
   * TaskCustomValue create
   */
  export type TaskCustomValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskCustomValue.
     */
    data: XOR<TaskCustomValueCreateInput, TaskCustomValueUncheckedCreateInput>
  }

  /**
   * TaskCustomValue createMany
   */
  export type TaskCustomValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskCustomValues.
     */
    data: TaskCustomValueCreateManyInput | TaskCustomValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskCustomValue createManyAndReturn
   */
  export type TaskCustomValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * The data used to create many TaskCustomValues.
     */
    data: TaskCustomValueCreateManyInput | TaskCustomValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskCustomValue update
   */
  export type TaskCustomValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskCustomValue.
     */
    data: XOR<TaskCustomValueUpdateInput, TaskCustomValueUncheckedUpdateInput>
    /**
     * Choose, which TaskCustomValue to update.
     */
    where: TaskCustomValueWhereUniqueInput
  }

  /**
   * TaskCustomValue updateMany
   */
  export type TaskCustomValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskCustomValues.
     */
    data: XOR<TaskCustomValueUpdateManyMutationInput, TaskCustomValueUncheckedUpdateManyInput>
    /**
     * Filter which TaskCustomValues to update
     */
    where?: TaskCustomValueWhereInput
    /**
     * Limit how many TaskCustomValues to update.
     */
    limit?: number
  }

  /**
   * TaskCustomValue updateManyAndReturn
   */
  export type TaskCustomValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * The data used to update TaskCustomValues.
     */
    data: XOR<TaskCustomValueUpdateManyMutationInput, TaskCustomValueUncheckedUpdateManyInput>
    /**
     * Filter which TaskCustomValues to update
     */
    where?: TaskCustomValueWhereInput
    /**
     * Limit how many TaskCustomValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskCustomValue upsert
   */
  export type TaskCustomValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskCustomValue to update in case it exists.
     */
    where: TaskCustomValueWhereUniqueInput
    /**
     * In case the TaskCustomValue found by the `where` argument doesn't exist, create a new TaskCustomValue with this data.
     */
    create: XOR<TaskCustomValueCreateInput, TaskCustomValueUncheckedCreateInput>
    /**
     * In case the TaskCustomValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskCustomValueUpdateInput, TaskCustomValueUncheckedUpdateInput>
  }

  /**
   * TaskCustomValue delete
   */
  export type TaskCustomValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
    /**
     * Filter which TaskCustomValue to delete.
     */
    where: TaskCustomValueWhereUniqueInput
  }

  /**
   * TaskCustomValue deleteMany
   */
  export type TaskCustomValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCustomValues to delete
     */
    where?: TaskCustomValueWhereInput
    /**
     * Limit how many TaskCustomValues to delete.
     */
    limit?: number
  }

  /**
   * TaskCustomValue without action
   */
  export type TaskCustomValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCustomValue
     */
    select?: TaskCustomValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCustomValue
     */
    omit?: TaskCustomValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCustomValueInclude<ExtArgs> | null
  }


  /**
   * Model TaskOccurrence
   */

  export type AggregateTaskOccurrence = {
    _count: TaskOccurrenceCountAggregateOutputType | null
    _avg: TaskOccurrenceAvgAggregateOutputType | null
    _sum: TaskOccurrenceSumAggregateOutputType | null
    _min: TaskOccurrenceMinAggregateOutputType | null
    _max: TaskOccurrenceMaxAggregateOutputType | null
  }

  export type TaskOccurrenceAvgAggregateOutputType = {
    occurrenceIndex: number | null
    sequentialId: number | null
    clientMailSendCount: number | null
  }

  export type TaskOccurrenceSumAggregateOutputType = {
    occurrenceIndex: number | null
    sequentialId: number | null
    clientMailSendCount: number | null
  }

  export type TaskOccurrenceMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    dueDate: Date | null
    assignedToId: string | null
    priority: $Enums.Priority | null
    remarks: string | null
    status: $Enums.TaskStatus | null
    occurrenceIndex: number | null
    isCompleted: boolean | null
    completedAt: Date | null
    completedBy: string | null
    completionNote: string | null
    clientId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sequentialId: number | null
    clientMailSendCount: number | null
    startEmailSent: boolean | null
    startEmailSentAt: Date | null
  }

  export type TaskOccurrenceMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    dueDate: Date | null
    assignedToId: string | null
    priority: $Enums.Priority | null
    remarks: string | null
    status: $Enums.TaskStatus | null
    occurrenceIndex: number | null
    isCompleted: boolean | null
    completedAt: Date | null
    completedBy: string | null
    completionNote: string | null
    clientId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sequentialId: number | null
    clientMailSendCount: number | null
    startEmailSent: boolean | null
    startEmailSentAt: Date | null
  }

  export type TaskOccurrenceCountAggregateOutputType = {
    id: number
    taskId: number
    title: number
    description: number
    startDate: number
    dueDate: number
    assignedToId: number
    priority: number
    remarks: number
    status: number
    occurrenceIndex: number
    isCompleted: number
    completedAt: number
    completedBy: number
    completionNote: number
    clientId: number
    projectId: number
    createdAt: number
    updatedAt: number
    sequentialId: number
    clientMailSendCount: number
    startEmailSent: number
    startEmailSentAt: number
    _all: number
  }


  export type TaskOccurrenceAvgAggregateInputType = {
    occurrenceIndex?: true
    sequentialId?: true
    clientMailSendCount?: true
  }

  export type TaskOccurrenceSumAggregateInputType = {
    occurrenceIndex?: true
    sequentialId?: true
    clientMailSendCount?: true
  }

  export type TaskOccurrenceMinAggregateInputType = {
    id?: true
    taskId?: true
    title?: true
    description?: true
    startDate?: true
    dueDate?: true
    assignedToId?: true
    priority?: true
    remarks?: true
    status?: true
    occurrenceIndex?: true
    isCompleted?: true
    completedAt?: true
    completedBy?: true
    completionNote?: true
    clientId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    sequentialId?: true
    clientMailSendCount?: true
    startEmailSent?: true
    startEmailSentAt?: true
  }

  export type TaskOccurrenceMaxAggregateInputType = {
    id?: true
    taskId?: true
    title?: true
    description?: true
    startDate?: true
    dueDate?: true
    assignedToId?: true
    priority?: true
    remarks?: true
    status?: true
    occurrenceIndex?: true
    isCompleted?: true
    completedAt?: true
    completedBy?: true
    completionNote?: true
    clientId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    sequentialId?: true
    clientMailSendCount?: true
    startEmailSent?: true
    startEmailSentAt?: true
  }

  export type TaskOccurrenceCountAggregateInputType = {
    id?: true
    taskId?: true
    title?: true
    description?: true
    startDate?: true
    dueDate?: true
    assignedToId?: true
    priority?: true
    remarks?: true
    status?: true
    occurrenceIndex?: true
    isCompleted?: true
    completedAt?: true
    completedBy?: true
    completionNote?: true
    clientId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    sequentialId?: true
    clientMailSendCount?: true
    startEmailSent?: true
    startEmailSentAt?: true
    _all?: true
  }

  export type TaskOccurrenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskOccurrence to aggregate.
     */
    where?: TaskOccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOccurrences to fetch.
     */
    orderBy?: TaskOccurrenceOrderByWithRelationInput | TaskOccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskOccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOccurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOccurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskOccurrences
    **/
    _count?: true | TaskOccurrenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskOccurrenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskOccurrenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskOccurrenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskOccurrenceMaxAggregateInputType
  }

  export type GetTaskOccurrenceAggregateType<T extends TaskOccurrenceAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskOccurrence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskOccurrence[P]>
      : GetScalarType<T[P], AggregateTaskOccurrence[P]>
  }




  export type TaskOccurrenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskOccurrenceWhereInput
    orderBy?: TaskOccurrenceOrderByWithAggregationInput | TaskOccurrenceOrderByWithAggregationInput[]
    by: TaskOccurrenceScalarFieldEnum[] | TaskOccurrenceScalarFieldEnum
    having?: TaskOccurrenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskOccurrenceCountAggregateInputType | true
    _avg?: TaskOccurrenceAvgAggregateInputType
    _sum?: TaskOccurrenceSumAggregateInputType
    _min?: TaskOccurrenceMinAggregateInputType
    _max?: TaskOccurrenceMaxAggregateInputType
  }

  export type TaskOccurrenceGroupByOutputType = {
    id: string
    taskId: string
    title: string
    description: string | null
    startDate: Date
    dueDate: Date
    assignedToId: string | null
    priority: $Enums.Priority
    remarks: string | null
    status: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted: boolean
    completedAt: Date | null
    completedBy: string | null
    completionNote: string | null
    clientId: string | null
    projectId: string | null
    createdAt: Date
    updatedAt: Date
    sequentialId: number
    clientMailSendCount: number
    startEmailSent: boolean
    startEmailSentAt: Date | null
    _count: TaskOccurrenceCountAggregateOutputType | null
    _avg: TaskOccurrenceAvgAggregateOutputType | null
    _sum: TaskOccurrenceSumAggregateOutputType | null
    _min: TaskOccurrenceMinAggregateOutputType | null
    _max: TaskOccurrenceMaxAggregateOutputType | null
  }

  type GetTaskOccurrenceGroupByPayload<T extends TaskOccurrenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskOccurrenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskOccurrenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskOccurrenceGroupByOutputType[P]>
            : GetScalarType<T[P], TaskOccurrenceGroupByOutputType[P]>
        }
      >
    >


  export type TaskOccurrenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    dueDate?: boolean
    assignedToId?: boolean
    priority?: boolean
    remarks?: boolean
    status?: boolean
    occurrenceIndex?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    completedBy?: boolean
    completionNote?: boolean
    clientId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sequentialId?: boolean
    clientMailSendCount?: boolean
    startEmailSent?: boolean
    startEmailSentAt?: boolean
    assignees?: boolean | TaskOccurrence$assigneesArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    attachments?: boolean | TaskOccurrence$attachmentsArgs<ExtArgs>
    emailLogs?: boolean | TaskOccurrence$emailLogsArgs<ExtArgs>
    _count?: boolean | TaskOccurrenceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskOccurrence"]>

  export type TaskOccurrenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    dueDate?: boolean
    assignedToId?: boolean
    priority?: boolean
    remarks?: boolean
    status?: boolean
    occurrenceIndex?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    completedBy?: boolean
    completionNote?: boolean
    clientId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sequentialId?: boolean
    clientMailSendCount?: boolean
    startEmailSent?: boolean
    startEmailSentAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskOccurrence"]>

  export type TaskOccurrenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    dueDate?: boolean
    assignedToId?: boolean
    priority?: boolean
    remarks?: boolean
    status?: boolean
    occurrenceIndex?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    completedBy?: boolean
    completionNote?: boolean
    clientId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sequentialId?: boolean
    clientMailSendCount?: boolean
    startEmailSent?: boolean
    startEmailSentAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskOccurrence"]>

  export type TaskOccurrenceSelectScalar = {
    id?: boolean
    taskId?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    dueDate?: boolean
    assignedToId?: boolean
    priority?: boolean
    remarks?: boolean
    status?: boolean
    occurrenceIndex?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    completedBy?: boolean
    completionNote?: boolean
    clientId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sequentialId?: boolean
    clientMailSendCount?: boolean
    startEmailSent?: boolean
    startEmailSentAt?: boolean
  }

  export type TaskOccurrenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "title" | "description" | "startDate" | "dueDate" | "assignedToId" | "priority" | "remarks" | "status" | "occurrenceIndex" | "isCompleted" | "completedAt" | "completedBy" | "completionNote" | "clientId" | "projectId" | "createdAt" | "updatedAt" | "sequentialId" | "clientMailSendCount" | "startEmailSent" | "startEmailSentAt", ExtArgs["result"]["taskOccurrence"]>
  export type TaskOccurrenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignees?: boolean | TaskOccurrence$assigneesArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    attachments?: boolean | TaskOccurrence$attachmentsArgs<ExtArgs>
    emailLogs?: boolean | TaskOccurrence$emailLogsArgs<ExtArgs>
    _count?: boolean | TaskOccurrenceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskOccurrenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskOccurrenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskOccurrencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskOccurrence"
    objects: {
      assignees: Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>[]
      task: Prisma.$TaskPayload<ExtArgs>
      attachments: Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>[]
      emailLogs: Prisma.$EmailLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      title: string
      description: string | null
      startDate: Date
      dueDate: Date
      assignedToId: string | null
      priority: $Enums.Priority
      remarks: string | null
      status: $Enums.TaskStatus
      occurrenceIndex: number
      isCompleted: boolean
      completedAt: Date | null
      completedBy: string | null
      completionNote: string | null
      clientId: string | null
      projectId: string | null
      createdAt: Date
      updatedAt: Date
      sequentialId: number
      clientMailSendCount: number
      startEmailSent: boolean
      startEmailSentAt: Date | null
    }, ExtArgs["result"]["taskOccurrence"]>
    composites: {}
  }

  type TaskOccurrenceGetPayload<S extends boolean | null | undefined | TaskOccurrenceDefaultArgs> = $Result.GetResult<Prisma.$TaskOccurrencePayload, S>

  type TaskOccurrenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskOccurrenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskOccurrenceCountAggregateInputType | true
    }

  export interface TaskOccurrenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskOccurrence'], meta: { name: 'TaskOccurrence' } }
    /**
     * Find zero or one TaskOccurrence that matches the filter.
     * @param {TaskOccurrenceFindUniqueArgs} args - Arguments to find a TaskOccurrence
     * @example
     * // Get one TaskOccurrence
     * const taskOccurrence = await prisma.taskOccurrence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskOccurrenceFindUniqueArgs>(args: SelectSubset<T, TaskOccurrenceFindUniqueArgs<ExtArgs>>): Prisma__TaskOccurrenceClient<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskOccurrence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskOccurrenceFindUniqueOrThrowArgs} args - Arguments to find a TaskOccurrence
     * @example
     * // Get one TaskOccurrence
     * const taskOccurrence = await prisma.taskOccurrence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskOccurrenceFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskOccurrenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskOccurrenceClient<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskOccurrence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceFindFirstArgs} args - Arguments to find a TaskOccurrence
     * @example
     * // Get one TaskOccurrence
     * const taskOccurrence = await prisma.taskOccurrence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskOccurrenceFindFirstArgs>(args?: SelectSubset<T, TaskOccurrenceFindFirstArgs<ExtArgs>>): Prisma__TaskOccurrenceClient<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskOccurrence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceFindFirstOrThrowArgs} args - Arguments to find a TaskOccurrence
     * @example
     * // Get one TaskOccurrence
     * const taskOccurrence = await prisma.taskOccurrence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskOccurrenceFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskOccurrenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskOccurrenceClient<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskOccurrences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskOccurrences
     * const taskOccurrences = await prisma.taskOccurrence.findMany()
     * 
     * // Get first 10 TaskOccurrences
     * const taskOccurrences = await prisma.taskOccurrence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskOccurrenceWithIdOnly = await prisma.taskOccurrence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskOccurrenceFindManyArgs>(args?: SelectSubset<T, TaskOccurrenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskOccurrence.
     * @param {TaskOccurrenceCreateArgs} args - Arguments to create a TaskOccurrence.
     * @example
     * // Create one TaskOccurrence
     * const TaskOccurrence = await prisma.taskOccurrence.create({
     *   data: {
     *     // ... data to create a TaskOccurrence
     *   }
     * })
     * 
     */
    create<T extends TaskOccurrenceCreateArgs>(args: SelectSubset<T, TaskOccurrenceCreateArgs<ExtArgs>>): Prisma__TaskOccurrenceClient<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskOccurrences.
     * @param {TaskOccurrenceCreateManyArgs} args - Arguments to create many TaskOccurrences.
     * @example
     * // Create many TaskOccurrences
     * const taskOccurrence = await prisma.taskOccurrence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskOccurrenceCreateManyArgs>(args?: SelectSubset<T, TaskOccurrenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskOccurrences and returns the data saved in the database.
     * @param {TaskOccurrenceCreateManyAndReturnArgs} args - Arguments to create many TaskOccurrences.
     * @example
     * // Create many TaskOccurrences
     * const taskOccurrence = await prisma.taskOccurrence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskOccurrences and only return the `id`
     * const taskOccurrenceWithIdOnly = await prisma.taskOccurrence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskOccurrenceCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskOccurrenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskOccurrence.
     * @param {TaskOccurrenceDeleteArgs} args - Arguments to delete one TaskOccurrence.
     * @example
     * // Delete one TaskOccurrence
     * const TaskOccurrence = await prisma.taskOccurrence.delete({
     *   where: {
     *     // ... filter to delete one TaskOccurrence
     *   }
     * })
     * 
     */
    delete<T extends TaskOccurrenceDeleteArgs>(args: SelectSubset<T, TaskOccurrenceDeleteArgs<ExtArgs>>): Prisma__TaskOccurrenceClient<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskOccurrence.
     * @param {TaskOccurrenceUpdateArgs} args - Arguments to update one TaskOccurrence.
     * @example
     * // Update one TaskOccurrence
     * const taskOccurrence = await prisma.taskOccurrence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskOccurrenceUpdateArgs>(args: SelectSubset<T, TaskOccurrenceUpdateArgs<ExtArgs>>): Prisma__TaskOccurrenceClient<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskOccurrences.
     * @param {TaskOccurrenceDeleteManyArgs} args - Arguments to filter TaskOccurrences to delete.
     * @example
     * // Delete a few TaskOccurrences
     * const { count } = await prisma.taskOccurrence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskOccurrenceDeleteManyArgs>(args?: SelectSubset<T, TaskOccurrenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskOccurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskOccurrences
     * const taskOccurrence = await prisma.taskOccurrence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskOccurrenceUpdateManyArgs>(args: SelectSubset<T, TaskOccurrenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskOccurrences and returns the data updated in the database.
     * @param {TaskOccurrenceUpdateManyAndReturnArgs} args - Arguments to update many TaskOccurrences.
     * @example
     * // Update many TaskOccurrences
     * const taskOccurrence = await prisma.taskOccurrence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskOccurrences and only return the `id`
     * const taskOccurrenceWithIdOnly = await prisma.taskOccurrence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskOccurrenceUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskOccurrenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskOccurrence.
     * @param {TaskOccurrenceUpsertArgs} args - Arguments to update or create a TaskOccurrence.
     * @example
     * // Update or create a TaskOccurrence
     * const taskOccurrence = await prisma.taskOccurrence.upsert({
     *   create: {
     *     // ... data to create a TaskOccurrence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskOccurrence we want to update
     *   }
     * })
     */
    upsert<T extends TaskOccurrenceUpsertArgs>(args: SelectSubset<T, TaskOccurrenceUpsertArgs<ExtArgs>>): Prisma__TaskOccurrenceClient<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskOccurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceCountArgs} args - Arguments to filter TaskOccurrences to count.
     * @example
     * // Count the number of TaskOccurrences
     * const count = await prisma.taskOccurrence.count({
     *   where: {
     *     // ... the filter for the TaskOccurrences we want to count
     *   }
     * })
    **/
    count<T extends TaskOccurrenceCountArgs>(
      args?: Subset<T, TaskOccurrenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskOccurrenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskOccurrence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskOccurrenceAggregateArgs>(args: Subset<T, TaskOccurrenceAggregateArgs>): Prisma.PrismaPromise<GetTaskOccurrenceAggregateType<T>>

    /**
     * Group by TaskOccurrence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskOccurrenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskOccurrenceGroupByArgs['orderBy'] }
        : { orderBy?: TaskOccurrenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskOccurrenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskOccurrenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskOccurrence model
   */
  readonly fields: TaskOccurrenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskOccurrence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskOccurrenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignees<T extends TaskOccurrence$assigneesArgs<ExtArgs> = {}>(args?: Subset<T, TaskOccurrence$assigneesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends TaskOccurrence$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, TaskOccurrence$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailLogs<T extends TaskOccurrence$emailLogsArgs<ExtArgs> = {}>(args?: Subset<T, TaskOccurrence$emailLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskOccurrence model
   */
  interface TaskOccurrenceFieldRefs {
    readonly id: FieldRef<"TaskOccurrence", 'String'>
    readonly taskId: FieldRef<"TaskOccurrence", 'String'>
    readonly title: FieldRef<"TaskOccurrence", 'String'>
    readonly description: FieldRef<"TaskOccurrence", 'String'>
    readonly startDate: FieldRef<"TaskOccurrence", 'DateTime'>
    readonly dueDate: FieldRef<"TaskOccurrence", 'DateTime'>
    readonly assignedToId: FieldRef<"TaskOccurrence", 'String'>
    readonly priority: FieldRef<"TaskOccurrence", 'Priority'>
    readonly remarks: FieldRef<"TaskOccurrence", 'String'>
    readonly status: FieldRef<"TaskOccurrence", 'TaskStatus'>
    readonly occurrenceIndex: FieldRef<"TaskOccurrence", 'Int'>
    readonly isCompleted: FieldRef<"TaskOccurrence", 'Boolean'>
    readonly completedAt: FieldRef<"TaskOccurrence", 'DateTime'>
    readonly completedBy: FieldRef<"TaskOccurrence", 'String'>
    readonly completionNote: FieldRef<"TaskOccurrence", 'String'>
    readonly clientId: FieldRef<"TaskOccurrence", 'String'>
    readonly projectId: FieldRef<"TaskOccurrence", 'String'>
    readonly createdAt: FieldRef<"TaskOccurrence", 'DateTime'>
    readonly updatedAt: FieldRef<"TaskOccurrence", 'DateTime'>
    readonly sequentialId: FieldRef<"TaskOccurrence", 'Int'>
    readonly clientMailSendCount: FieldRef<"TaskOccurrence", 'Int'>
    readonly startEmailSent: FieldRef<"TaskOccurrence", 'Boolean'>
    readonly startEmailSentAt: FieldRef<"TaskOccurrence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskOccurrence findUnique
   */
  export type TaskOccurrenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrence to fetch.
     */
    where: TaskOccurrenceWhereUniqueInput
  }

  /**
   * TaskOccurrence findUniqueOrThrow
   */
  export type TaskOccurrenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrence to fetch.
     */
    where: TaskOccurrenceWhereUniqueInput
  }

  /**
   * TaskOccurrence findFirst
   */
  export type TaskOccurrenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrence to fetch.
     */
    where?: TaskOccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOccurrences to fetch.
     */
    orderBy?: TaskOccurrenceOrderByWithRelationInput | TaskOccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskOccurrences.
     */
    cursor?: TaskOccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOccurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOccurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskOccurrences.
     */
    distinct?: TaskOccurrenceScalarFieldEnum | TaskOccurrenceScalarFieldEnum[]
  }

  /**
   * TaskOccurrence findFirstOrThrow
   */
  export type TaskOccurrenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrence to fetch.
     */
    where?: TaskOccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOccurrences to fetch.
     */
    orderBy?: TaskOccurrenceOrderByWithRelationInput | TaskOccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskOccurrences.
     */
    cursor?: TaskOccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOccurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOccurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskOccurrences.
     */
    distinct?: TaskOccurrenceScalarFieldEnum | TaskOccurrenceScalarFieldEnum[]
  }

  /**
   * TaskOccurrence findMany
   */
  export type TaskOccurrenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrences to fetch.
     */
    where?: TaskOccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOccurrences to fetch.
     */
    orderBy?: TaskOccurrenceOrderByWithRelationInput | TaskOccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskOccurrences.
     */
    cursor?: TaskOccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOccurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOccurrences.
     */
    skip?: number
    distinct?: TaskOccurrenceScalarFieldEnum | TaskOccurrenceScalarFieldEnum[]
  }

  /**
   * TaskOccurrence create
   */
  export type TaskOccurrenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskOccurrence.
     */
    data: XOR<TaskOccurrenceCreateInput, TaskOccurrenceUncheckedCreateInput>
  }

  /**
   * TaskOccurrence createMany
   */
  export type TaskOccurrenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskOccurrences.
     */
    data: TaskOccurrenceCreateManyInput | TaskOccurrenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskOccurrence createManyAndReturn
   */
  export type TaskOccurrenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * The data used to create many TaskOccurrences.
     */
    data: TaskOccurrenceCreateManyInput | TaskOccurrenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskOccurrence update
   */
  export type TaskOccurrenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskOccurrence.
     */
    data: XOR<TaskOccurrenceUpdateInput, TaskOccurrenceUncheckedUpdateInput>
    /**
     * Choose, which TaskOccurrence to update.
     */
    where: TaskOccurrenceWhereUniqueInput
  }

  /**
   * TaskOccurrence updateMany
   */
  export type TaskOccurrenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskOccurrences.
     */
    data: XOR<TaskOccurrenceUpdateManyMutationInput, TaskOccurrenceUncheckedUpdateManyInput>
    /**
     * Filter which TaskOccurrences to update
     */
    where?: TaskOccurrenceWhereInput
    /**
     * Limit how many TaskOccurrences to update.
     */
    limit?: number
  }

  /**
   * TaskOccurrence updateManyAndReturn
   */
  export type TaskOccurrenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * The data used to update TaskOccurrences.
     */
    data: XOR<TaskOccurrenceUpdateManyMutationInput, TaskOccurrenceUncheckedUpdateManyInput>
    /**
     * Filter which TaskOccurrences to update
     */
    where?: TaskOccurrenceWhereInput
    /**
     * Limit how many TaskOccurrences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskOccurrence upsert
   */
  export type TaskOccurrenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskOccurrence to update in case it exists.
     */
    where: TaskOccurrenceWhereUniqueInput
    /**
     * In case the TaskOccurrence found by the `where` argument doesn't exist, create a new TaskOccurrence with this data.
     */
    create: XOR<TaskOccurrenceCreateInput, TaskOccurrenceUncheckedCreateInput>
    /**
     * In case the TaskOccurrence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskOccurrenceUpdateInput, TaskOccurrenceUncheckedUpdateInput>
  }

  /**
   * TaskOccurrence delete
   */
  export type TaskOccurrenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceInclude<ExtArgs> | null
    /**
     * Filter which TaskOccurrence to delete.
     */
    where: TaskOccurrenceWhereUniqueInput
  }

  /**
   * TaskOccurrence deleteMany
   */
  export type TaskOccurrenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskOccurrences to delete
     */
    where?: TaskOccurrenceWhereInput
    /**
     * Limit how many TaskOccurrences to delete.
     */
    limit?: number
  }

  /**
   * TaskOccurrence.assignees
   */
  export type TaskOccurrence$assigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeInclude<ExtArgs> | null
    where?: TaskOccurrenceAssigneeWhereInput
    orderBy?: TaskOccurrenceAssigneeOrderByWithRelationInput | TaskOccurrenceAssigneeOrderByWithRelationInput[]
    cursor?: TaskOccurrenceAssigneeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskOccurrenceAssigneeScalarFieldEnum | TaskOccurrenceAssigneeScalarFieldEnum[]
  }

  /**
   * TaskOccurrence.attachments
   */
  export type TaskOccurrence$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentInclude<ExtArgs> | null
    where?: TaskOccurrenceAttachmentWhereInput
    orderBy?: TaskOccurrenceAttachmentOrderByWithRelationInput | TaskOccurrenceAttachmentOrderByWithRelationInput[]
    cursor?: TaskOccurrenceAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskOccurrenceAttachmentScalarFieldEnum | TaskOccurrenceAttachmentScalarFieldEnum[]
  }

  /**
   * TaskOccurrence.emailLogs
   */
  export type TaskOccurrence$emailLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    cursor?: EmailLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * TaskOccurrence without action
   */
  export type TaskOccurrenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceInclude<ExtArgs> | null
  }


  /**
   * Model TaskAssignee
   */

  export type AggregateTaskAssignee = {
    _count: TaskAssigneeCountAggregateOutputType | null
    _min: TaskAssigneeMinAggregateOutputType | null
    _max: TaskAssigneeMaxAggregateOutputType | null
  }

  export type TaskAssigneeMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
  }

  export type TaskAssigneeMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    userId: string | null
  }

  export type TaskAssigneeCountAggregateOutputType = {
    id: number
    taskId: number
    userId: number
    _all: number
  }


  export type TaskAssigneeMinAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
  }

  export type TaskAssigneeMaxAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
  }

  export type TaskAssigneeCountAggregateInputType = {
    id?: true
    taskId?: true
    userId?: true
    _all?: true
  }

  export type TaskAssigneeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignee to aggregate.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAssignees
    **/
    _count?: true | TaskAssigneeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAssigneeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAssigneeMaxAggregateInputType
  }

  export type GetTaskAssigneeAggregateType<T extends TaskAssigneeAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAssignee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAssignee[P]>
      : GetScalarType<T[P], AggregateTaskAssignee[P]>
  }




  export type TaskAssigneeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAssigneeWhereInput
    orderBy?: TaskAssigneeOrderByWithAggregationInput | TaskAssigneeOrderByWithAggregationInput[]
    by: TaskAssigneeScalarFieldEnum[] | TaskAssigneeScalarFieldEnum
    having?: TaskAssigneeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAssigneeCountAggregateInputType | true
    _min?: TaskAssigneeMinAggregateInputType
    _max?: TaskAssigneeMaxAggregateInputType
  }

  export type TaskAssigneeGroupByOutputType = {
    id: string
    taskId: string
    userId: string
    _count: TaskAssigneeCountAggregateOutputType | null
    _min: TaskAssigneeMinAggregateOutputType | null
    _max: TaskAssigneeMaxAggregateOutputType | null
  }

  type GetTaskAssigneeGroupByPayload<T extends TaskAssigneeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAssigneeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAssigneeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAssigneeGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAssigneeGroupByOutputType[P]>
        }
      >
    >


  export type TaskAssigneeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignee"]>

  export type TaskAssigneeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignee"]>

  export type TaskAssigneeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    userId?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAssignee"]>

  export type TaskAssigneeSelectScalar = {
    id?: boolean
    taskId?: boolean
    userId?: boolean
  }

  export type TaskAssigneeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "userId", ExtArgs["result"]["taskAssignee"]>
  export type TaskAssigneeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskAssigneeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskAssigneeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskAssigneePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAssignee"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      userId: string
    }, ExtArgs["result"]["taskAssignee"]>
    composites: {}
  }

  type TaskAssigneeGetPayload<S extends boolean | null | undefined | TaskAssigneeDefaultArgs> = $Result.GetResult<Prisma.$TaskAssigneePayload, S>

  type TaskAssigneeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskAssigneeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskAssigneeCountAggregateInputType | true
    }

  export interface TaskAssigneeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAssignee'], meta: { name: 'TaskAssignee' } }
    /**
     * Find zero or one TaskAssignee that matches the filter.
     * @param {TaskAssigneeFindUniqueArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAssigneeFindUniqueArgs>(args: SelectSubset<T, TaskAssigneeFindUniqueArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskAssignee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskAssigneeFindUniqueOrThrowArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAssigneeFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAssigneeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAssignee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindFirstArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAssigneeFindFirstArgs>(args?: SelectSubset<T, TaskAssigneeFindFirstArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAssignee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindFirstOrThrowArgs} args - Arguments to find a TaskAssignee
     * @example
     * // Get one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAssigneeFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAssigneeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskAssignees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAssignees
     * const taskAssignees = await prisma.taskAssignee.findMany()
     * 
     * // Get first 10 TaskAssignees
     * const taskAssignees = await prisma.taskAssignee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskAssigneeWithIdOnly = await prisma.taskAssignee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskAssigneeFindManyArgs>(args?: SelectSubset<T, TaskAssigneeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskAssignee.
     * @param {TaskAssigneeCreateArgs} args - Arguments to create a TaskAssignee.
     * @example
     * // Create one TaskAssignee
     * const TaskAssignee = await prisma.taskAssignee.create({
     *   data: {
     *     // ... data to create a TaskAssignee
     *   }
     * })
     * 
     */
    create<T extends TaskAssigneeCreateArgs>(args: SelectSubset<T, TaskAssigneeCreateArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskAssignees.
     * @param {TaskAssigneeCreateManyArgs} args - Arguments to create many TaskAssignees.
     * @example
     * // Create many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAssigneeCreateManyArgs>(args?: SelectSubset<T, TaskAssigneeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAssignees and returns the data saved in the database.
     * @param {TaskAssigneeCreateManyAndReturnArgs} args - Arguments to create many TaskAssignees.
     * @example
     * // Create many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAssignees and only return the `id`
     * const taskAssigneeWithIdOnly = await prisma.taskAssignee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAssigneeCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAssigneeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskAssignee.
     * @param {TaskAssigneeDeleteArgs} args - Arguments to delete one TaskAssignee.
     * @example
     * // Delete one TaskAssignee
     * const TaskAssignee = await prisma.taskAssignee.delete({
     *   where: {
     *     // ... filter to delete one TaskAssignee
     *   }
     * })
     * 
     */
    delete<T extends TaskAssigneeDeleteArgs>(args: SelectSubset<T, TaskAssigneeDeleteArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskAssignee.
     * @param {TaskAssigneeUpdateArgs} args - Arguments to update one TaskAssignee.
     * @example
     * // Update one TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAssigneeUpdateArgs>(args: SelectSubset<T, TaskAssigneeUpdateArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskAssignees.
     * @param {TaskAssigneeDeleteManyArgs} args - Arguments to filter TaskAssignees to delete.
     * @example
     * // Delete a few TaskAssignees
     * const { count } = await prisma.taskAssignee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAssigneeDeleteManyArgs>(args?: SelectSubset<T, TaskAssigneeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAssigneeUpdateManyArgs>(args: SelectSubset<T, TaskAssigneeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAssignees and returns the data updated in the database.
     * @param {TaskAssigneeUpdateManyAndReturnArgs} args - Arguments to update many TaskAssignees.
     * @example
     * // Update many TaskAssignees
     * const taskAssignee = await prisma.taskAssignee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskAssignees and only return the `id`
     * const taskAssigneeWithIdOnly = await prisma.taskAssignee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskAssigneeUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskAssigneeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskAssignee.
     * @param {TaskAssigneeUpsertArgs} args - Arguments to update or create a TaskAssignee.
     * @example
     * // Update or create a TaskAssignee
     * const taskAssignee = await prisma.taskAssignee.upsert({
     *   create: {
     *     // ... data to create a TaskAssignee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAssignee we want to update
     *   }
     * })
     */
    upsert<T extends TaskAssigneeUpsertArgs>(args: SelectSubset<T, TaskAssigneeUpsertArgs<ExtArgs>>): Prisma__TaskAssigneeClient<$Result.GetResult<Prisma.$TaskAssigneePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeCountArgs} args - Arguments to filter TaskAssignees to count.
     * @example
     * // Count the number of TaskAssignees
     * const count = await prisma.taskAssignee.count({
     *   where: {
     *     // ... the filter for the TaskAssignees we want to count
     *   }
     * })
    **/
    count<T extends TaskAssigneeCountArgs>(
      args?: Subset<T, TaskAssigneeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAssigneeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAssigneeAggregateArgs>(args: Subset<T, TaskAssigneeAggregateArgs>): Prisma.PrismaPromise<GetTaskAssigneeAggregateType<T>>

    /**
     * Group by TaskAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAssigneeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAssigneeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAssigneeGroupByArgs['orderBy'] }
        : { orderBy?: TaskAssigneeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAssigneeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAssigneeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAssignee model
   */
  readonly fields: TaskAssigneeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAssignee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAssigneeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAssignee model
   */
  interface TaskAssigneeFieldRefs {
    readonly id: FieldRef<"TaskAssignee", 'String'>
    readonly taskId: FieldRef<"TaskAssignee", 'String'>
    readonly userId: FieldRef<"TaskAssignee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskAssignee findUnique
   */
  export type TaskAssigneeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee findUniqueOrThrow
   */
  export type TaskAssigneeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee findFirst
   */
  export type TaskAssigneeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignees.
     */
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * TaskAssignee findFirstOrThrow
   */
  export type TaskAssigneeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignee to fetch.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAssignees.
     */
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * TaskAssignee findMany
   */
  export type TaskAssigneeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskAssignees to fetch.
     */
    where?: TaskAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAssignees to fetch.
     */
    orderBy?: TaskAssigneeOrderByWithRelationInput | TaskAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAssignees.
     */
    cursor?: TaskAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAssignees.
     */
    skip?: number
    distinct?: TaskAssigneeScalarFieldEnum | TaskAssigneeScalarFieldEnum[]
  }

  /**
   * TaskAssignee create
   */
  export type TaskAssigneeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAssignee.
     */
    data: XOR<TaskAssigneeCreateInput, TaskAssigneeUncheckedCreateInput>
  }

  /**
   * TaskAssignee createMany
   */
  export type TaskAssigneeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAssignees.
     */
    data: TaskAssigneeCreateManyInput | TaskAssigneeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAssignee createManyAndReturn
   */
  export type TaskAssigneeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * The data used to create many TaskAssignees.
     */
    data: TaskAssigneeCreateManyInput | TaskAssigneeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignee update
   */
  export type TaskAssigneeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAssignee.
     */
    data: XOR<TaskAssigneeUpdateInput, TaskAssigneeUncheckedUpdateInput>
    /**
     * Choose, which TaskAssignee to update.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee updateMany
   */
  export type TaskAssigneeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAssignees.
     */
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignees to update
     */
    where?: TaskAssigneeWhereInput
    /**
     * Limit how many TaskAssignees to update.
     */
    limit?: number
  }

  /**
   * TaskAssignee updateManyAndReturn
   */
  export type TaskAssigneeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * The data used to update TaskAssignees.
     */
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyInput>
    /**
     * Filter which TaskAssignees to update
     */
    where?: TaskAssigneeWhereInput
    /**
     * Limit how many TaskAssignees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAssignee upsert
   */
  export type TaskAssigneeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAssignee to update in case it exists.
     */
    where: TaskAssigneeWhereUniqueInput
    /**
     * In case the TaskAssignee found by the `where` argument doesn't exist, create a new TaskAssignee with this data.
     */
    create: XOR<TaskAssigneeCreateInput, TaskAssigneeUncheckedCreateInput>
    /**
     * In case the TaskAssignee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAssigneeUpdateInput, TaskAssigneeUncheckedUpdateInput>
  }

  /**
   * TaskAssignee delete
   */
  export type TaskAssigneeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
    /**
     * Filter which TaskAssignee to delete.
     */
    where: TaskAssigneeWhereUniqueInput
  }

  /**
   * TaskAssignee deleteMany
   */
  export type TaskAssigneeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAssignees to delete
     */
    where?: TaskAssigneeWhereInput
    /**
     * Limit how many TaskAssignees to delete.
     */
    limit?: number
  }

  /**
   * TaskAssignee without action
   */
  export type TaskAssigneeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAssignee
     */
    select?: TaskAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAssignee
     */
    omit?: TaskAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAssigneeInclude<ExtArgs> | null
  }


  /**
   * Model TaskOccurrenceAssignee
   */

  export type AggregateTaskOccurrenceAssignee = {
    _count: TaskOccurrenceAssigneeCountAggregateOutputType | null
    _min: TaskOccurrenceAssigneeMinAggregateOutputType | null
    _max: TaskOccurrenceAssigneeMaxAggregateOutputType | null
  }

  export type TaskOccurrenceAssigneeMinAggregateOutputType = {
    id: string | null
    occurrenceId: string | null
    userId: string | null
  }

  export type TaskOccurrenceAssigneeMaxAggregateOutputType = {
    id: string | null
    occurrenceId: string | null
    userId: string | null
  }

  export type TaskOccurrenceAssigneeCountAggregateOutputType = {
    id: number
    occurrenceId: number
    userId: number
    _all: number
  }


  export type TaskOccurrenceAssigneeMinAggregateInputType = {
    id?: true
    occurrenceId?: true
    userId?: true
  }

  export type TaskOccurrenceAssigneeMaxAggregateInputType = {
    id?: true
    occurrenceId?: true
    userId?: true
  }

  export type TaskOccurrenceAssigneeCountAggregateInputType = {
    id?: true
    occurrenceId?: true
    userId?: true
    _all?: true
  }

  export type TaskOccurrenceAssigneeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskOccurrenceAssignee to aggregate.
     */
    where?: TaskOccurrenceAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOccurrenceAssignees to fetch.
     */
    orderBy?: TaskOccurrenceAssigneeOrderByWithRelationInput | TaskOccurrenceAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskOccurrenceAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOccurrenceAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOccurrenceAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskOccurrenceAssignees
    **/
    _count?: true | TaskOccurrenceAssigneeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskOccurrenceAssigneeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskOccurrenceAssigneeMaxAggregateInputType
  }

  export type GetTaskOccurrenceAssigneeAggregateType<T extends TaskOccurrenceAssigneeAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskOccurrenceAssignee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskOccurrenceAssignee[P]>
      : GetScalarType<T[P], AggregateTaskOccurrenceAssignee[P]>
  }




  export type TaskOccurrenceAssigneeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskOccurrenceAssigneeWhereInput
    orderBy?: TaskOccurrenceAssigneeOrderByWithAggregationInput | TaskOccurrenceAssigneeOrderByWithAggregationInput[]
    by: TaskOccurrenceAssigneeScalarFieldEnum[] | TaskOccurrenceAssigneeScalarFieldEnum
    having?: TaskOccurrenceAssigneeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskOccurrenceAssigneeCountAggregateInputType | true
    _min?: TaskOccurrenceAssigneeMinAggregateInputType
    _max?: TaskOccurrenceAssigneeMaxAggregateInputType
  }

  export type TaskOccurrenceAssigneeGroupByOutputType = {
    id: string
    occurrenceId: string
    userId: string
    _count: TaskOccurrenceAssigneeCountAggregateOutputType | null
    _min: TaskOccurrenceAssigneeMinAggregateOutputType | null
    _max: TaskOccurrenceAssigneeMaxAggregateOutputType | null
  }

  type GetTaskOccurrenceAssigneeGroupByPayload<T extends TaskOccurrenceAssigneeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskOccurrenceAssigneeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskOccurrenceAssigneeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskOccurrenceAssigneeGroupByOutputType[P]>
            : GetScalarType<T[P], TaskOccurrenceAssigneeGroupByOutputType[P]>
        }
      >
    >


  export type TaskOccurrenceAssigneeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    occurrenceId?: boolean
    userId?: boolean
    occurrence?: boolean | TaskOccurrenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskOccurrenceAssignee"]>

  export type TaskOccurrenceAssigneeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    occurrenceId?: boolean
    userId?: boolean
    occurrence?: boolean | TaskOccurrenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskOccurrenceAssignee"]>

  export type TaskOccurrenceAssigneeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    occurrenceId?: boolean
    userId?: boolean
    occurrence?: boolean | TaskOccurrenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskOccurrenceAssignee"]>

  export type TaskOccurrenceAssigneeSelectScalar = {
    id?: boolean
    occurrenceId?: boolean
    userId?: boolean
  }

  export type TaskOccurrenceAssigneeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "occurrenceId" | "userId", ExtArgs["result"]["taskOccurrenceAssignee"]>
  export type TaskOccurrenceAssigneeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occurrence?: boolean | TaskOccurrenceDefaultArgs<ExtArgs>
  }
  export type TaskOccurrenceAssigneeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occurrence?: boolean | TaskOccurrenceDefaultArgs<ExtArgs>
  }
  export type TaskOccurrenceAssigneeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occurrence?: boolean | TaskOccurrenceDefaultArgs<ExtArgs>
  }

  export type $TaskOccurrenceAssigneePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskOccurrenceAssignee"
    objects: {
      occurrence: Prisma.$TaskOccurrencePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      occurrenceId: string
      userId: string
    }, ExtArgs["result"]["taskOccurrenceAssignee"]>
    composites: {}
  }

  type TaskOccurrenceAssigneeGetPayload<S extends boolean | null | undefined | TaskOccurrenceAssigneeDefaultArgs> = $Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload, S>

  type TaskOccurrenceAssigneeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskOccurrenceAssigneeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskOccurrenceAssigneeCountAggregateInputType | true
    }

  export interface TaskOccurrenceAssigneeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskOccurrenceAssignee'], meta: { name: 'TaskOccurrenceAssignee' } }
    /**
     * Find zero or one TaskOccurrenceAssignee that matches the filter.
     * @param {TaskOccurrenceAssigneeFindUniqueArgs} args - Arguments to find a TaskOccurrenceAssignee
     * @example
     * // Get one TaskOccurrenceAssignee
     * const taskOccurrenceAssignee = await prisma.taskOccurrenceAssignee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskOccurrenceAssigneeFindUniqueArgs>(args: SelectSubset<T, TaskOccurrenceAssigneeFindUniqueArgs<ExtArgs>>): Prisma__TaskOccurrenceAssigneeClient<$Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskOccurrenceAssignee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskOccurrenceAssigneeFindUniqueOrThrowArgs} args - Arguments to find a TaskOccurrenceAssignee
     * @example
     * // Get one TaskOccurrenceAssignee
     * const taskOccurrenceAssignee = await prisma.taskOccurrenceAssignee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskOccurrenceAssigneeFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskOccurrenceAssigneeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskOccurrenceAssigneeClient<$Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskOccurrenceAssignee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAssigneeFindFirstArgs} args - Arguments to find a TaskOccurrenceAssignee
     * @example
     * // Get one TaskOccurrenceAssignee
     * const taskOccurrenceAssignee = await prisma.taskOccurrenceAssignee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskOccurrenceAssigneeFindFirstArgs>(args?: SelectSubset<T, TaskOccurrenceAssigneeFindFirstArgs<ExtArgs>>): Prisma__TaskOccurrenceAssigneeClient<$Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskOccurrenceAssignee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAssigneeFindFirstOrThrowArgs} args - Arguments to find a TaskOccurrenceAssignee
     * @example
     * // Get one TaskOccurrenceAssignee
     * const taskOccurrenceAssignee = await prisma.taskOccurrenceAssignee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskOccurrenceAssigneeFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskOccurrenceAssigneeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskOccurrenceAssigneeClient<$Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskOccurrenceAssignees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAssigneeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskOccurrenceAssignees
     * const taskOccurrenceAssignees = await prisma.taskOccurrenceAssignee.findMany()
     * 
     * // Get first 10 TaskOccurrenceAssignees
     * const taskOccurrenceAssignees = await prisma.taskOccurrenceAssignee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskOccurrenceAssigneeWithIdOnly = await prisma.taskOccurrenceAssignee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskOccurrenceAssigneeFindManyArgs>(args?: SelectSubset<T, TaskOccurrenceAssigneeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskOccurrenceAssignee.
     * @param {TaskOccurrenceAssigneeCreateArgs} args - Arguments to create a TaskOccurrenceAssignee.
     * @example
     * // Create one TaskOccurrenceAssignee
     * const TaskOccurrenceAssignee = await prisma.taskOccurrenceAssignee.create({
     *   data: {
     *     // ... data to create a TaskOccurrenceAssignee
     *   }
     * })
     * 
     */
    create<T extends TaskOccurrenceAssigneeCreateArgs>(args: SelectSubset<T, TaskOccurrenceAssigneeCreateArgs<ExtArgs>>): Prisma__TaskOccurrenceAssigneeClient<$Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskOccurrenceAssignees.
     * @param {TaskOccurrenceAssigneeCreateManyArgs} args - Arguments to create many TaskOccurrenceAssignees.
     * @example
     * // Create many TaskOccurrenceAssignees
     * const taskOccurrenceAssignee = await prisma.taskOccurrenceAssignee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskOccurrenceAssigneeCreateManyArgs>(args?: SelectSubset<T, TaskOccurrenceAssigneeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskOccurrenceAssignees and returns the data saved in the database.
     * @param {TaskOccurrenceAssigneeCreateManyAndReturnArgs} args - Arguments to create many TaskOccurrenceAssignees.
     * @example
     * // Create many TaskOccurrenceAssignees
     * const taskOccurrenceAssignee = await prisma.taskOccurrenceAssignee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskOccurrenceAssignees and only return the `id`
     * const taskOccurrenceAssigneeWithIdOnly = await prisma.taskOccurrenceAssignee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskOccurrenceAssigneeCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskOccurrenceAssigneeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskOccurrenceAssignee.
     * @param {TaskOccurrenceAssigneeDeleteArgs} args - Arguments to delete one TaskOccurrenceAssignee.
     * @example
     * // Delete one TaskOccurrenceAssignee
     * const TaskOccurrenceAssignee = await prisma.taskOccurrenceAssignee.delete({
     *   where: {
     *     // ... filter to delete one TaskOccurrenceAssignee
     *   }
     * })
     * 
     */
    delete<T extends TaskOccurrenceAssigneeDeleteArgs>(args: SelectSubset<T, TaskOccurrenceAssigneeDeleteArgs<ExtArgs>>): Prisma__TaskOccurrenceAssigneeClient<$Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskOccurrenceAssignee.
     * @param {TaskOccurrenceAssigneeUpdateArgs} args - Arguments to update one TaskOccurrenceAssignee.
     * @example
     * // Update one TaskOccurrenceAssignee
     * const taskOccurrenceAssignee = await prisma.taskOccurrenceAssignee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskOccurrenceAssigneeUpdateArgs>(args: SelectSubset<T, TaskOccurrenceAssigneeUpdateArgs<ExtArgs>>): Prisma__TaskOccurrenceAssigneeClient<$Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskOccurrenceAssignees.
     * @param {TaskOccurrenceAssigneeDeleteManyArgs} args - Arguments to filter TaskOccurrenceAssignees to delete.
     * @example
     * // Delete a few TaskOccurrenceAssignees
     * const { count } = await prisma.taskOccurrenceAssignee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskOccurrenceAssigneeDeleteManyArgs>(args?: SelectSubset<T, TaskOccurrenceAssigneeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskOccurrenceAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAssigneeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskOccurrenceAssignees
     * const taskOccurrenceAssignee = await prisma.taskOccurrenceAssignee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskOccurrenceAssigneeUpdateManyArgs>(args: SelectSubset<T, TaskOccurrenceAssigneeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskOccurrenceAssignees and returns the data updated in the database.
     * @param {TaskOccurrenceAssigneeUpdateManyAndReturnArgs} args - Arguments to update many TaskOccurrenceAssignees.
     * @example
     * // Update many TaskOccurrenceAssignees
     * const taskOccurrenceAssignee = await prisma.taskOccurrenceAssignee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskOccurrenceAssignees and only return the `id`
     * const taskOccurrenceAssigneeWithIdOnly = await prisma.taskOccurrenceAssignee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskOccurrenceAssigneeUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskOccurrenceAssigneeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskOccurrenceAssignee.
     * @param {TaskOccurrenceAssigneeUpsertArgs} args - Arguments to update or create a TaskOccurrenceAssignee.
     * @example
     * // Update or create a TaskOccurrenceAssignee
     * const taskOccurrenceAssignee = await prisma.taskOccurrenceAssignee.upsert({
     *   create: {
     *     // ... data to create a TaskOccurrenceAssignee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskOccurrenceAssignee we want to update
     *   }
     * })
     */
    upsert<T extends TaskOccurrenceAssigneeUpsertArgs>(args: SelectSubset<T, TaskOccurrenceAssigneeUpsertArgs<ExtArgs>>): Prisma__TaskOccurrenceAssigneeClient<$Result.GetResult<Prisma.$TaskOccurrenceAssigneePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskOccurrenceAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAssigneeCountArgs} args - Arguments to filter TaskOccurrenceAssignees to count.
     * @example
     * // Count the number of TaskOccurrenceAssignees
     * const count = await prisma.taskOccurrenceAssignee.count({
     *   where: {
     *     // ... the filter for the TaskOccurrenceAssignees we want to count
     *   }
     * })
    **/
    count<T extends TaskOccurrenceAssigneeCountArgs>(
      args?: Subset<T, TaskOccurrenceAssigneeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskOccurrenceAssigneeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskOccurrenceAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAssigneeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskOccurrenceAssigneeAggregateArgs>(args: Subset<T, TaskOccurrenceAssigneeAggregateArgs>): Prisma.PrismaPromise<GetTaskOccurrenceAssigneeAggregateType<T>>

    /**
     * Group by TaskOccurrenceAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAssigneeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskOccurrenceAssigneeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskOccurrenceAssigneeGroupByArgs['orderBy'] }
        : { orderBy?: TaskOccurrenceAssigneeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskOccurrenceAssigneeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskOccurrenceAssigneeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskOccurrenceAssignee model
   */
  readonly fields: TaskOccurrenceAssigneeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskOccurrenceAssignee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskOccurrenceAssigneeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    occurrence<T extends TaskOccurrenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskOccurrenceDefaultArgs<ExtArgs>>): Prisma__TaskOccurrenceClient<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskOccurrenceAssignee model
   */
  interface TaskOccurrenceAssigneeFieldRefs {
    readonly id: FieldRef<"TaskOccurrenceAssignee", 'String'>
    readonly occurrenceId: FieldRef<"TaskOccurrenceAssignee", 'String'>
    readonly userId: FieldRef<"TaskOccurrenceAssignee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskOccurrenceAssignee findUnique
   */
  export type TaskOccurrenceAssigneeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrenceAssignee to fetch.
     */
    where: TaskOccurrenceAssigneeWhereUniqueInput
  }

  /**
   * TaskOccurrenceAssignee findUniqueOrThrow
   */
  export type TaskOccurrenceAssigneeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrenceAssignee to fetch.
     */
    where: TaskOccurrenceAssigneeWhereUniqueInput
  }

  /**
   * TaskOccurrenceAssignee findFirst
   */
  export type TaskOccurrenceAssigneeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrenceAssignee to fetch.
     */
    where?: TaskOccurrenceAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOccurrenceAssignees to fetch.
     */
    orderBy?: TaskOccurrenceAssigneeOrderByWithRelationInput | TaskOccurrenceAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskOccurrenceAssignees.
     */
    cursor?: TaskOccurrenceAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOccurrenceAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOccurrenceAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskOccurrenceAssignees.
     */
    distinct?: TaskOccurrenceAssigneeScalarFieldEnum | TaskOccurrenceAssigneeScalarFieldEnum[]
  }

  /**
   * TaskOccurrenceAssignee findFirstOrThrow
   */
  export type TaskOccurrenceAssigneeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrenceAssignee to fetch.
     */
    where?: TaskOccurrenceAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOccurrenceAssignees to fetch.
     */
    orderBy?: TaskOccurrenceAssigneeOrderByWithRelationInput | TaskOccurrenceAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskOccurrenceAssignees.
     */
    cursor?: TaskOccurrenceAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOccurrenceAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOccurrenceAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskOccurrenceAssignees.
     */
    distinct?: TaskOccurrenceAssigneeScalarFieldEnum | TaskOccurrenceAssigneeScalarFieldEnum[]
  }

  /**
   * TaskOccurrenceAssignee findMany
   */
  export type TaskOccurrenceAssigneeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrenceAssignees to fetch.
     */
    where?: TaskOccurrenceAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOccurrenceAssignees to fetch.
     */
    orderBy?: TaskOccurrenceAssigneeOrderByWithRelationInput | TaskOccurrenceAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskOccurrenceAssignees.
     */
    cursor?: TaskOccurrenceAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOccurrenceAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOccurrenceAssignees.
     */
    skip?: number
    distinct?: TaskOccurrenceAssigneeScalarFieldEnum | TaskOccurrenceAssigneeScalarFieldEnum[]
  }

  /**
   * TaskOccurrenceAssignee create
   */
  export type TaskOccurrenceAssigneeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskOccurrenceAssignee.
     */
    data: XOR<TaskOccurrenceAssigneeCreateInput, TaskOccurrenceAssigneeUncheckedCreateInput>
  }

  /**
   * TaskOccurrenceAssignee createMany
   */
  export type TaskOccurrenceAssigneeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskOccurrenceAssignees.
     */
    data: TaskOccurrenceAssigneeCreateManyInput | TaskOccurrenceAssigneeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskOccurrenceAssignee createManyAndReturn
   */
  export type TaskOccurrenceAssigneeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * The data used to create many TaskOccurrenceAssignees.
     */
    data: TaskOccurrenceAssigneeCreateManyInput | TaskOccurrenceAssigneeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskOccurrenceAssignee update
   */
  export type TaskOccurrenceAssigneeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskOccurrenceAssignee.
     */
    data: XOR<TaskOccurrenceAssigneeUpdateInput, TaskOccurrenceAssigneeUncheckedUpdateInput>
    /**
     * Choose, which TaskOccurrenceAssignee to update.
     */
    where: TaskOccurrenceAssigneeWhereUniqueInput
  }

  /**
   * TaskOccurrenceAssignee updateMany
   */
  export type TaskOccurrenceAssigneeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskOccurrenceAssignees.
     */
    data: XOR<TaskOccurrenceAssigneeUpdateManyMutationInput, TaskOccurrenceAssigneeUncheckedUpdateManyInput>
    /**
     * Filter which TaskOccurrenceAssignees to update
     */
    where?: TaskOccurrenceAssigneeWhereInput
    /**
     * Limit how many TaskOccurrenceAssignees to update.
     */
    limit?: number
  }

  /**
   * TaskOccurrenceAssignee updateManyAndReturn
   */
  export type TaskOccurrenceAssigneeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * The data used to update TaskOccurrenceAssignees.
     */
    data: XOR<TaskOccurrenceAssigneeUpdateManyMutationInput, TaskOccurrenceAssigneeUncheckedUpdateManyInput>
    /**
     * Filter which TaskOccurrenceAssignees to update
     */
    where?: TaskOccurrenceAssigneeWhereInput
    /**
     * Limit how many TaskOccurrenceAssignees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskOccurrenceAssignee upsert
   */
  export type TaskOccurrenceAssigneeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskOccurrenceAssignee to update in case it exists.
     */
    where: TaskOccurrenceAssigneeWhereUniqueInput
    /**
     * In case the TaskOccurrenceAssignee found by the `where` argument doesn't exist, create a new TaskOccurrenceAssignee with this data.
     */
    create: XOR<TaskOccurrenceAssigneeCreateInput, TaskOccurrenceAssigneeUncheckedCreateInput>
    /**
     * In case the TaskOccurrenceAssignee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskOccurrenceAssigneeUpdateInput, TaskOccurrenceAssigneeUncheckedUpdateInput>
  }

  /**
   * TaskOccurrenceAssignee delete
   */
  export type TaskOccurrenceAssigneeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeInclude<ExtArgs> | null
    /**
     * Filter which TaskOccurrenceAssignee to delete.
     */
    where: TaskOccurrenceAssigneeWhereUniqueInput
  }

  /**
   * TaskOccurrenceAssignee deleteMany
   */
  export type TaskOccurrenceAssigneeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskOccurrenceAssignees to delete
     */
    where?: TaskOccurrenceAssigneeWhereInput
    /**
     * Limit how many TaskOccurrenceAssignees to delete.
     */
    limit?: number
  }

  /**
   * TaskOccurrenceAssignee without action
   */
  export type TaskOccurrenceAssigneeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAssignee
     */
    select?: TaskOccurrenceAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAssignee
     */
    omit?: TaskOccurrenceAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAssigneeInclude<ExtArgs> | null
  }


  /**
   * Model TaskAttachment
   */

  export type AggregateTaskAttachment = {
    _count: TaskAttachmentCountAggregateOutputType | null
    _min: TaskAttachmentMinAggregateOutputType | null
    _max: TaskAttachmentMaxAggregateOutputType | null
  }

  export type TaskAttachmentMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    key: string | null
    createdAt: Date | null
  }

  export type TaskAttachmentMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    key: string | null
    createdAt: Date | null
  }

  export type TaskAttachmentCountAggregateOutputType = {
    id: number
    taskId: number
    key: number
    createdAt: number
    _all: number
  }


  export type TaskAttachmentMinAggregateInputType = {
    id?: true
    taskId?: true
    key?: true
    createdAt?: true
  }

  export type TaskAttachmentMaxAggregateInputType = {
    id?: true
    taskId?: true
    key?: true
    createdAt?: true
  }

  export type TaskAttachmentCountAggregateInputType = {
    id?: true
    taskId?: true
    key?: true
    createdAt?: true
    _all?: true
  }

  export type TaskAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAttachment to aggregate.
     */
    where?: TaskAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskAttachments
    **/
    _count?: true | TaskAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskAttachmentMaxAggregateInputType
  }

  export type GetTaskAttachmentAggregateType<T extends TaskAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskAttachment[P]>
      : GetScalarType<T[P], AggregateTaskAttachment[P]>
  }




  export type TaskAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskAttachmentWhereInput
    orderBy?: TaskAttachmentOrderByWithAggregationInput | TaskAttachmentOrderByWithAggregationInput[]
    by: TaskAttachmentScalarFieldEnum[] | TaskAttachmentScalarFieldEnum
    having?: TaskAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskAttachmentCountAggregateInputType | true
    _min?: TaskAttachmentMinAggregateInputType
    _max?: TaskAttachmentMaxAggregateInputType
  }

  export type TaskAttachmentGroupByOutputType = {
    id: string
    taskId: string
    key: string
    createdAt: Date
    _count: TaskAttachmentCountAggregateOutputType | null
    _min: TaskAttachmentMinAggregateOutputType | null
    _max: TaskAttachmentMaxAggregateOutputType | null
  }

  type GetTaskAttachmentGroupByPayload<T extends TaskAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], TaskAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type TaskAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    key?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAttachment"]>

  export type TaskAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    key?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAttachment"]>

  export type TaskAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    key?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskAttachment"]>

  export type TaskAttachmentSelectScalar = {
    id?: boolean
    taskId?: boolean
    key?: boolean
    createdAt?: boolean
  }

  export type TaskAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "key" | "createdAt", ExtArgs["result"]["taskAttachment"]>
  export type TaskAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskAttachment"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      key: string
      createdAt: Date
    }, ExtArgs["result"]["taskAttachment"]>
    composites: {}
  }

  type TaskAttachmentGetPayload<S extends boolean | null | undefined | TaskAttachmentDefaultArgs> = $Result.GetResult<Prisma.$TaskAttachmentPayload, S>

  type TaskAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskAttachmentCountAggregateInputType | true
    }

  export interface TaskAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskAttachment'], meta: { name: 'TaskAttachment' } }
    /**
     * Find zero or one TaskAttachment that matches the filter.
     * @param {TaskAttachmentFindUniqueArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskAttachmentFindUniqueArgs>(args: SelectSubset<T, TaskAttachmentFindUniqueArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskAttachmentFindUniqueOrThrowArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentFindFirstArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskAttachmentFindFirstArgs>(args?: SelectSubset<T, TaskAttachmentFindFirstArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentFindFirstOrThrowArgs} args - Arguments to find a TaskAttachment
     * @example
     * // Get one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskAttachments
     * const taskAttachments = await prisma.taskAttachment.findMany()
     * 
     * // Get first 10 TaskAttachments
     * const taskAttachments = await prisma.taskAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskAttachmentWithIdOnly = await prisma.taskAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskAttachmentFindManyArgs>(args?: SelectSubset<T, TaskAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskAttachment.
     * @param {TaskAttachmentCreateArgs} args - Arguments to create a TaskAttachment.
     * @example
     * // Create one TaskAttachment
     * const TaskAttachment = await prisma.taskAttachment.create({
     *   data: {
     *     // ... data to create a TaskAttachment
     *   }
     * })
     * 
     */
    create<T extends TaskAttachmentCreateArgs>(args: SelectSubset<T, TaskAttachmentCreateArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskAttachments.
     * @param {TaskAttachmentCreateManyArgs} args - Arguments to create many TaskAttachments.
     * @example
     * // Create many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskAttachmentCreateManyArgs>(args?: SelectSubset<T, TaskAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskAttachments and returns the data saved in the database.
     * @param {TaskAttachmentCreateManyAndReturnArgs} args - Arguments to create many TaskAttachments.
     * @example
     * // Create many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskAttachments and only return the `id`
     * const taskAttachmentWithIdOnly = await prisma.taskAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskAttachment.
     * @param {TaskAttachmentDeleteArgs} args - Arguments to delete one TaskAttachment.
     * @example
     * // Delete one TaskAttachment
     * const TaskAttachment = await prisma.taskAttachment.delete({
     *   where: {
     *     // ... filter to delete one TaskAttachment
     *   }
     * })
     * 
     */
    delete<T extends TaskAttachmentDeleteArgs>(args: SelectSubset<T, TaskAttachmentDeleteArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskAttachment.
     * @param {TaskAttachmentUpdateArgs} args - Arguments to update one TaskAttachment.
     * @example
     * // Update one TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskAttachmentUpdateArgs>(args: SelectSubset<T, TaskAttachmentUpdateArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskAttachments.
     * @param {TaskAttachmentDeleteManyArgs} args - Arguments to filter TaskAttachments to delete.
     * @example
     * // Delete a few TaskAttachments
     * const { count } = await prisma.taskAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskAttachmentDeleteManyArgs>(args?: SelectSubset<T, TaskAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskAttachmentUpdateManyArgs>(args: SelectSubset<T, TaskAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskAttachments and returns the data updated in the database.
     * @param {TaskAttachmentUpdateManyAndReturnArgs} args - Arguments to update many TaskAttachments.
     * @example
     * // Update many TaskAttachments
     * const taskAttachment = await prisma.taskAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskAttachments and only return the `id`
     * const taskAttachmentWithIdOnly = await prisma.taskAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskAttachment.
     * @param {TaskAttachmentUpsertArgs} args - Arguments to update or create a TaskAttachment.
     * @example
     * // Update or create a TaskAttachment
     * const taskAttachment = await prisma.taskAttachment.upsert({
     *   create: {
     *     // ... data to create a TaskAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskAttachment we want to update
     *   }
     * })
     */
    upsert<T extends TaskAttachmentUpsertArgs>(args: SelectSubset<T, TaskAttachmentUpsertArgs<ExtArgs>>): Prisma__TaskAttachmentClient<$Result.GetResult<Prisma.$TaskAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentCountArgs} args - Arguments to filter TaskAttachments to count.
     * @example
     * // Count the number of TaskAttachments
     * const count = await prisma.taskAttachment.count({
     *   where: {
     *     // ... the filter for the TaskAttachments we want to count
     *   }
     * })
    **/
    count<T extends TaskAttachmentCountArgs>(
      args?: Subset<T, TaskAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAttachmentAggregateArgs>(args: Subset<T, TaskAttachmentAggregateArgs>): Prisma.PrismaPromise<GetTaskAttachmentAggregateType<T>>

    /**
     * Group by TaskAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: TaskAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskAttachment model
   */
  readonly fields: TaskAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskAttachment model
   */
  interface TaskAttachmentFieldRefs {
    readonly id: FieldRef<"TaskAttachment", 'String'>
    readonly taskId: FieldRef<"TaskAttachment", 'String'>
    readonly key: FieldRef<"TaskAttachment", 'String'>
    readonly createdAt: FieldRef<"TaskAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskAttachment findUnique
   */
  export type TaskAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where: TaskAttachmentWhereUniqueInput
  }

  /**
   * TaskAttachment findUniqueOrThrow
   */
  export type TaskAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where: TaskAttachmentWhereUniqueInput
  }

  /**
   * TaskAttachment findFirst
   */
  export type TaskAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where?: TaskAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAttachments.
     */
    cursor?: TaskAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAttachments.
     */
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * TaskAttachment findFirstOrThrow
   */
  export type TaskAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachment to fetch.
     */
    where?: TaskAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskAttachments.
     */
    cursor?: TaskAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskAttachments.
     */
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * TaskAttachment findMany
   */
  export type TaskAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskAttachments to fetch.
     */
    where?: TaskAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskAttachments to fetch.
     */
    orderBy?: TaskAttachmentOrderByWithRelationInput | TaskAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskAttachments.
     */
    cursor?: TaskAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskAttachments.
     */
    skip?: number
    distinct?: TaskAttachmentScalarFieldEnum | TaskAttachmentScalarFieldEnum[]
  }

  /**
   * TaskAttachment create
   */
  export type TaskAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskAttachment.
     */
    data: XOR<TaskAttachmentCreateInput, TaskAttachmentUncheckedCreateInput>
  }

  /**
   * TaskAttachment createMany
   */
  export type TaskAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskAttachments.
     */
    data: TaskAttachmentCreateManyInput | TaskAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskAttachment createManyAndReturn
   */
  export type TaskAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many TaskAttachments.
     */
    data: TaskAttachmentCreateManyInput | TaskAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAttachment update
   */
  export type TaskAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskAttachment.
     */
    data: XOR<TaskAttachmentUpdateInput, TaskAttachmentUncheckedUpdateInput>
    /**
     * Choose, which TaskAttachment to update.
     */
    where: TaskAttachmentWhereUniqueInput
  }

  /**
   * TaskAttachment updateMany
   */
  export type TaskAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskAttachments.
     */
    data: XOR<TaskAttachmentUpdateManyMutationInput, TaskAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskAttachments to update
     */
    where?: TaskAttachmentWhereInput
    /**
     * Limit how many TaskAttachments to update.
     */
    limit?: number
  }

  /**
   * TaskAttachment updateManyAndReturn
   */
  export type TaskAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update TaskAttachments.
     */
    data: XOR<TaskAttachmentUpdateManyMutationInput, TaskAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskAttachments to update
     */
    where?: TaskAttachmentWhereInput
    /**
     * Limit how many TaskAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskAttachment upsert
   */
  export type TaskAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskAttachment to update in case it exists.
     */
    where: TaskAttachmentWhereUniqueInput
    /**
     * In case the TaskAttachment found by the `where` argument doesn't exist, create a new TaskAttachment with this data.
     */
    create: XOR<TaskAttachmentCreateInput, TaskAttachmentUncheckedCreateInput>
    /**
     * In case the TaskAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskAttachmentUpdateInput, TaskAttachmentUncheckedUpdateInput>
  }

  /**
   * TaskAttachment delete
   */
  export type TaskAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
    /**
     * Filter which TaskAttachment to delete.
     */
    where: TaskAttachmentWhereUniqueInput
  }

  /**
   * TaskAttachment deleteMany
   */
  export type TaskAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskAttachments to delete
     */
    where?: TaskAttachmentWhereInput
    /**
     * Limit how many TaskAttachments to delete.
     */
    limit?: number
  }

  /**
   * TaskAttachment without action
   */
  export type TaskAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskAttachment
     */
    select?: TaskAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskAttachment
     */
    omit?: TaskAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model TaskOccurrenceAttachment
   */

  export type AggregateTaskOccurrenceAttachment = {
    _count: TaskOccurrenceAttachmentCountAggregateOutputType | null
    _min: TaskOccurrenceAttachmentMinAggregateOutputType | null
    _max: TaskOccurrenceAttachmentMaxAggregateOutputType | null
  }

  export type TaskOccurrenceAttachmentMinAggregateOutputType = {
    id: string | null
    occurrenceId: string | null
    key: string | null
    createdAt: Date | null
  }

  export type TaskOccurrenceAttachmentMaxAggregateOutputType = {
    id: string | null
    occurrenceId: string | null
    key: string | null
    createdAt: Date | null
  }

  export type TaskOccurrenceAttachmentCountAggregateOutputType = {
    id: number
    occurrenceId: number
    key: number
    createdAt: number
    _all: number
  }


  export type TaskOccurrenceAttachmentMinAggregateInputType = {
    id?: true
    occurrenceId?: true
    key?: true
    createdAt?: true
  }

  export type TaskOccurrenceAttachmentMaxAggregateInputType = {
    id?: true
    occurrenceId?: true
    key?: true
    createdAt?: true
  }

  export type TaskOccurrenceAttachmentCountAggregateInputType = {
    id?: true
    occurrenceId?: true
    key?: true
    createdAt?: true
    _all?: true
  }

  export type TaskOccurrenceAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskOccurrenceAttachment to aggregate.
     */
    where?: TaskOccurrenceAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOccurrenceAttachments to fetch.
     */
    orderBy?: TaskOccurrenceAttachmentOrderByWithRelationInput | TaskOccurrenceAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskOccurrenceAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOccurrenceAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOccurrenceAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskOccurrenceAttachments
    **/
    _count?: true | TaskOccurrenceAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskOccurrenceAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskOccurrenceAttachmentMaxAggregateInputType
  }

  export type GetTaskOccurrenceAttachmentAggregateType<T extends TaskOccurrenceAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskOccurrenceAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskOccurrenceAttachment[P]>
      : GetScalarType<T[P], AggregateTaskOccurrenceAttachment[P]>
  }




  export type TaskOccurrenceAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskOccurrenceAttachmentWhereInput
    orderBy?: TaskOccurrenceAttachmentOrderByWithAggregationInput | TaskOccurrenceAttachmentOrderByWithAggregationInput[]
    by: TaskOccurrenceAttachmentScalarFieldEnum[] | TaskOccurrenceAttachmentScalarFieldEnum
    having?: TaskOccurrenceAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskOccurrenceAttachmentCountAggregateInputType | true
    _min?: TaskOccurrenceAttachmentMinAggregateInputType
    _max?: TaskOccurrenceAttachmentMaxAggregateInputType
  }

  export type TaskOccurrenceAttachmentGroupByOutputType = {
    id: string
    occurrenceId: string
    key: string
    createdAt: Date
    _count: TaskOccurrenceAttachmentCountAggregateOutputType | null
    _min: TaskOccurrenceAttachmentMinAggregateOutputType | null
    _max: TaskOccurrenceAttachmentMaxAggregateOutputType | null
  }

  type GetTaskOccurrenceAttachmentGroupByPayload<T extends TaskOccurrenceAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskOccurrenceAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskOccurrenceAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskOccurrenceAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], TaskOccurrenceAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type TaskOccurrenceAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    occurrenceId?: boolean
    key?: boolean
    createdAt?: boolean
    occurrence?: boolean | TaskOccurrenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskOccurrenceAttachment"]>

  export type TaskOccurrenceAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    occurrenceId?: boolean
    key?: boolean
    createdAt?: boolean
    occurrence?: boolean | TaskOccurrenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskOccurrenceAttachment"]>

  export type TaskOccurrenceAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    occurrenceId?: boolean
    key?: boolean
    createdAt?: boolean
    occurrence?: boolean | TaskOccurrenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskOccurrenceAttachment"]>

  export type TaskOccurrenceAttachmentSelectScalar = {
    id?: boolean
    occurrenceId?: boolean
    key?: boolean
    createdAt?: boolean
  }

  export type TaskOccurrenceAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "occurrenceId" | "key" | "createdAt", ExtArgs["result"]["taskOccurrenceAttachment"]>
  export type TaskOccurrenceAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occurrence?: boolean | TaskOccurrenceDefaultArgs<ExtArgs>
  }
  export type TaskOccurrenceAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occurrence?: boolean | TaskOccurrenceDefaultArgs<ExtArgs>
  }
  export type TaskOccurrenceAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occurrence?: boolean | TaskOccurrenceDefaultArgs<ExtArgs>
  }

  export type $TaskOccurrenceAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskOccurrenceAttachment"
    objects: {
      occurrence: Prisma.$TaskOccurrencePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      occurrenceId: string
      key: string
      createdAt: Date
    }, ExtArgs["result"]["taskOccurrenceAttachment"]>
    composites: {}
  }

  type TaskOccurrenceAttachmentGetPayload<S extends boolean | null | undefined | TaskOccurrenceAttachmentDefaultArgs> = $Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload, S>

  type TaskOccurrenceAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskOccurrenceAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskOccurrenceAttachmentCountAggregateInputType | true
    }

  export interface TaskOccurrenceAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskOccurrenceAttachment'], meta: { name: 'TaskOccurrenceAttachment' } }
    /**
     * Find zero or one TaskOccurrenceAttachment that matches the filter.
     * @param {TaskOccurrenceAttachmentFindUniqueArgs} args - Arguments to find a TaskOccurrenceAttachment
     * @example
     * // Get one TaskOccurrenceAttachment
     * const taskOccurrenceAttachment = await prisma.taskOccurrenceAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskOccurrenceAttachmentFindUniqueArgs>(args: SelectSubset<T, TaskOccurrenceAttachmentFindUniqueArgs<ExtArgs>>): Prisma__TaskOccurrenceAttachmentClient<$Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskOccurrenceAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskOccurrenceAttachmentFindUniqueOrThrowArgs} args - Arguments to find a TaskOccurrenceAttachment
     * @example
     * // Get one TaskOccurrenceAttachment
     * const taskOccurrenceAttachment = await prisma.taskOccurrenceAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskOccurrenceAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskOccurrenceAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskOccurrenceAttachmentClient<$Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskOccurrenceAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAttachmentFindFirstArgs} args - Arguments to find a TaskOccurrenceAttachment
     * @example
     * // Get one TaskOccurrenceAttachment
     * const taskOccurrenceAttachment = await prisma.taskOccurrenceAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskOccurrenceAttachmentFindFirstArgs>(args?: SelectSubset<T, TaskOccurrenceAttachmentFindFirstArgs<ExtArgs>>): Prisma__TaskOccurrenceAttachmentClient<$Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskOccurrenceAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAttachmentFindFirstOrThrowArgs} args - Arguments to find a TaskOccurrenceAttachment
     * @example
     * // Get one TaskOccurrenceAttachment
     * const taskOccurrenceAttachment = await prisma.taskOccurrenceAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskOccurrenceAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskOccurrenceAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskOccurrenceAttachmentClient<$Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskOccurrenceAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskOccurrenceAttachments
     * const taskOccurrenceAttachments = await prisma.taskOccurrenceAttachment.findMany()
     * 
     * // Get first 10 TaskOccurrenceAttachments
     * const taskOccurrenceAttachments = await prisma.taskOccurrenceAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskOccurrenceAttachmentWithIdOnly = await prisma.taskOccurrenceAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskOccurrenceAttachmentFindManyArgs>(args?: SelectSubset<T, TaskOccurrenceAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskOccurrenceAttachment.
     * @param {TaskOccurrenceAttachmentCreateArgs} args - Arguments to create a TaskOccurrenceAttachment.
     * @example
     * // Create one TaskOccurrenceAttachment
     * const TaskOccurrenceAttachment = await prisma.taskOccurrenceAttachment.create({
     *   data: {
     *     // ... data to create a TaskOccurrenceAttachment
     *   }
     * })
     * 
     */
    create<T extends TaskOccurrenceAttachmentCreateArgs>(args: SelectSubset<T, TaskOccurrenceAttachmentCreateArgs<ExtArgs>>): Prisma__TaskOccurrenceAttachmentClient<$Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskOccurrenceAttachments.
     * @param {TaskOccurrenceAttachmentCreateManyArgs} args - Arguments to create many TaskOccurrenceAttachments.
     * @example
     * // Create many TaskOccurrenceAttachments
     * const taskOccurrenceAttachment = await prisma.taskOccurrenceAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskOccurrenceAttachmentCreateManyArgs>(args?: SelectSubset<T, TaskOccurrenceAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskOccurrenceAttachments and returns the data saved in the database.
     * @param {TaskOccurrenceAttachmentCreateManyAndReturnArgs} args - Arguments to create many TaskOccurrenceAttachments.
     * @example
     * // Create many TaskOccurrenceAttachments
     * const taskOccurrenceAttachment = await prisma.taskOccurrenceAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskOccurrenceAttachments and only return the `id`
     * const taskOccurrenceAttachmentWithIdOnly = await prisma.taskOccurrenceAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskOccurrenceAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskOccurrenceAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskOccurrenceAttachment.
     * @param {TaskOccurrenceAttachmentDeleteArgs} args - Arguments to delete one TaskOccurrenceAttachment.
     * @example
     * // Delete one TaskOccurrenceAttachment
     * const TaskOccurrenceAttachment = await prisma.taskOccurrenceAttachment.delete({
     *   where: {
     *     // ... filter to delete one TaskOccurrenceAttachment
     *   }
     * })
     * 
     */
    delete<T extends TaskOccurrenceAttachmentDeleteArgs>(args: SelectSubset<T, TaskOccurrenceAttachmentDeleteArgs<ExtArgs>>): Prisma__TaskOccurrenceAttachmentClient<$Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskOccurrenceAttachment.
     * @param {TaskOccurrenceAttachmentUpdateArgs} args - Arguments to update one TaskOccurrenceAttachment.
     * @example
     * // Update one TaskOccurrenceAttachment
     * const taskOccurrenceAttachment = await prisma.taskOccurrenceAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskOccurrenceAttachmentUpdateArgs>(args: SelectSubset<T, TaskOccurrenceAttachmentUpdateArgs<ExtArgs>>): Prisma__TaskOccurrenceAttachmentClient<$Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskOccurrenceAttachments.
     * @param {TaskOccurrenceAttachmentDeleteManyArgs} args - Arguments to filter TaskOccurrenceAttachments to delete.
     * @example
     * // Delete a few TaskOccurrenceAttachments
     * const { count } = await prisma.taskOccurrenceAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskOccurrenceAttachmentDeleteManyArgs>(args?: SelectSubset<T, TaskOccurrenceAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskOccurrenceAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskOccurrenceAttachments
     * const taskOccurrenceAttachment = await prisma.taskOccurrenceAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskOccurrenceAttachmentUpdateManyArgs>(args: SelectSubset<T, TaskOccurrenceAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskOccurrenceAttachments and returns the data updated in the database.
     * @param {TaskOccurrenceAttachmentUpdateManyAndReturnArgs} args - Arguments to update many TaskOccurrenceAttachments.
     * @example
     * // Update many TaskOccurrenceAttachments
     * const taskOccurrenceAttachment = await prisma.taskOccurrenceAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskOccurrenceAttachments and only return the `id`
     * const taskOccurrenceAttachmentWithIdOnly = await prisma.taskOccurrenceAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskOccurrenceAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskOccurrenceAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskOccurrenceAttachment.
     * @param {TaskOccurrenceAttachmentUpsertArgs} args - Arguments to update or create a TaskOccurrenceAttachment.
     * @example
     * // Update or create a TaskOccurrenceAttachment
     * const taskOccurrenceAttachment = await prisma.taskOccurrenceAttachment.upsert({
     *   create: {
     *     // ... data to create a TaskOccurrenceAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskOccurrenceAttachment we want to update
     *   }
     * })
     */
    upsert<T extends TaskOccurrenceAttachmentUpsertArgs>(args: SelectSubset<T, TaskOccurrenceAttachmentUpsertArgs<ExtArgs>>): Prisma__TaskOccurrenceAttachmentClient<$Result.GetResult<Prisma.$TaskOccurrenceAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskOccurrenceAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAttachmentCountArgs} args - Arguments to filter TaskOccurrenceAttachments to count.
     * @example
     * // Count the number of TaskOccurrenceAttachments
     * const count = await prisma.taskOccurrenceAttachment.count({
     *   where: {
     *     // ... the filter for the TaskOccurrenceAttachments we want to count
     *   }
     * })
    **/
    count<T extends TaskOccurrenceAttachmentCountArgs>(
      args?: Subset<T, TaskOccurrenceAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskOccurrenceAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskOccurrenceAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskOccurrenceAttachmentAggregateArgs>(args: Subset<T, TaskOccurrenceAttachmentAggregateArgs>): Prisma.PrismaPromise<GetTaskOccurrenceAttachmentAggregateType<T>>

    /**
     * Group by TaskOccurrenceAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOccurrenceAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskOccurrenceAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskOccurrenceAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: TaskOccurrenceAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskOccurrenceAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskOccurrenceAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskOccurrenceAttachment model
   */
  readonly fields: TaskOccurrenceAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskOccurrenceAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskOccurrenceAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    occurrence<T extends TaskOccurrenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskOccurrenceDefaultArgs<ExtArgs>>): Prisma__TaskOccurrenceClient<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskOccurrenceAttachment model
   */
  interface TaskOccurrenceAttachmentFieldRefs {
    readonly id: FieldRef<"TaskOccurrenceAttachment", 'String'>
    readonly occurrenceId: FieldRef<"TaskOccurrenceAttachment", 'String'>
    readonly key: FieldRef<"TaskOccurrenceAttachment", 'String'>
    readonly createdAt: FieldRef<"TaskOccurrenceAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskOccurrenceAttachment findUnique
   */
  export type TaskOccurrenceAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrenceAttachment to fetch.
     */
    where: TaskOccurrenceAttachmentWhereUniqueInput
  }

  /**
   * TaskOccurrenceAttachment findUniqueOrThrow
   */
  export type TaskOccurrenceAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrenceAttachment to fetch.
     */
    where: TaskOccurrenceAttachmentWhereUniqueInput
  }

  /**
   * TaskOccurrenceAttachment findFirst
   */
  export type TaskOccurrenceAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrenceAttachment to fetch.
     */
    where?: TaskOccurrenceAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOccurrenceAttachments to fetch.
     */
    orderBy?: TaskOccurrenceAttachmentOrderByWithRelationInput | TaskOccurrenceAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskOccurrenceAttachments.
     */
    cursor?: TaskOccurrenceAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOccurrenceAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOccurrenceAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskOccurrenceAttachments.
     */
    distinct?: TaskOccurrenceAttachmentScalarFieldEnum | TaskOccurrenceAttachmentScalarFieldEnum[]
  }

  /**
   * TaskOccurrenceAttachment findFirstOrThrow
   */
  export type TaskOccurrenceAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrenceAttachment to fetch.
     */
    where?: TaskOccurrenceAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOccurrenceAttachments to fetch.
     */
    orderBy?: TaskOccurrenceAttachmentOrderByWithRelationInput | TaskOccurrenceAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskOccurrenceAttachments.
     */
    cursor?: TaskOccurrenceAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOccurrenceAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOccurrenceAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskOccurrenceAttachments.
     */
    distinct?: TaskOccurrenceAttachmentScalarFieldEnum | TaskOccurrenceAttachmentScalarFieldEnum[]
  }

  /**
   * TaskOccurrenceAttachment findMany
   */
  export type TaskOccurrenceAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TaskOccurrenceAttachments to fetch.
     */
    where?: TaskOccurrenceAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOccurrenceAttachments to fetch.
     */
    orderBy?: TaskOccurrenceAttachmentOrderByWithRelationInput | TaskOccurrenceAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskOccurrenceAttachments.
     */
    cursor?: TaskOccurrenceAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOccurrenceAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOccurrenceAttachments.
     */
    skip?: number
    distinct?: TaskOccurrenceAttachmentScalarFieldEnum | TaskOccurrenceAttachmentScalarFieldEnum[]
  }

  /**
   * TaskOccurrenceAttachment create
   */
  export type TaskOccurrenceAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskOccurrenceAttachment.
     */
    data: XOR<TaskOccurrenceAttachmentCreateInput, TaskOccurrenceAttachmentUncheckedCreateInput>
  }

  /**
   * TaskOccurrenceAttachment createMany
   */
  export type TaskOccurrenceAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskOccurrenceAttachments.
     */
    data: TaskOccurrenceAttachmentCreateManyInput | TaskOccurrenceAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskOccurrenceAttachment createManyAndReturn
   */
  export type TaskOccurrenceAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many TaskOccurrenceAttachments.
     */
    data: TaskOccurrenceAttachmentCreateManyInput | TaskOccurrenceAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskOccurrenceAttachment update
   */
  export type TaskOccurrenceAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskOccurrenceAttachment.
     */
    data: XOR<TaskOccurrenceAttachmentUpdateInput, TaskOccurrenceAttachmentUncheckedUpdateInput>
    /**
     * Choose, which TaskOccurrenceAttachment to update.
     */
    where: TaskOccurrenceAttachmentWhereUniqueInput
  }

  /**
   * TaskOccurrenceAttachment updateMany
   */
  export type TaskOccurrenceAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskOccurrenceAttachments.
     */
    data: XOR<TaskOccurrenceAttachmentUpdateManyMutationInput, TaskOccurrenceAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskOccurrenceAttachments to update
     */
    where?: TaskOccurrenceAttachmentWhereInput
    /**
     * Limit how many TaskOccurrenceAttachments to update.
     */
    limit?: number
  }

  /**
   * TaskOccurrenceAttachment updateManyAndReturn
   */
  export type TaskOccurrenceAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update TaskOccurrenceAttachments.
     */
    data: XOR<TaskOccurrenceAttachmentUpdateManyMutationInput, TaskOccurrenceAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TaskOccurrenceAttachments to update
     */
    where?: TaskOccurrenceAttachmentWhereInput
    /**
     * Limit how many TaskOccurrenceAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskOccurrenceAttachment upsert
   */
  export type TaskOccurrenceAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskOccurrenceAttachment to update in case it exists.
     */
    where: TaskOccurrenceAttachmentWhereUniqueInput
    /**
     * In case the TaskOccurrenceAttachment found by the `where` argument doesn't exist, create a new TaskOccurrenceAttachment with this data.
     */
    create: XOR<TaskOccurrenceAttachmentCreateInput, TaskOccurrenceAttachmentUncheckedCreateInput>
    /**
     * In case the TaskOccurrenceAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskOccurrenceAttachmentUpdateInput, TaskOccurrenceAttachmentUncheckedUpdateInput>
  }

  /**
   * TaskOccurrenceAttachment delete
   */
  export type TaskOccurrenceAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentInclude<ExtArgs> | null
    /**
     * Filter which TaskOccurrenceAttachment to delete.
     */
    where: TaskOccurrenceAttachmentWhereUniqueInput
  }

  /**
   * TaskOccurrenceAttachment deleteMany
   */
  export type TaskOccurrenceAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskOccurrenceAttachments to delete
     */
    where?: TaskOccurrenceAttachmentWhereInput
    /**
     * Limit how many TaskOccurrenceAttachments to delete.
     */
    limit?: number
  }

  /**
   * TaskOccurrenceAttachment without action
   */
  export type TaskOccurrenceAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrenceAttachment
     */
    select?: TaskOccurrenceAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrenceAttachment
     */
    omit?: TaskOccurrenceAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model CompletionLog
   */

  export type AggregateCompletionLog = {
    _count: CompletionLogCountAggregateOutputType | null
    _min: CompletionLogMinAggregateOutputType | null
    _max: CompletionLogMaxAggregateOutputType | null
  }

  export type CompletionLogMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    occurrenceAt: Date | null
    type: $Enums.LogType | null
    completedBy: string | null
    note: string | null
    createdAt: Date | null
  }

  export type CompletionLogMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    occurrenceAt: Date | null
    type: $Enums.LogType | null
    completedBy: string | null
    note: string | null
    createdAt: Date | null
  }

  export type CompletionLogCountAggregateOutputType = {
    id: number
    taskId: number
    occurrenceAt: number
    type: number
    completedBy: number
    note: number
    createdAt: number
    _all: number
  }


  export type CompletionLogMinAggregateInputType = {
    id?: true
    taskId?: true
    occurrenceAt?: true
    type?: true
    completedBy?: true
    note?: true
    createdAt?: true
  }

  export type CompletionLogMaxAggregateInputType = {
    id?: true
    taskId?: true
    occurrenceAt?: true
    type?: true
    completedBy?: true
    note?: true
    createdAt?: true
  }

  export type CompletionLogCountAggregateInputType = {
    id?: true
    taskId?: true
    occurrenceAt?: true
    type?: true
    completedBy?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type CompletionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompletionLog to aggregate.
     */
    where?: CompletionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletionLogs to fetch.
     */
    orderBy?: CompletionLogOrderByWithRelationInput | CompletionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompletionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompletionLogs
    **/
    _count?: true | CompletionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompletionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompletionLogMaxAggregateInputType
  }

  export type GetCompletionLogAggregateType<T extends CompletionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCompletionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompletionLog[P]>
      : GetScalarType<T[P], AggregateCompletionLog[P]>
  }




  export type CompletionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompletionLogWhereInput
    orderBy?: CompletionLogOrderByWithAggregationInput | CompletionLogOrderByWithAggregationInput[]
    by: CompletionLogScalarFieldEnum[] | CompletionLogScalarFieldEnum
    having?: CompletionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompletionLogCountAggregateInputType | true
    _min?: CompletionLogMinAggregateInputType
    _max?: CompletionLogMaxAggregateInputType
  }

  export type CompletionLogGroupByOutputType = {
    id: string
    taskId: string
    occurrenceAt: Date
    type: $Enums.LogType
    completedBy: string | null
    note: string | null
    createdAt: Date
    _count: CompletionLogCountAggregateOutputType | null
    _min: CompletionLogMinAggregateOutputType | null
    _max: CompletionLogMaxAggregateOutputType | null
  }

  type GetCompletionLogGroupByPayload<T extends CompletionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompletionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompletionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompletionLogGroupByOutputType[P]>
            : GetScalarType<T[P], CompletionLogGroupByOutputType[P]>
        }
      >
    >


  export type CompletionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    occurrenceAt?: boolean
    type?: boolean
    completedBy?: boolean
    note?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["completionLog"]>

  export type CompletionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    occurrenceAt?: boolean
    type?: boolean
    completedBy?: boolean
    note?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["completionLog"]>

  export type CompletionLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    occurrenceAt?: boolean
    type?: boolean
    completedBy?: boolean
    note?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["completionLog"]>

  export type CompletionLogSelectScalar = {
    id?: boolean
    taskId?: boolean
    occurrenceAt?: boolean
    type?: boolean
    completedBy?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type CompletionLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "occurrenceAt" | "type" | "completedBy" | "note" | "createdAt", ExtArgs["result"]["completionLog"]>

  export type $CompletionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompletionLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      occurrenceAt: Date
      type: $Enums.LogType
      completedBy: string | null
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["completionLog"]>
    composites: {}
  }

  type CompletionLogGetPayload<S extends boolean | null | undefined | CompletionLogDefaultArgs> = $Result.GetResult<Prisma.$CompletionLogPayload, S>

  type CompletionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompletionLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompletionLogCountAggregateInputType | true
    }

  export interface CompletionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompletionLog'], meta: { name: 'CompletionLog' } }
    /**
     * Find zero or one CompletionLog that matches the filter.
     * @param {CompletionLogFindUniqueArgs} args - Arguments to find a CompletionLog
     * @example
     * // Get one CompletionLog
     * const completionLog = await prisma.completionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompletionLogFindUniqueArgs>(args: SelectSubset<T, CompletionLogFindUniqueArgs<ExtArgs>>): Prisma__CompletionLogClient<$Result.GetResult<Prisma.$CompletionLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompletionLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompletionLogFindUniqueOrThrowArgs} args - Arguments to find a CompletionLog
     * @example
     * // Get one CompletionLog
     * const completionLog = await prisma.completionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompletionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CompletionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompletionLogClient<$Result.GetResult<Prisma.$CompletionLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompletionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionLogFindFirstArgs} args - Arguments to find a CompletionLog
     * @example
     * // Get one CompletionLog
     * const completionLog = await prisma.completionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompletionLogFindFirstArgs>(args?: SelectSubset<T, CompletionLogFindFirstArgs<ExtArgs>>): Prisma__CompletionLogClient<$Result.GetResult<Prisma.$CompletionLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompletionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionLogFindFirstOrThrowArgs} args - Arguments to find a CompletionLog
     * @example
     * // Get one CompletionLog
     * const completionLog = await prisma.completionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompletionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CompletionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompletionLogClient<$Result.GetResult<Prisma.$CompletionLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompletionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompletionLogs
     * const completionLogs = await prisma.completionLog.findMany()
     * 
     * // Get first 10 CompletionLogs
     * const completionLogs = await prisma.completionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const completionLogWithIdOnly = await prisma.completionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompletionLogFindManyArgs>(args?: SelectSubset<T, CompletionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompletionLog.
     * @param {CompletionLogCreateArgs} args - Arguments to create a CompletionLog.
     * @example
     * // Create one CompletionLog
     * const CompletionLog = await prisma.completionLog.create({
     *   data: {
     *     // ... data to create a CompletionLog
     *   }
     * })
     * 
     */
    create<T extends CompletionLogCreateArgs>(args: SelectSubset<T, CompletionLogCreateArgs<ExtArgs>>): Prisma__CompletionLogClient<$Result.GetResult<Prisma.$CompletionLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompletionLogs.
     * @param {CompletionLogCreateManyArgs} args - Arguments to create many CompletionLogs.
     * @example
     * // Create many CompletionLogs
     * const completionLog = await prisma.completionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompletionLogCreateManyArgs>(args?: SelectSubset<T, CompletionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompletionLogs and returns the data saved in the database.
     * @param {CompletionLogCreateManyAndReturnArgs} args - Arguments to create many CompletionLogs.
     * @example
     * // Create many CompletionLogs
     * const completionLog = await prisma.completionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompletionLogs and only return the `id`
     * const completionLogWithIdOnly = await prisma.completionLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompletionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CompletionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletionLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompletionLog.
     * @param {CompletionLogDeleteArgs} args - Arguments to delete one CompletionLog.
     * @example
     * // Delete one CompletionLog
     * const CompletionLog = await prisma.completionLog.delete({
     *   where: {
     *     // ... filter to delete one CompletionLog
     *   }
     * })
     * 
     */
    delete<T extends CompletionLogDeleteArgs>(args: SelectSubset<T, CompletionLogDeleteArgs<ExtArgs>>): Prisma__CompletionLogClient<$Result.GetResult<Prisma.$CompletionLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompletionLog.
     * @param {CompletionLogUpdateArgs} args - Arguments to update one CompletionLog.
     * @example
     * // Update one CompletionLog
     * const completionLog = await prisma.completionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompletionLogUpdateArgs>(args: SelectSubset<T, CompletionLogUpdateArgs<ExtArgs>>): Prisma__CompletionLogClient<$Result.GetResult<Prisma.$CompletionLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompletionLogs.
     * @param {CompletionLogDeleteManyArgs} args - Arguments to filter CompletionLogs to delete.
     * @example
     * // Delete a few CompletionLogs
     * const { count } = await prisma.completionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompletionLogDeleteManyArgs>(args?: SelectSubset<T, CompletionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompletionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompletionLogs
     * const completionLog = await prisma.completionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompletionLogUpdateManyArgs>(args: SelectSubset<T, CompletionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompletionLogs and returns the data updated in the database.
     * @param {CompletionLogUpdateManyAndReturnArgs} args - Arguments to update many CompletionLogs.
     * @example
     * // Update many CompletionLogs
     * const completionLog = await prisma.completionLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompletionLogs and only return the `id`
     * const completionLogWithIdOnly = await prisma.completionLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompletionLogUpdateManyAndReturnArgs>(args: SelectSubset<T, CompletionLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletionLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompletionLog.
     * @param {CompletionLogUpsertArgs} args - Arguments to update or create a CompletionLog.
     * @example
     * // Update or create a CompletionLog
     * const completionLog = await prisma.completionLog.upsert({
     *   create: {
     *     // ... data to create a CompletionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompletionLog we want to update
     *   }
     * })
     */
    upsert<T extends CompletionLogUpsertArgs>(args: SelectSubset<T, CompletionLogUpsertArgs<ExtArgs>>): Prisma__CompletionLogClient<$Result.GetResult<Prisma.$CompletionLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompletionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionLogCountArgs} args - Arguments to filter CompletionLogs to count.
     * @example
     * // Count the number of CompletionLogs
     * const count = await prisma.completionLog.count({
     *   where: {
     *     // ... the filter for the CompletionLogs we want to count
     *   }
     * })
    **/
    count<T extends CompletionLogCountArgs>(
      args?: Subset<T, CompletionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompletionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompletionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompletionLogAggregateArgs>(args: Subset<T, CompletionLogAggregateArgs>): Prisma.PrismaPromise<GetCompletionLogAggregateType<T>>

    /**
     * Group by CompletionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompletionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompletionLogGroupByArgs['orderBy'] }
        : { orderBy?: CompletionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompletionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompletionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompletionLog model
   */
  readonly fields: CompletionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompletionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompletionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompletionLog model
   */
  interface CompletionLogFieldRefs {
    readonly id: FieldRef<"CompletionLog", 'String'>
    readonly taskId: FieldRef<"CompletionLog", 'String'>
    readonly occurrenceAt: FieldRef<"CompletionLog", 'DateTime'>
    readonly type: FieldRef<"CompletionLog", 'LogType'>
    readonly completedBy: FieldRef<"CompletionLog", 'String'>
    readonly note: FieldRef<"CompletionLog", 'String'>
    readonly createdAt: FieldRef<"CompletionLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompletionLog findUnique
   */
  export type CompletionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionLog
     */
    select?: CompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionLog
     */
    omit?: CompletionLogOmit<ExtArgs> | null
    /**
     * Filter, which CompletionLog to fetch.
     */
    where: CompletionLogWhereUniqueInput
  }

  /**
   * CompletionLog findUniqueOrThrow
   */
  export type CompletionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionLog
     */
    select?: CompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionLog
     */
    omit?: CompletionLogOmit<ExtArgs> | null
    /**
     * Filter, which CompletionLog to fetch.
     */
    where: CompletionLogWhereUniqueInput
  }

  /**
   * CompletionLog findFirst
   */
  export type CompletionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionLog
     */
    select?: CompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionLog
     */
    omit?: CompletionLogOmit<ExtArgs> | null
    /**
     * Filter, which CompletionLog to fetch.
     */
    where?: CompletionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletionLogs to fetch.
     */
    orderBy?: CompletionLogOrderByWithRelationInput | CompletionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompletionLogs.
     */
    cursor?: CompletionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompletionLogs.
     */
    distinct?: CompletionLogScalarFieldEnum | CompletionLogScalarFieldEnum[]
  }

  /**
   * CompletionLog findFirstOrThrow
   */
  export type CompletionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionLog
     */
    select?: CompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionLog
     */
    omit?: CompletionLogOmit<ExtArgs> | null
    /**
     * Filter, which CompletionLog to fetch.
     */
    where?: CompletionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletionLogs to fetch.
     */
    orderBy?: CompletionLogOrderByWithRelationInput | CompletionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompletionLogs.
     */
    cursor?: CompletionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompletionLogs.
     */
    distinct?: CompletionLogScalarFieldEnum | CompletionLogScalarFieldEnum[]
  }

  /**
   * CompletionLog findMany
   */
  export type CompletionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionLog
     */
    select?: CompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionLog
     */
    omit?: CompletionLogOmit<ExtArgs> | null
    /**
     * Filter, which CompletionLogs to fetch.
     */
    where?: CompletionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletionLogs to fetch.
     */
    orderBy?: CompletionLogOrderByWithRelationInput | CompletionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompletionLogs.
     */
    cursor?: CompletionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletionLogs.
     */
    skip?: number
    distinct?: CompletionLogScalarFieldEnum | CompletionLogScalarFieldEnum[]
  }

  /**
   * CompletionLog create
   */
  export type CompletionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionLog
     */
    select?: CompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionLog
     */
    omit?: CompletionLogOmit<ExtArgs> | null
    /**
     * The data needed to create a CompletionLog.
     */
    data: XOR<CompletionLogCreateInput, CompletionLogUncheckedCreateInput>
  }

  /**
   * CompletionLog createMany
   */
  export type CompletionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompletionLogs.
     */
    data: CompletionLogCreateManyInput | CompletionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompletionLog createManyAndReturn
   */
  export type CompletionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionLog
     */
    select?: CompletionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionLog
     */
    omit?: CompletionLogOmit<ExtArgs> | null
    /**
     * The data used to create many CompletionLogs.
     */
    data: CompletionLogCreateManyInput | CompletionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompletionLog update
   */
  export type CompletionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionLog
     */
    select?: CompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionLog
     */
    omit?: CompletionLogOmit<ExtArgs> | null
    /**
     * The data needed to update a CompletionLog.
     */
    data: XOR<CompletionLogUpdateInput, CompletionLogUncheckedUpdateInput>
    /**
     * Choose, which CompletionLog to update.
     */
    where: CompletionLogWhereUniqueInput
  }

  /**
   * CompletionLog updateMany
   */
  export type CompletionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompletionLogs.
     */
    data: XOR<CompletionLogUpdateManyMutationInput, CompletionLogUncheckedUpdateManyInput>
    /**
     * Filter which CompletionLogs to update
     */
    where?: CompletionLogWhereInput
    /**
     * Limit how many CompletionLogs to update.
     */
    limit?: number
  }

  /**
   * CompletionLog updateManyAndReturn
   */
  export type CompletionLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionLog
     */
    select?: CompletionLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionLog
     */
    omit?: CompletionLogOmit<ExtArgs> | null
    /**
     * The data used to update CompletionLogs.
     */
    data: XOR<CompletionLogUpdateManyMutationInput, CompletionLogUncheckedUpdateManyInput>
    /**
     * Filter which CompletionLogs to update
     */
    where?: CompletionLogWhereInput
    /**
     * Limit how many CompletionLogs to update.
     */
    limit?: number
  }

  /**
   * CompletionLog upsert
   */
  export type CompletionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionLog
     */
    select?: CompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionLog
     */
    omit?: CompletionLogOmit<ExtArgs> | null
    /**
     * The filter to search for the CompletionLog to update in case it exists.
     */
    where: CompletionLogWhereUniqueInput
    /**
     * In case the CompletionLog found by the `where` argument doesn't exist, create a new CompletionLog with this data.
     */
    create: XOR<CompletionLogCreateInput, CompletionLogUncheckedCreateInput>
    /**
     * In case the CompletionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompletionLogUpdateInput, CompletionLogUncheckedUpdateInput>
  }

  /**
   * CompletionLog delete
   */
  export type CompletionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionLog
     */
    select?: CompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionLog
     */
    omit?: CompletionLogOmit<ExtArgs> | null
    /**
     * Filter which CompletionLog to delete.
     */
    where: CompletionLogWhereUniqueInput
  }

  /**
   * CompletionLog deleteMany
   */
  export type CompletionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompletionLogs to delete
     */
    where?: CompletionLogWhereInput
    /**
     * Limit how many CompletionLogs to delete.
     */
    limit?: number
  }

  /**
   * CompletionLog without action
   */
  export type CompletionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletionLog
     */
    select?: CompletionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletionLog
     */
    omit?: CompletionLogOmit<ExtArgs> | null
  }


  /**
   * Model Reminder
   */

  export type AggregateReminder = {
    _count: ReminderCountAggregateOutputType | null
    _min: ReminderMinAggregateOutputType | null
    _max: ReminderMaxAggregateOutputType | null
  }

  export type ReminderMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    occurrenceAt: Date | null
    remindAt: Date | null
    channel: string | null
    sent: boolean | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type ReminderMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    occurrenceAt: Date | null
    remindAt: Date | null
    channel: string | null
    sent: boolean | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type ReminderCountAggregateOutputType = {
    id: number
    taskId: number
    occurrenceAt: number
    remindAt: number
    channel: number
    payload: number
    sent: number
    sentAt: number
    createdAt: number
    _all: number
  }


  export type ReminderMinAggregateInputType = {
    id?: true
    taskId?: true
    occurrenceAt?: true
    remindAt?: true
    channel?: true
    sent?: true
    sentAt?: true
    createdAt?: true
  }

  export type ReminderMaxAggregateInputType = {
    id?: true
    taskId?: true
    occurrenceAt?: true
    remindAt?: true
    channel?: true
    sent?: true
    sentAt?: true
    createdAt?: true
  }

  export type ReminderCountAggregateInputType = {
    id?: true
    taskId?: true
    occurrenceAt?: true
    remindAt?: true
    channel?: true
    payload?: true
    sent?: true
    sentAt?: true
    createdAt?: true
    _all?: true
  }

  export type ReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reminder to aggregate.
     */
    where?: ReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reminders to fetch.
     */
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reminders
    **/
    _count?: true | ReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReminderMaxAggregateInputType
  }

  export type GetReminderAggregateType<T extends ReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReminder[P]>
      : GetScalarType<T[P], AggregateReminder[P]>
  }




  export type ReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderWhereInput
    orderBy?: ReminderOrderByWithAggregationInput | ReminderOrderByWithAggregationInput[]
    by: ReminderScalarFieldEnum[] | ReminderScalarFieldEnum
    having?: ReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReminderCountAggregateInputType | true
    _min?: ReminderMinAggregateInputType
    _max?: ReminderMaxAggregateInputType
  }

  export type ReminderGroupByOutputType = {
    id: string
    taskId: string
    occurrenceAt: Date
    remindAt: Date
    channel: string | null
    payload: JsonValue | null
    sent: boolean
    sentAt: Date | null
    createdAt: Date
    _count: ReminderCountAggregateOutputType | null
    _min: ReminderMinAggregateOutputType | null
    _max: ReminderMaxAggregateOutputType | null
  }

  type GetReminderGroupByPayload<T extends ReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReminderGroupByOutputType[P]>
            : GetScalarType<T[P], ReminderGroupByOutputType[P]>
        }
      >
    >


  export type ReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    occurrenceAt?: boolean
    remindAt?: boolean
    channel?: boolean
    payload?: boolean
    sent?: boolean
    sentAt?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reminder"]>

  export type ReminderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    occurrenceAt?: boolean
    remindAt?: boolean
    channel?: boolean
    payload?: boolean
    sent?: boolean
    sentAt?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reminder"]>

  export type ReminderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    occurrenceAt?: boolean
    remindAt?: boolean
    channel?: boolean
    payload?: boolean
    sent?: boolean
    sentAt?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reminder"]>

  export type ReminderSelectScalar = {
    id?: boolean
    taskId?: boolean
    occurrenceAt?: boolean
    remindAt?: boolean
    channel?: boolean
    payload?: boolean
    sent?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }

  export type ReminderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "occurrenceAt" | "remindAt" | "channel" | "payload" | "sent" | "sentAt" | "createdAt", ExtArgs["result"]["reminder"]>
  export type ReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type ReminderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type ReminderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $ReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reminder"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      occurrenceAt: Date
      remindAt: Date
      channel: string | null
      payload: Prisma.JsonValue | null
      sent: boolean
      sentAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["reminder"]>
    composites: {}
  }

  type ReminderGetPayload<S extends boolean | null | undefined | ReminderDefaultArgs> = $Result.GetResult<Prisma.$ReminderPayload, S>

  type ReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReminderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReminderCountAggregateInputType | true
    }

  export interface ReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reminder'], meta: { name: 'Reminder' } }
    /**
     * Find zero or one Reminder that matches the filter.
     * @param {ReminderFindUniqueArgs} args - Arguments to find a Reminder
     * @example
     * // Get one Reminder
     * const reminder = await prisma.reminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReminderFindUniqueArgs>(args: SelectSubset<T, ReminderFindUniqueArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reminder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReminderFindUniqueOrThrowArgs} args - Arguments to find a Reminder
     * @example
     * // Get one Reminder
     * const reminder = await prisma.reminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, ReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderFindFirstArgs} args - Arguments to find a Reminder
     * @example
     * // Get one Reminder
     * const reminder = await prisma.reminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReminderFindFirstArgs>(args?: SelectSubset<T, ReminderFindFirstArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderFindFirstOrThrowArgs} args - Arguments to find a Reminder
     * @example
     * // Get one Reminder
     * const reminder = await prisma.reminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, ReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reminders
     * const reminders = await prisma.reminder.findMany()
     * 
     * // Get first 10 Reminders
     * const reminders = await prisma.reminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reminderWithIdOnly = await prisma.reminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReminderFindManyArgs>(args?: SelectSubset<T, ReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reminder.
     * @param {ReminderCreateArgs} args - Arguments to create a Reminder.
     * @example
     * // Create one Reminder
     * const Reminder = await prisma.reminder.create({
     *   data: {
     *     // ... data to create a Reminder
     *   }
     * })
     * 
     */
    create<T extends ReminderCreateArgs>(args: SelectSubset<T, ReminderCreateArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reminders.
     * @param {ReminderCreateManyArgs} args - Arguments to create many Reminders.
     * @example
     * // Create many Reminders
     * const reminder = await prisma.reminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReminderCreateManyArgs>(args?: SelectSubset<T, ReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reminders and returns the data saved in the database.
     * @param {ReminderCreateManyAndReturnArgs} args - Arguments to create many Reminders.
     * @example
     * // Create many Reminders
     * const reminder = await prisma.reminder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reminders and only return the `id`
     * const reminderWithIdOnly = await prisma.reminder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReminderCreateManyAndReturnArgs>(args?: SelectSubset<T, ReminderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reminder.
     * @param {ReminderDeleteArgs} args - Arguments to delete one Reminder.
     * @example
     * // Delete one Reminder
     * const Reminder = await prisma.reminder.delete({
     *   where: {
     *     // ... filter to delete one Reminder
     *   }
     * })
     * 
     */
    delete<T extends ReminderDeleteArgs>(args: SelectSubset<T, ReminderDeleteArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reminder.
     * @param {ReminderUpdateArgs} args - Arguments to update one Reminder.
     * @example
     * // Update one Reminder
     * const reminder = await prisma.reminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReminderUpdateArgs>(args: SelectSubset<T, ReminderUpdateArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reminders.
     * @param {ReminderDeleteManyArgs} args - Arguments to filter Reminders to delete.
     * @example
     * // Delete a few Reminders
     * const { count } = await prisma.reminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReminderDeleteManyArgs>(args?: SelectSubset<T, ReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reminders
     * const reminder = await prisma.reminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReminderUpdateManyArgs>(args: SelectSubset<T, ReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reminders and returns the data updated in the database.
     * @param {ReminderUpdateManyAndReturnArgs} args - Arguments to update many Reminders.
     * @example
     * // Update many Reminders
     * const reminder = await prisma.reminder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reminders and only return the `id`
     * const reminderWithIdOnly = await prisma.reminder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReminderUpdateManyAndReturnArgs>(args: SelectSubset<T, ReminderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reminder.
     * @param {ReminderUpsertArgs} args - Arguments to update or create a Reminder.
     * @example
     * // Update or create a Reminder
     * const reminder = await prisma.reminder.upsert({
     *   create: {
     *     // ... data to create a Reminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reminder we want to update
     *   }
     * })
     */
    upsert<T extends ReminderUpsertArgs>(args: SelectSubset<T, ReminderUpsertArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderCountArgs} args - Arguments to filter Reminders to count.
     * @example
     * // Count the number of Reminders
     * const count = await prisma.reminder.count({
     *   where: {
     *     // ... the filter for the Reminders we want to count
     *   }
     * })
    **/
    count<T extends ReminderCountArgs>(
      args?: Subset<T, ReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReminderAggregateArgs>(args: Subset<T, ReminderAggregateArgs>): Prisma.PrismaPromise<GetReminderAggregateType<T>>

    /**
     * Group by Reminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReminderGroupByArgs['orderBy'] }
        : { orderBy?: ReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reminder model
   */
  readonly fields: ReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reminder model
   */
  interface ReminderFieldRefs {
    readonly id: FieldRef<"Reminder", 'String'>
    readonly taskId: FieldRef<"Reminder", 'String'>
    readonly occurrenceAt: FieldRef<"Reminder", 'DateTime'>
    readonly remindAt: FieldRef<"Reminder", 'DateTime'>
    readonly channel: FieldRef<"Reminder", 'String'>
    readonly payload: FieldRef<"Reminder", 'Json'>
    readonly sent: FieldRef<"Reminder", 'Boolean'>
    readonly sentAt: FieldRef<"Reminder", 'DateTime'>
    readonly createdAt: FieldRef<"Reminder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reminder findUnique
   */
  export type ReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminder to fetch.
     */
    where: ReminderWhereUniqueInput
  }

  /**
   * Reminder findUniqueOrThrow
   */
  export type ReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminder to fetch.
     */
    where: ReminderWhereUniqueInput
  }

  /**
   * Reminder findFirst
   */
  export type ReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminder to fetch.
     */
    where?: ReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reminders to fetch.
     */
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reminders.
     */
    cursor?: ReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reminders.
     */
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * Reminder findFirstOrThrow
   */
  export type ReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminder to fetch.
     */
    where?: ReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reminders to fetch.
     */
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reminders.
     */
    cursor?: ReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reminders.
     */
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * Reminder findMany
   */
  export type ReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminders to fetch.
     */
    where?: ReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reminders to fetch.
     */
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reminders.
     */
    cursor?: ReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reminders.
     */
    skip?: number
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * Reminder create
   */
  export type ReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a Reminder.
     */
    data: XOR<ReminderCreateInput, ReminderUncheckedCreateInput>
  }

  /**
   * Reminder createMany
   */
  export type ReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reminders.
     */
    data: ReminderCreateManyInput | ReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reminder createManyAndReturn
   */
  export type ReminderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * The data used to create many Reminders.
     */
    data: ReminderCreateManyInput | ReminderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reminder update
   */
  export type ReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a Reminder.
     */
    data: XOR<ReminderUpdateInput, ReminderUncheckedUpdateInput>
    /**
     * Choose, which Reminder to update.
     */
    where: ReminderWhereUniqueInput
  }

  /**
   * Reminder updateMany
   */
  export type ReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reminders.
     */
    data: XOR<ReminderUpdateManyMutationInput, ReminderUncheckedUpdateManyInput>
    /**
     * Filter which Reminders to update
     */
    where?: ReminderWhereInput
    /**
     * Limit how many Reminders to update.
     */
    limit?: number
  }

  /**
   * Reminder updateManyAndReturn
   */
  export type ReminderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * The data used to update Reminders.
     */
    data: XOR<ReminderUpdateManyMutationInput, ReminderUncheckedUpdateManyInput>
    /**
     * Filter which Reminders to update
     */
    where?: ReminderWhereInput
    /**
     * Limit how many Reminders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reminder upsert
   */
  export type ReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the Reminder to update in case it exists.
     */
    where: ReminderWhereUniqueInput
    /**
     * In case the Reminder found by the `where` argument doesn't exist, create a new Reminder with this data.
     */
    create: XOR<ReminderCreateInput, ReminderUncheckedCreateInput>
    /**
     * In case the Reminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReminderUpdateInput, ReminderUncheckedUpdateInput>
  }

  /**
   * Reminder delete
   */
  export type ReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter which Reminder to delete.
     */
    where: ReminderWhereUniqueInput
  }

  /**
   * Reminder deleteMany
   */
  export type ReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reminders to delete
     */
    where?: ReminderWhereInput
    /**
     * Limit how many Reminders to delete.
     */
    limit?: number
  }

  /**
   * Reminder without action
   */
  export type ReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
  }


  /**
   * Model CalendarEntry
   */

  export type AggregateCalendarEntry = {
    _count: CalendarEntryCountAggregateOutputType | null
    _avg: CalendarEntryAvgAggregateOutputType | null
    _sum: CalendarEntrySumAggregateOutputType | null
    _min: CalendarEntryMinAggregateOutputType | null
    _max: CalendarEntryMaxAggregateOutputType | null
  }

  export type CalendarEntryAvgAggregateOutputType = {
    interval: number | null
    count: number | null
  }

  export type CalendarEntrySumAggregateOutputType = {
    interval: number | null
    count: number | null
  }

  export type CalendarEntryMinAggregateOutputType = {
    id: string | null
    createdById: string | null
    type: $Enums.CalendarEntryType | null
    title: string | null
    description: string | null
    start: Date | null
    end: Date | null
    allDay: boolean | null
    freq: $Enums.RecurrenceFreq | null
    interval: number | null
    until: Date | null
    count: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarEntryMaxAggregateOutputType = {
    id: string | null
    createdById: string | null
    type: $Enums.CalendarEntryType | null
    title: string | null
    description: string | null
    start: Date | null
    end: Date | null
    allDay: boolean | null
    freq: $Enums.RecurrenceFreq | null
    interval: number | null
    until: Date | null
    count: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarEntryCountAggregateOutputType = {
    id: number
    createdById: number
    type: number
    title: number
    description: number
    start: number
    end: number
    allDay: number
    freq: number
    interval: number
    until: number
    count: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarEntryAvgAggregateInputType = {
    interval?: true
    count?: true
  }

  export type CalendarEntrySumAggregateInputType = {
    interval?: true
    count?: true
  }

  export type CalendarEntryMinAggregateInputType = {
    id?: true
    createdById?: true
    type?: true
    title?: true
    description?: true
    start?: true
    end?: true
    allDay?: true
    freq?: true
    interval?: true
    until?: true
    count?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarEntryMaxAggregateInputType = {
    id?: true
    createdById?: true
    type?: true
    title?: true
    description?: true
    start?: true
    end?: true
    allDay?: true
    freq?: true
    interval?: true
    until?: true
    count?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarEntryCountAggregateInputType = {
    id?: true
    createdById?: true
    type?: true
    title?: true
    description?: true
    start?: true
    end?: true
    allDay?: true
    freq?: true
    interval?: true
    until?: true
    count?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEntry to aggregate.
     */
    where?: CalendarEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEntries to fetch.
     */
    orderBy?: CalendarEntryOrderByWithRelationInput | CalendarEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEntries
    **/
    _count?: true | CalendarEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEntryMaxAggregateInputType
  }

  export type GetCalendarEntryAggregateType<T extends CalendarEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEntry[P]>
      : GetScalarType<T[P], AggregateCalendarEntry[P]>
  }




  export type CalendarEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEntryWhereInput
    orderBy?: CalendarEntryOrderByWithAggregationInput | CalendarEntryOrderByWithAggregationInput[]
    by: CalendarEntryScalarFieldEnum[] | CalendarEntryScalarFieldEnum
    having?: CalendarEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEntryCountAggregateInputType | true
    _avg?: CalendarEntryAvgAggregateInputType
    _sum?: CalendarEntrySumAggregateInputType
    _min?: CalendarEntryMinAggregateInputType
    _max?: CalendarEntryMaxAggregateInputType
  }

  export type CalendarEntryGroupByOutputType = {
    id: string
    createdById: string
    type: $Enums.CalendarEntryType
    title: string
    description: string | null
    start: Date
    end: Date | null
    allDay: boolean
    freq: $Enums.RecurrenceFreq | null
    interval: number | null
    until: Date | null
    count: number | null
    createdAt: Date
    updatedAt: Date
    _count: CalendarEntryCountAggregateOutputType | null
    _avg: CalendarEntryAvgAggregateOutputType | null
    _sum: CalendarEntrySumAggregateOutputType | null
    _min: CalendarEntryMinAggregateOutputType | null
    _max: CalendarEntryMaxAggregateOutputType | null
  }

  type GetCalendarEntryGroupByPayload<T extends CalendarEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEntryGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEntryGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdById?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    start?: boolean
    end?: boolean
    allDay?: boolean
    freq?: boolean
    interval?: boolean
    until?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["calendarEntry"]>

  export type CalendarEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdById?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    start?: boolean
    end?: boolean
    allDay?: boolean
    freq?: boolean
    interval?: boolean
    until?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["calendarEntry"]>

  export type CalendarEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdById?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    start?: boolean
    end?: boolean
    allDay?: boolean
    freq?: boolean
    interval?: boolean
    until?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["calendarEntry"]>

  export type CalendarEntrySelectScalar = {
    id?: boolean
    createdById?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    start?: boolean
    end?: boolean
    allDay?: boolean
    freq?: boolean
    interval?: boolean
    until?: boolean
    count?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalendarEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdById" | "type" | "title" | "description" | "start" | "end" | "allDay" | "freq" | "interval" | "until" | "count" | "createdAt" | "updatedAt", ExtArgs["result"]["calendarEntry"]>

  export type $CalendarEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEntry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdById: string
      type: $Enums.CalendarEntryType
      title: string
      description: string | null
      start: Date
      end: Date | null
      allDay: boolean
      freq: $Enums.RecurrenceFreq | null
      interval: number | null
      until: Date | null
      count: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendarEntry"]>
    composites: {}
  }

  type CalendarEntryGetPayload<S extends boolean | null | undefined | CalendarEntryDefaultArgs> = $Result.GetResult<Prisma.$CalendarEntryPayload, S>

  type CalendarEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarEntryCountAggregateInputType | true
    }

  export interface CalendarEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEntry'], meta: { name: 'CalendarEntry' } }
    /**
     * Find zero or one CalendarEntry that matches the filter.
     * @param {CalendarEntryFindUniqueArgs} args - Arguments to find a CalendarEntry
     * @example
     * // Get one CalendarEntry
     * const calendarEntry = await prisma.calendarEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEntryFindUniqueArgs>(args: SelectSubset<T, CalendarEntryFindUniqueArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalendarEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarEntryFindUniqueOrThrowArgs} args - Arguments to find a CalendarEntry
     * @example
     * // Get one CalendarEntry
     * const calendarEntry = await prisma.calendarEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryFindFirstArgs} args - Arguments to find a CalendarEntry
     * @example
     * // Get one CalendarEntry
     * const calendarEntry = await prisma.calendarEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEntryFindFirstArgs>(args?: SelectSubset<T, CalendarEntryFindFirstArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryFindFirstOrThrowArgs} args - Arguments to find a CalendarEntry
     * @example
     * // Get one CalendarEntry
     * const calendarEntry = await prisma.calendarEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalendarEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEntries
     * const calendarEntries = await prisma.calendarEntry.findMany()
     * 
     * // Get first 10 CalendarEntries
     * const calendarEntries = await prisma.calendarEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEntryWithIdOnly = await prisma.calendarEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEntryFindManyArgs>(args?: SelectSubset<T, CalendarEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalendarEntry.
     * @param {CalendarEntryCreateArgs} args - Arguments to create a CalendarEntry.
     * @example
     * // Create one CalendarEntry
     * const CalendarEntry = await prisma.calendarEntry.create({
     *   data: {
     *     // ... data to create a CalendarEntry
     *   }
     * })
     * 
     */
    create<T extends CalendarEntryCreateArgs>(args: SelectSubset<T, CalendarEntryCreateArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalendarEntries.
     * @param {CalendarEntryCreateManyArgs} args - Arguments to create many CalendarEntries.
     * @example
     * // Create many CalendarEntries
     * const calendarEntry = await prisma.calendarEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEntryCreateManyArgs>(args?: SelectSubset<T, CalendarEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarEntries and returns the data saved in the database.
     * @param {CalendarEntryCreateManyAndReturnArgs} args - Arguments to create many CalendarEntries.
     * @example
     * // Create many CalendarEntries
     * const calendarEntry = await prisma.calendarEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarEntries and only return the `id`
     * const calendarEntryWithIdOnly = await prisma.calendarEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CalendarEntry.
     * @param {CalendarEntryDeleteArgs} args - Arguments to delete one CalendarEntry.
     * @example
     * // Delete one CalendarEntry
     * const CalendarEntry = await prisma.calendarEntry.delete({
     *   where: {
     *     // ... filter to delete one CalendarEntry
     *   }
     * })
     * 
     */
    delete<T extends CalendarEntryDeleteArgs>(args: SelectSubset<T, CalendarEntryDeleteArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalendarEntry.
     * @param {CalendarEntryUpdateArgs} args - Arguments to update one CalendarEntry.
     * @example
     * // Update one CalendarEntry
     * const calendarEntry = await prisma.calendarEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEntryUpdateArgs>(args: SelectSubset<T, CalendarEntryUpdateArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalendarEntries.
     * @param {CalendarEntryDeleteManyArgs} args - Arguments to filter CalendarEntries to delete.
     * @example
     * // Delete a few CalendarEntries
     * const { count } = await prisma.calendarEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEntryDeleteManyArgs>(args?: SelectSubset<T, CalendarEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEntries
     * const calendarEntry = await prisma.calendarEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEntryUpdateManyArgs>(args: SelectSubset<T, CalendarEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEntries and returns the data updated in the database.
     * @param {CalendarEntryUpdateManyAndReturnArgs} args - Arguments to update many CalendarEntries.
     * @example
     * // Update many CalendarEntries
     * const calendarEntry = await prisma.calendarEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CalendarEntries and only return the `id`
     * const calendarEntryWithIdOnly = await prisma.calendarEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalendarEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, CalendarEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CalendarEntry.
     * @param {CalendarEntryUpsertArgs} args - Arguments to update or create a CalendarEntry.
     * @example
     * // Update or create a CalendarEntry
     * const calendarEntry = await prisma.calendarEntry.upsert({
     *   create: {
     *     // ... data to create a CalendarEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEntry we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEntryUpsertArgs>(args: SelectSubset<T, CalendarEntryUpsertArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalendarEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryCountArgs} args - Arguments to filter CalendarEntries to count.
     * @example
     * // Count the number of CalendarEntries
     * const count = await prisma.calendarEntry.count({
     *   where: {
     *     // ... the filter for the CalendarEntries we want to count
     *   }
     * })
    **/
    count<T extends CalendarEntryCountArgs>(
      args?: Subset<T, CalendarEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEntryAggregateArgs>(args: Subset<T, CalendarEntryAggregateArgs>): Prisma.PrismaPromise<GetCalendarEntryAggregateType<T>>

    /**
     * Group by CalendarEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEntryGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEntry model
   */
  readonly fields: CalendarEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEntry model
   */
  interface CalendarEntryFieldRefs {
    readonly id: FieldRef<"CalendarEntry", 'String'>
    readonly createdById: FieldRef<"CalendarEntry", 'String'>
    readonly type: FieldRef<"CalendarEntry", 'CalendarEntryType'>
    readonly title: FieldRef<"CalendarEntry", 'String'>
    readonly description: FieldRef<"CalendarEntry", 'String'>
    readonly start: FieldRef<"CalendarEntry", 'DateTime'>
    readonly end: FieldRef<"CalendarEntry", 'DateTime'>
    readonly allDay: FieldRef<"CalendarEntry", 'Boolean'>
    readonly freq: FieldRef<"CalendarEntry", 'RecurrenceFreq'>
    readonly interval: FieldRef<"CalendarEntry", 'Int'>
    readonly until: FieldRef<"CalendarEntry", 'DateTime'>
    readonly count: FieldRef<"CalendarEntry", 'Int'>
    readonly createdAt: FieldRef<"CalendarEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEntry findUnique
   */
  export type CalendarEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Filter, which CalendarEntry to fetch.
     */
    where: CalendarEntryWhereUniqueInput
  }

  /**
   * CalendarEntry findUniqueOrThrow
   */
  export type CalendarEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Filter, which CalendarEntry to fetch.
     */
    where: CalendarEntryWhereUniqueInput
  }

  /**
   * CalendarEntry findFirst
   */
  export type CalendarEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Filter, which CalendarEntry to fetch.
     */
    where?: CalendarEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEntries to fetch.
     */
    orderBy?: CalendarEntryOrderByWithRelationInput | CalendarEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEntries.
     */
    cursor?: CalendarEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEntries.
     */
    distinct?: CalendarEntryScalarFieldEnum | CalendarEntryScalarFieldEnum[]
  }

  /**
   * CalendarEntry findFirstOrThrow
   */
  export type CalendarEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Filter, which CalendarEntry to fetch.
     */
    where?: CalendarEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEntries to fetch.
     */
    orderBy?: CalendarEntryOrderByWithRelationInput | CalendarEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEntries.
     */
    cursor?: CalendarEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEntries.
     */
    distinct?: CalendarEntryScalarFieldEnum | CalendarEntryScalarFieldEnum[]
  }

  /**
   * CalendarEntry findMany
   */
  export type CalendarEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Filter, which CalendarEntries to fetch.
     */
    where?: CalendarEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEntries to fetch.
     */
    orderBy?: CalendarEntryOrderByWithRelationInput | CalendarEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEntries.
     */
    cursor?: CalendarEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEntries.
     */
    skip?: number
    distinct?: CalendarEntryScalarFieldEnum | CalendarEntryScalarFieldEnum[]
  }

  /**
   * CalendarEntry create
   */
  export type CalendarEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * The data needed to create a CalendarEntry.
     */
    data: XOR<CalendarEntryCreateInput, CalendarEntryUncheckedCreateInput>
  }

  /**
   * CalendarEntry createMany
   */
  export type CalendarEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEntries.
     */
    data: CalendarEntryCreateManyInput | CalendarEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEntry createManyAndReturn
   */
  export type CalendarEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * The data used to create many CalendarEntries.
     */
    data: CalendarEntryCreateManyInput | CalendarEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEntry update
   */
  export type CalendarEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * The data needed to update a CalendarEntry.
     */
    data: XOR<CalendarEntryUpdateInput, CalendarEntryUncheckedUpdateInput>
    /**
     * Choose, which CalendarEntry to update.
     */
    where: CalendarEntryWhereUniqueInput
  }

  /**
   * CalendarEntry updateMany
   */
  export type CalendarEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEntries.
     */
    data: XOR<CalendarEntryUpdateManyMutationInput, CalendarEntryUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEntries to update
     */
    where?: CalendarEntryWhereInput
    /**
     * Limit how many CalendarEntries to update.
     */
    limit?: number
  }

  /**
   * CalendarEntry updateManyAndReturn
   */
  export type CalendarEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * The data used to update CalendarEntries.
     */
    data: XOR<CalendarEntryUpdateManyMutationInput, CalendarEntryUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEntries to update
     */
    where?: CalendarEntryWhereInput
    /**
     * Limit how many CalendarEntries to update.
     */
    limit?: number
  }

  /**
   * CalendarEntry upsert
   */
  export type CalendarEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * The filter to search for the CalendarEntry to update in case it exists.
     */
    where: CalendarEntryWhereUniqueInput
    /**
     * In case the CalendarEntry found by the `where` argument doesn't exist, create a new CalendarEntry with this data.
     */
    create: XOR<CalendarEntryCreateInput, CalendarEntryUncheckedCreateInput>
    /**
     * In case the CalendarEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEntryUpdateInput, CalendarEntryUncheckedUpdateInput>
  }

  /**
   * CalendarEntry delete
   */
  export type CalendarEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Filter which CalendarEntry to delete.
     */
    where: CalendarEntryWhereUniqueInput
  }

  /**
   * CalendarEntry deleteMany
   */
  export type CalendarEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEntries to delete
     */
    where?: CalendarEntryWhereInput
    /**
     * Limit how many CalendarEntries to delete.
     */
    limit?: number
  }

  /**
   * CalendarEntry without action
   */
  export type CalendarEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    recipientId: string | null
    actorId: string | null
    taskId: string | null
    occurrenceId: string | null
    type: string | null
    title: string | null
    body: string | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    recipientId: string | null
    actorId: string | null
    taskId: string | null
    occurrenceId: string | null
    type: string | null
    title: string | null
    body: string | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    recipientId: number
    actorId: number
    taskId: number
    occurrenceId: number
    type: number
    title: number
    body: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    recipientId?: true
    actorId?: true
    taskId?: true
    occurrenceId?: true
    type?: true
    title?: true
    body?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    recipientId?: true
    actorId?: true
    taskId?: true
    occurrenceId?: true
    type?: true
    title?: true
    body?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    recipientId?: true
    actorId?: true
    taskId?: true
    occurrenceId?: true
    type?: true
    title?: true
    body?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    recipientId: string
    actorId: string | null
    taskId: string | null
    occurrenceId: string | null
    type: string
    title: string
    body: string
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    actorId?: boolean
    taskId?: boolean
    occurrenceId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    actorId?: boolean
    taskId?: boolean
    occurrenceId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    actorId?: boolean
    taskId?: boolean
    occurrenceId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    recipientId?: boolean
    actorId?: boolean
    taskId?: boolean
    occurrenceId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipientId" | "actorId" | "taskId" | "occurrenceId" | "type" | "title" | "body" | "readAt" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipientId: string
      actorId: string | null
      taskId: string | null
      occurrenceId: string | null
      type: string
      title: string
      body: string
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly actorId: FieldRef<"Notification", 'String'>
    readonly taskId: FieldRef<"Notification", 'String'>
    readonly occurrenceId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    isGroup: boolean | null
    title: string | null
    createdById: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    isGroup: boolean | null
    title: string | null
    createdById: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    isGroup: number
    title: number
    createdById: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    isGroup?: true
    title?: true
    createdById?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    isGroup?: true
    title?: true
    createdById?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    isGroup?: true
    title?: true
    createdById?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    isGroup: boolean
    title: string | null
    createdById: string
    updatedAt: Date
    createdAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isGroup?: boolean
    title?: boolean
    createdById?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    members?: boolean | Conversation$membersArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isGroup?: boolean
    title?: boolean
    createdById?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isGroup?: boolean
    title?: boolean
    createdById?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    isGroup?: boolean
    title?: boolean
    createdById?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isGroup" | "title" | "createdById" | "updatedAt" | "createdAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Conversation$membersArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      members: Prisma.$ConversationMemberPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isGroup: boolean
      title: string | null
      createdById: string
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Conversation$membersArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly isGroup: FieldRef<"Conversation", 'Boolean'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly createdById: FieldRef<"Conversation", 'String'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.members
   */
  export type Conversation$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberInclude<ExtArgs> | null
    where?: ConversationMemberWhereInput
    orderBy?: ConversationMemberOrderByWithRelationInput | ConversationMemberOrderByWithRelationInput[]
    cursor?: ConversationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationMemberScalarFieldEnum | ConversationMemberScalarFieldEnum[]
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model ConversationMember
   */

  export type AggregateConversationMember = {
    _count: ConversationMemberCountAggregateOutputType | null
    _min: ConversationMemberMinAggregateOutputType | null
    _max: ConversationMemberMaxAggregateOutputType | null
  }

  export type ConversationMemberMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    role: string | null
  }

  export type ConversationMemberMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    role: string | null
  }

  export type ConversationMemberCountAggregateOutputType = {
    id: number
    conversationId: number
    userId: number
    role: number
    _all: number
  }


  export type ConversationMemberMinAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    role?: true
  }

  export type ConversationMemberMaxAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    role?: true
  }

  export type ConversationMemberCountAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    role?: true
    _all?: true
  }

  export type ConversationMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationMember to aggregate.
     */
    where?: ConversationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMembers to fetch.
     */
    orderBy?: ConversationMemberOrderByWithRelationInput | ConversationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationMembers
    **/
    _count?: true | ConversationMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMemberMaxAggregateInputType
  }

  export type GetConversationMemberAggregateType<T extends ConversationMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationMember[P]>
      : GetScalarType<T[P], AggregateConversationMember[P]>
  }




  export type ConversationMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationMemberWhereInput
    orderBy?: ConversationMemberOrderByWithAggregationInput | ConversationMemberOrderByWithAggregationInput[]
    by: ConversationMemberScalarFieldEnum[] | ConversationMemberScalarFieldEnum
    having?: ConversationMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationMemberCountAggregateInputType | true
    _min?: ConversationMemberMinAggregateInputType
    _max?: ConversationMemberMaxAggregateInputType
  }

  export type ConversationMemberGroupByOutputType = {
    id: string
    conversationId: string
    userId: string
    role: string | null
    _count: ConversationMemberCountAggregateOutputType | null
    _min: ConversationMemberMinAggregateOutputType | null
    _max: ConversationMemberMaxAggregateOutputType | null
  }

  type GetConversationMemberGroupByPayload<T extends ConversationMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationMemberGroupByOutputType[P]>
        }
      >
    >


  export type ConversationMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    role?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | DirectoryUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMember"]>

  export type ConversationMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    role?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | DirectoryUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMember"]>

  export type ConversationMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    role?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | DirectoryUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMember"]>

  export type ConversationMemberSelectScalar = {
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    role?: boolean
  }

  export type ConversationMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "userId" | "role", ExtArgs["result"]["conversationMember"]>
  export type ConversationMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | DirectoryUserDefaultArgs<ExtArgs>
  }
  export type ConversationMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | DirectoryUserDefaultArgs<ExtArgs>
  }
  export type ConversationMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | DirectoryUserDefaultArgs<ExtArgs>
  }

  export type $ConversationMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationMember"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      user: Prisma.$DirectoryUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      userId: string
      role: string | null
    }, ExtArgs["result"]["conversationMember"]>
    composites: {}
  }

  type ConversationMemberGetPayload<S extends boolean | null | undefined | ConversationMemberDefaultArgs> = $Result.GetResult<Prisma.$ConversationMemberPayload, S>

  type ConversationMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationMemberCountAggregateInputType | true
    }

  export interface ConversationMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationMember'], meta: { name: 'ConversationMember' } }
    /**
     * Find zero or one ConversationMember that matches the filter.
     * @param {ConversationMemberFindUniqueArgs} args - Arguments to find a ConversationMember
     * @example
     * // Get one ConversationMember
     * const conversationMember = await prisma.conversationMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationMemberFindUniqueArgs>(args: SelectSubset<T, ConversationMemberFindUniqueArgs<ExtArgs>>): Prisma__ConversationMemberClient<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationMemberFindUniqueOrThrowArgs} args - Arguments to find a ConversationMember
     * @example
     * // Get one ConversationMember
     * const conversationMember = await prisma.conversationMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationMemberClient<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemberFindFirstArgs} args - Arguments to find a ConversationMember
     * @example
     * // Get one ConversationMember
     * const conversationMember = await prisma.conversationMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationMemberFindFirstArgs>(args?: SelectSubset<T, ConversationMemberFindFirstArgs<ExtArgs>>): Prisma__ConversationMemberClient<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemberFindFirstOrThrowArgs} args - Arguments to find a ConversationMember
     * @example
     * // Get one ConversationMember
     * const conversationMember = await prisma.conversationMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationMemberClient<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationMembers
     * const conversationMembers = await prisma.conversationMember.findMany()
     * 
     * // Get first 10 ConversationMembers
     * const conversationMembers = await prisma.conversationMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationMemberWithIdOnly = await prisma.conversationMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationMemberFindManyArgs>(args?: SelectSubset<T, ConversationMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationMember.
     * @param {ConversationMemberCreateArgs} args - Arguments to create a ConversationMember.
     * @example
     * // Create one ConversationMember
     * const ConversationMember = await prisma.conversationMember.create({
     *   data: {
     *     // ... data to create a ConversationMember
     *   }
     * })
     * 
     */
    create<T extends ConversationMemberCreateArgs>(args: SelectSubset<T, ConversationMemberCreateArgs<ExtArgs>>): Prisma__ConversationMemberClient<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationMembers.
     * @param {ConversationMemberCreateManyArgs} args - Arguments to create many ConversationMembers.
     * @example
     * // Create many ConversationMembers
     * const conversationMember = await prisma.conversationMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationMemberCreateManyArgs>(args?: SelectSubset<T, ConversationMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationMembers and returns the data saved in the database.
     * @param {ConversationMemberCreateManyAndReturnArgs} args - Arguments to create many ConversationMembers.
     * @example
     * // Create many ConversationMembers
     * const conversationMember = await prisma.conversationMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationMembers and only return the `id`
     * const conversationMemberWithIdOnly = await prisma.conversationMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationMember.
     * @param {ConversationMemberDeleteArgs} args - Arguments to delete one ConversationMember.
     * @example
     * // Delete one ConversationMember
     * const ConversationMember = await prisma.conversationMember.delete({
     *   where: {
     *     // ... filter to delete one ConversationMember
     *   }
     * })
     * 
     */
    delete<T extends ConversationMemberDeleteArgs>(args: SelectSubset<T, ConversationMemberDeleteArgs<ExtArgs>>): Prisma__ConversationMemberClient<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationMember.
     * @param {ConversationMemberUpdateArgs} args - Arguments to update one ConversationMember.
     * @example
     * // Update one ConversationMember
     * const conversationMember = await prisma.conversationMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationMemberUpdateArgs>(args: SelectSubset<T, ConversationMemberUpdateArgs<ExtArgs>>): Prisma__ConversationMemberClient<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationMembers.
     * @param {ConversationMemberDeleteManyArgs} args - Arguments to filter ConversationMembers to delete.
     * @example
     * // Delete a few ConversationMembers
     * const { count } = await prisma.conversationMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationMemberDeleteManyArgs>(args?: SelectSubset<T, ConversationMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationMembers
     * const conversationMember = await prisma.conversationMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationMemberUpdateManyArgs>(args: SelectSubset<T, ConversationMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationMembers and returns the data updated in the database.
     * @param {ConversationMemberUpdateManyAndReturnArgs} args - Arguments to update many ConversationMembers.
     * @example
     * // Update many ConversationMembers
     * const conversationMember = await prisma.conversationMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationMembers and only return the `id`
     * const conversationMemberWithIdOnly = await prisma.conversationMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationMember.
     * @param {ConversationMemberUpsertArgs} args - Arguments to update or create a ConversationMember.
     * @example
     * // Update or create a ConversationMember
     * const conversationMember = await prisma.conversationMember.upsert({
     *   create: {
     *     // ... data to create a ConversationMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationMember we want to update
     *   }
     * })
     */
    upsert<T extends ConversationMemberUpsertArgs>(args: SelectSubset<T, ConversationMemberUpsertArgs<ExtArgs>>): Prisma__ConversationMemberClient<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemberCountArgs} args - Arguments to filter ConversationMembers to count.
     * @example
     * // Count the number of ConversationMembers
     * const count = await prisma.conversationMember.count({
     *   where: {
     *     // ... the filter for the ConversationMembers we want to count
     *   }
     * })
    **/
    count<T extends ConversationMemberCountArgs>(
      args?: Subset<T, ConversationMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationMemberAggregateArgs>(args: Subset<T, ConversationMemberAggregateArgs>): Prisma.PrismaPromise<GetConversationMemberAggregateType<T>>

    /**
     * Group by ConversationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationMemberGroupByArgs['orderBy'] }
        : { orderBy?: ConversationMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationMember model
   */
  readonly fields: ConversationMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends DirectoryUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DirectoryUserDefaultArgs<ExtArgs>>): Prisma__DirectoryUserClient<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationMember model
   */
  interface ConversationMemberFieldRefs {
    readonly id: FieldRef<"ConversationMember", 'String'>
    readonly conversationId: FieldRef<"ConversationMember", 'String'>
    readonly userId: FieldRef<"ConversationMember", 'String'>
    readonly role: FieldRef<"ConversationMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConversationMember findUnique
   */
  export type ConversationMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMember to fetch.
     */
    where: ConversationMemberWhereUniqueInput
  }

  /**
   * ConversationMember findUniqueOrThrow
   */
  export type ConversationMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMember to fetch.
     */
    where: ConversationMemberWhereUniqueInput
  }

  /**
   * ConversationMember findFirst
   */
  export type ConversationMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMember to fetch.
     */
    where?: ConversationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMembers to fetch.
     */
    orderBy?: ConversationMemberOrderByWithRelationInput | ConversationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationMembers.
     */
    cursor?: ConversationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationMembers.
     */
    distinct?: ConversationMemberScalarFieldEnum | ConversationMemberScalarFieldEnum[]
  }

  /**
   * ConversationMember findFirstOrThrow
   */
  export type ConversationMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMember to fetch.
     */
    where?: ConversationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMembers to fetch.
     */
    orderBy?: ConversationMemberOrderByWithRelationInput | ConversationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationMembers.
     */
    cursor?: ConversationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationMembers.
     */
    distinct?: ConversationMemberScalarFieldEnum | ConversationMemberScalarFieldEnum[]
  }

  /**
   * ConversationMember findMany
   */
  export type ConversationMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMembers to fetch.
     */
    where?: ConversationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMembers to fetch.
     */
    orderBy?: ConversationMemberOrderByWithRelationInput | ConversationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationMembers.
     */
    cursor?: ConversationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMembers.
     */
    skip?: number
    distinct?: ConversationMemberScalarFieldEnum | ConversationMemberScalarFieldEnum[]
  }

  /**
   * ConversationMember create
   */
  export type ConversationMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationMember.
     */
    data: XOR<ConversationMemberCreateInput, ConversationMemberUncheckedCreateInput>
  }

  /**
   * ConversationMember createMany
   */
  export type ConversationMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationMembers.
     */
    data: ConversationMemberCreateManyInput | ConversationMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationMember createManyAndReturn
   */
  export type ConversationMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationMembers.
     */
    data: ConversationMemberCreateManyInput | ConversationMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationMember update
   */
  export type ConversationMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationMember.
     */
    data: XOR<ConversationMemberUpdateInput, ConversationMemberUncheckedUpdateInput>
    /**
     * Choose, which ConversationMember to update.
     */
    where: ConversationMemberWhereUniqueInput
  }

  /**
   * ConversationMember updateMany
   */
  export type ConversationMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationMembers.
     */
    data: XOR<ConversationMemberUpdateManyMutationInput, ConversationMemberUncheckedUpdateManyInput>
    /**
     * Filter which ConversationMembers to update
     */
    where?: ConversationMemberWhereInput
    /**
     * Limit how many ConversationMembers to update.
     */
    limit?: number
  }

  /**
   * ConversationMember updateManyAndReturn
   */
  export type ConversationMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * The data used to update ConversationMembers.
     */
    data: XOR<ConversationMemberUpdateManyMutationInput, ConversationMemberUncheckedUpdateManyInput>
    /**
     * Filter which ConversationMembers to update
     */
    where?: ConversationMemberWhereInput
    /**
     * Limit how many ConversationMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationMember upsert
   */
  export type ConversationMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationMember to update in case it exists.
     */
    where: ConversationMemberWhereUniqueInput
    /**
     * In case the ConversationMember found by the `where` argument doesn't exist, create a new ConversationMember with this data.
     */
    create: XOR<ConversationMemberCreateInput, ConversationMemberUncheckedCreateInput>
    /**
     * In case the ConversationMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationMemberUpdateInput, ConversationMemberUncheckedUpdateInput>
  }

  /**
   * ConversationMember delete
   */
  export type ConversationMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberInclude<ExtArgs> | null
    /**
     * Filter which ConversationMember to delete.
     */
    where: ConversationMemberWhereUniqueInput
  }

  /**
   * ConversationMember deleteMany
   */
  export type ConversationMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationMembers to delete
     */
    where?: ConversationMemberWhereInput
    /**
     * Limit how many ConversationMembers to delete.
     */
    limit?: number
  }

  /**
   * ConversationMember without action
   */
  export type ConversationMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    body: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    body: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    body: number
    attachments: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    body?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    body?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    body?: true
    attachments?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    body: string | null
    attachments: JsonValue | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    body?: boolean
    attachments?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | DirectoryUserDefaultArgs<ExtArgs>
    reads?: boolean | Message$readsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    body?: boolean
    attachments?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | DirectoryUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    body?: boolean
    attachments?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | DirectoryUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    body?: boolean
    attachments?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "senderId" | "body" | "attachments" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | DirectoryUserDefaultArgs<ExtArgs>
    reads?: boolean | Message$readsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | DirectoryUserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | DirectoryUserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$DirectoryUserPayload<ExtArgs>
      reads: Prisma.$MessageReadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      body: string | null
      attachments: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends DirectoryUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DirectoryUserDefaultArgs<ExtArgs>>): Prisma__DirectoryUserClient<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reads<T extends Message$readsArgs<ExtArgs> = {}>(args?: Subset<T, Message$readsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly body: FieldRef<"Message", 'String'>
    readonly attachments: FieldRef<"Message", 'Json'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.reads
   */
  export type Message$readsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    where?: MessageReadWhereInput
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    cursor?: MessageReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageRead
   */

  export type AggregateMessageRead = {
    _count: MessageReadCountAggregateOutputType | null
    _min: MessageReadMinAggregateOutputType | null
    _max: MessageReadMaxAggregateOutputType | null
  }

  export type MessageReadMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type MessageReadMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type MessageReadCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    readAt: number
    _all: number
  }


  export type MessageReadMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type MessageReadMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type MessageReadCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
    _all?: true
  }

  export type MessageReadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageRead to aggregate.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageReads
    **/
    _count?: true | MessageReadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageReadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageReadMaxAggregateInputType
  }

  export type GetMessageReadAggregateType<T extends MessageReadAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageRead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageRead[P]>
      : GetScalarType<T[P], AggregateMessageRead[P]>
  }




  export type MessageReadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadWhereInput
    orderBy?: MessageReadOrderByWithAggregationInput | MessageReadOrderByWithAggregationInput[]
    by: MessageReadScalarFieldEnum[] | MessageReadScalarFieldEnum
    having?: MessageReadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageReadCountAggregateInputType | true
    _min?: MessageReadMinAggregateInputType
    _max?: MessageReadMaxAggregateInputType
  }

  export type MessageReadGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    readAt: Date
    _count: MessageReadCountAggregateOutputType | null
    _min: MessageReadMinAggregateOutputType | null
    _max: MessageReadMaxAggregateOutputType | null
  }

  type GetMessageReadGroupByPayload<T extends MessageReadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageReadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageReadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageReadGroupByOutputType[P]>
            : GetScalarType<T[P], MessageReadGroupByOutputType[P]>
        }
      >
    >


  export type MessageReadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRead"]>

  export type MessageReadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRead"]>

  export type MessageReadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRead"]>

  export type MessageReadSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
  }

  export type MessageReadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "userId" | "readAt", ExtArgs["result"]["messageRead"]>
  export type MessageReadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type MessageReadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type MessageReadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $MessageReadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageRead"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      readAt: Date
    }, ExtArgs["result"]["messageRead"]>
    composites: {}
  }

  type MessageReadGetPayload<S extends boolean | null | undefined | MessageReadDefaultArgs> = $Result.GetResult<Prisma.$MessageReadPayload, S>

  type MessageReadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageReadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageReadCountAggregateInputType | true
    }

  export interface MessageReadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageRead'], meta: { name: 'MessageRead' } }
    /**
     * Find zero or one MessageRead that matches the filter.
     * @param {MessageReadFindUniqueArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageReadFindUniqueArgs>(args: SelectSubset<T, MessageReadFindUniqueArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageRead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageReadFindUniqueOrThrowArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageReadFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageReadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageRead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadFindFirstArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageReadFindFirstArgs>(args?: SelectSubset<T, MessageReadFindFirstArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageRead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadFindFirstOrThrowArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageReadFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageReadFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageReads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageReads
     * const messageReads = await prisma.messageRead.findMany()
     * 
     * // Get first 10 MessageReads
     * const messageReads = await prisma.messageRead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageReadWithIdOnly = await prisma.messageRead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageReadFindManyArgs>(args?: SelectSubset<T, MessageReadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageRead.
     * @param {MessageReadCreateArgs} args - Arguments to create a MessageRead.
     * @example
     * // Create one MessageRead
     * const MessageRead = await prisma.messageRead.create({
     *   data: {
     *     // ... data to create a MessageRead
     *   }
     * })
     * 
     */
    create<T extends MessageReadCreateArgs>(args: SelectSubset<T, MessageReadCreateArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageReads.
     * @param {MessageReadCreateManyArgs} args - Arguments to create many MessageReads.
     * @example
     * // Create many MessageReads
     * const messageRead = await prisma.messageRead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageReadCreateManyArgs>(args?: SelectSubset<T, MessageReadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageReads and returns the data saved in the database.
     * @param {MessageReadCreateManyAndReturnArgs} args - Arguments to create many MessageReads.
     * @example
     * // Create many MessageReads
     * const messageRead = await prisma.messageRead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageReads and only return the `id`
     * const messageReadWithIdOnly = await prisma.messageRead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageReadCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageReadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageRead.
     * @param {MessageReadDeleteArgs} args - Arguments to delete one MessageRead.
     * @example
     * // Delete one MessageRead
     * const MessageRead = await prisma.messageRead.delete({
     *   where: {
     *     // ... filter to delete one MessageRead
     *   }
     * })
     * 
     */
    delete<T extends MessageReadDeleteArgs>(args: SelectSubset<T, MessageReadDeleteArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageRead.
     * @param {MessageReadUpdateArgs} args - Arguments to update one MessageRead.
     * @example
     * // Update one MessageRead
     * const messageRead = await prisma.messageRead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageReadUpdateArgs>(args: SelectSubset<T, MessageReadUpdateArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageReads.
     * @param {MessageReadDeleteManyArgs} args - Arguments to filter MessageReads to delete.
     * @example
     * // Delete a few MessageReads
     * const { count } = await prisma.messageRead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageReadDeleteManyArgs>(args?: SelectSubset<T, MessageReadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageReads
     * const messageRead = await prisma.messageRead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageReadUpdateManyArgs>(args: SelectSubset<T, MessageReadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReads and returns the data updated in the database.
     * @param {MessageReadUpdateManyAndReturnArgs} args - Arguments to update many MessageReads.
     * @example
     * // Update many MessageReads
     * const messageRead = await prisma.messageRead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageReads and only return the `id`
     * const messageReadWithIdOnly = await prisma.messageRead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageReadUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageReadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageRead.
     * @param {MessageReadUpsertArgs} args - Arguments to update or create a MessageRead.
     * @example
     * // Update or create a MessageRead
     * const messageRead = await prisma.messageRead.upsert({
     *   create: {
     *     // ... data to create a MessageRead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageRead we want to update
     *   }
     * })
     */
    upsert<T extends MessageReadUpsertArgs>(args: SelectSubset<T, MessageReadUpsertArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadCountArgs} args - Arguments to filter MessageReads to count.
     * @example
     * // Count the number of MessageReads
     * const count = await prisma.messageRead.count({
     *   where: {
     *     // ... the filter for the MessageReads we want to count
     *   }
     * })
    **/
    count<T extends MessageReadCountArgs>(
      args?: Subset<T, MessageReadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageReadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageReadAggregateArgs>(args: Subset<T, MessageReadAggregateArgs>): Prisma.PrismaPromise<GetMessageReadAggregateType<T>>

    /**
     * Group by MessageRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageReadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageReadGroupByArgs['orderBy'] }
        : { orderBy?: MessageReadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageReadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageReadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageRead model
   */
  readonly fields: MessageReadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageRead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageReadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageRead model
   */
  interface MessageReadFieldRefs {
    readonly id: FieldRef<"MessageRead", 'String'>
    readonly messageId: FieldRef<"MessageRead", 'String'>
    readonly userId: FieldRef<"MessageRead", 'String'>
    readonly readAt: FieldRef<"MessageRead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageRead findUnique
   */
  export type MessageReadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead findUniqueOrThrow
   */
  export type MessageReadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead findFirst
   */
  export type MessageReadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReads.
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReads.
     */
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * MessageRead findFirstOrThrow
   */
  export type MessageReadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReads.
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReads.
     */
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * MessageRead findMany
   */
  export type MessageReadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageReads to fetch.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageReads.
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * MessageRead create
   */
  export type MessageReadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageRead.
     */
    data: XOR<MessageReadCreateInput, MessageReadUncheckedCreateInput>
  }

  /**
   * MessageRead createMany
   */
  export type MessageReadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageReads.
     */
    data: MessageReadCreateManyInput | MessageReadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageRead createManyAndReturn
   */
  export type MessageReadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * The data used to create many MessageReads.
     */
    data: MessageReadCreateManyInput | MessageReadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageRead update
   */
  export type MessageReadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageRead.
     */
    data: XOR<MessageReadUpdateInput, MessageReadUncheckedUpdateInput>
    /**
     * Choose, which MessageRead to update.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead updateMany
   */
  export type MessageReadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageReads.
     */
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyInput>
    /**
     * Filter which MessageReads to update
     */
    where?: MessageReadWhereInput
    /**
     * Limit how many MessageReads to update.
     */
    limit?: number
  }

  /**
   * MessageRead updateManyAndReturn
   */
  export type MessageReadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * The data used to update MessageReads.
     */
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyInput>
    /**
     * Filter which MessageReads to update
     */
    where?: MessageReadWhereInput
    /**
     * Limit how many MessageReads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageRead upsert
   */
  export type MessageReadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageRead to update in case it exists.
     */
    where: MessageReadWhereUniqueInput
    /**
     * In case the MessageRead found by the `where` argument doesn't exist, create a new MessageRead with this data.
     */
    create: XOR<MessageReadCreateInput, MessageReadUncheckedCreateInput>
    /**
     * In case the MessageRead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageReadUpdateInput, MessageReadUncheckedUpdateInput>
  }

  /**
   * MessageRead delete
   */
  export type MessageReadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter which MessageRead to delete.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead deleteMany
   */
  export type MessageReadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReads to delete
     */
    where?: MessageReadWhereInput
    /**
     * Limit how many MessageReads to delete.
     */
    limit?: number
  }

  /**
   * MessageRead without action
   */
  export type MessageReadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
  }


  /**
   * Model DirectoryUser
   */

  export type AggregateDirectoryUser = {
    _count: DirectoryUserCountAggregateOutputType | null
    _min: DirectoryUserMinAggregateOutputType | null
    _max: DirectoryUserMaxAggregateOutputType | null
  }

  export type DirectoryUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    avatarUrl: string | null
    lastActiveAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DirectoryUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    avatarUrl: string | null
    lastActiveAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DirectoryUserCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    avatarUrl: number
    lastActiveAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DirectoryUserMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    avatarUrl?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DirectoryUserMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    avatarUrl?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DirectoryUserCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    avatarUrl?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DirectoryUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DirectoryUser to aggregate.
     */
    where?: DirectoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectoryUsers to fetch.
     */
    orderBy?: DirectoryUserOrderByWithRelationInput | DirectoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DirectoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectoryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DirectoryUsers
    **/
    _count?: true | DirectoryUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectoryUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectoryUserMaxAggregateInputType
  }

  export type GetDirectoryUserAggregateType<T extends DirectoryUserAggregateArgs> = {
        [P in keyof T & keyof AggregateDirectoryUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirectoryUser[P]>
      : GetScalarType<T[P], AggregateDirectoryUser[P]>
  }




  export type DirectoryUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectoryUserWhereInput
    orderBy?: DirectoryUserOrderByWithAggregationInput | DirectoryUserOrderByWithAggregationInput[]
    by: DirectoryUserScalarFieldEnum[] | DirectoryUserScalarFieldEnum
    having?: DirectoryUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectoryUserCountAggregateInputType | true
    _min?: DirectoryUserMinAggregateInputType
    _max?: DirectoryUserMaxAggregateInputType
  }

  export type DirectoryUserGroupByOutputType = {
    id: string
    userId: string
    name: string
    avatarUrl: string | null
    lastActiveAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DirectoryUserCountAggregateOutputType | null
    _min: DirectoryUserMinAggregateOutputType | null
    _max: DirectoryUserMaxAggregateOutputType | null
  }

  type GetDirectoryUserGroupByPayload<T extends DirectoryUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DirectoryUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectoryUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectoryUserGroupByOutputType[P]>
            : GetScalarType<T[P], DirectoryUserGroupByOutputType[P]>
        }
      >
    >


  export type DirectoryUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    avatarUrl?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | DirectoryUser$membersArgs<ExtArgs>
    messagesSent?: boolean | DirectoryUser$messagesSentArgs<ExtArgs>
    _count?: boolean | DirectoryUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["directoryUser"]>

  export type DirectoryUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    avatarUrl?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["directoryUser"]>

  export type DirectoryUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    avatarUrl?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["directoryUser"]>

  export type DirectoryUserSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    avatarUrl?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DirectoryUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "avatarUrl" | "lastActiveAt" | "createdAt" | "updatedAt", ExtArgs["result"]["directoryUser"]>
  export type DirectoryUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | DirectoryUser$membersArgs<ExtArgs>
    messagesSent?: boolean | DirectoryUser$messagesSentArgs<ExtArgs>
    _count?: boolean | DirectoryUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DirectoryUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DirectoryUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DirectoryUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DirectoryUser"
    objects: {
      members: Prisma.$ConversationMemberPayload<ExtArgs>[]
      messagesSent: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      avatarUrl: string | null
      lastActiveAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["directoryUser"]>
    composites: {}
  }

  type DirectoryUserGetPayload<S extends boolean | null | undefined | DirectoryUserDefaultArgs> = $Result.GetResult<Prisma.$DirectoryUserPayload, S>

  type DirectoryUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DirectoryUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DirectoryUserCountAggregateInputType | true
    }

  export interface DirectoryUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DirectoryUser'], meta: { name: 'DirectoryUser' } }
    /**
     * Find zero or one DirectoryUser that matches the filter.
     * @param {DirectoryUserFindUniqueArgs} args - Arguments to find a DirectoryUser
     * @example
     * // Get one DirectoryUser
     * const directoryUser = await prisma.directoryUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DirectoryUserFindUniqueArgs>(args: SelectSubset<T, DirectoryUserFindUniqueArgs<ExtArgs>>): Prisma__DirectoryUserClient<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DirectoryUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DirectoryUserFindUniqueOrThrowArgs} args - Arguments to find a DirectoryUser
     * @example
     * // Get one DirectoryUser
     * const directoryUser = await prisma.directoryUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DirectoryUserFindUniqueOrThrowArgs>(args: SelectSubset<T, DirectoryUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DirectoryUserClient<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DirectoryUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryUserFindFirstArgs} args - Arguments to find a DirectoryUser
     * @example
     * // Get one DirectoryUser
     * const directoryUser = await prisma.directoryUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DirectoryUserFindFirstArgs>(args?: SelectSubset<T, DirectoryUserFindFirstArgs<ExtArgs>>): Prisma__DirectoryUserClient<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DirectoryUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryUserFindFirstOrThrowArgs} args - Arguments to find a DirectoryUser
     * @example
     * // Get one DirectoryUser
     * const directoryUser = await prisma.directoryUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DirectoryUserFindFirstOrThrowArgs>(args?: SelectSubset<T, DirectoryUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__DirectoryUserClient<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DirectoryUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DirectoryUsers
     * const directoryUsers = await prisma.directoryUser.findMany()
     * 
     * // Get first 10 DirectoryUsers
     * const directoryUsers = await prisma.directoryUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directoryUserWithIdOnly = await prisma.directoryUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DirectoryUserFindManyArgs>(args?: SelectSubset<T, DirectoryUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DirectoryUser.
     * @param {DirectoryUserCreateArgs} args - Arguments to create a DirectoryUser.
     * @example
     * // Create one DirectoryUser
     * const DirectoryUser = await prisma.directoryUser.create({
     *   data: {
     *     // ... data to create a DirectoryUser
     *   }
     * })
     * 
     */
    create<T extends DirectoryUserCreateArgs>(args: SelectSubset<T, DirectoryUserCreateArgs<ExtArgs>>): Prisma__DirectoryUserClient<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DirectoryUsers.
     * @param {DirectoryUserCreateManyArgs} args - Arguments to create many DirectoryUsers.
     * @example
     * // Create many DirectoryUsers
     * const directoryUser = await prisma.directoryUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DirectoryUserCreateManyArgs>(args?: SelectSubset<T, DirectoryUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DirectoryUsers and returns the data saved in the database.
     * @param {DirectoryUserCreateManyAndReturnArgs} args - Arguments to create many DirectoryUsers.
     * @example
     * // Create many DirectoryUsers
     * const directoryUser = await prisma.directoryUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DirectoryUsers and only return the `id`
     * const directoryUserWithIdOnly = await prisma.directoryUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DirectoryUserCreateManyAndReturnArgs>(args?: SelectSubset<T, DirectoryUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DirectoryUser.
     * @param {DirectoryUserDeleteArgs} args - Arguments to delete one DirectoryUser.
     * @example
     * // Delete one DirectoryUser
     * const DirectoryUser = await prisma.directoryUser.delete({
     *   where: {
     *     // ... filter to delete one DirectoryUser
     *   }
     * })
     * 
     */
    delete<T extends DirectoryUserDeleteArgs>(args: SelectSubset<T, DirectoryUserDeleteArgs<ExtArgs>>): Prisma__DirectoryUserClient<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DirectoryUser.
     * @param {DirectoryUserUpdateArgs} args - Arguments to update one DirectoryUser.
     * @example
     * // Update one DirectoryUser
     * const directoryUser = await prisma.directoryUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DirectoryUserUpdateArgs>(args: SelectSubset<T, DirectoryUserUpdateArgs<ExtArgs>>): Prisma__DirectoryUserClient<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DirectoryUsers.
     * @param {DirectoryUserDeleteManyArgs} args - Arguments to filter DirectoryUsers to delete.
     * @example
     * // Delete a few DirectoryUsers
     * const { count } = await prisma.directoryUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DirectoryUserDeleteManyArgs>(args?: SelectSubset<T, DirectoryUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectoryUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DirectoryUsers
     * const directoryUser = await prisma.directoryUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DirectoryUserUpdateManyArgs>(args: SelectSubset<T, DirectoryUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectoryUsers and returns the data updated in the database.
     * @param {DirectoryUserUpdateManyAndReturnArgs} args - Arguments to update many DirectoryUsers.
     * @example
     * // Update many DirectoryUsers
     * const directoryUser = await prisma.directoryUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DirectoryUsers and only return the `id`
     * const directoryUserWithIdOnly = await prisma.directoryUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DirectoryUserUpdateManyAndReturnArgs>(args: SelectSubset<T, DirectoryUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DirectoryUser.
     * @param {DirectoryUserUpsertArgs} args - Arguments to update or create a DirectoryUser.
     * @example
     * // Update or create a DirectoryUser
     * const directoryUser = await prisma.directoryUser.upsert({
     *   create: {
     *     // ... data to create a DirectoryUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DirectoryUser we want to update
     *   }
     * })
     */
    upsert<T extends DirectoryUserUpsertArgs>(args: SelectSubset<T, DirectoryUserUpsertArgs<ExtArgs>>): Prisma__DirectoryUserClient<$Result.GetResult<Prisma.$DirectoryUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DirectoryUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryUserCountArgs} args - Arguments to filter DirectoryUsers to count.
     * @example
     * // Count the number of DirectoryUsers
     * const count = await prisma.directoryUser.count({
     *   where: {
     *     // ... the filter for the DirectoryUsers we want to count
     *   }
     * })
    **/
    count<T extends DirectoryUserCountArgs>(
      args?: Subset<T, DirectoryUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectoryUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DirectoryUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectoryUserAggregateArgs>(args: Subset<T, DirectoryUserAggregateArgs>): Prisma.PrismaPromise<GetDirectoryUserAggregateType<T>>

    /**
     * Group by DirectoryUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectoryUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirectoryUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirectoryUserGroupByArgs['orderBy'] }
        : { orderBy?: DirectoryUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirectoryUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectoryUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DirectoryUser model
   */
  readonly fields: DirectoryUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DirectoryUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DirectoryUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends DirectoryUser$membersArgs<ExtArgs> = {}>(args?: Subset<T, DirectoryUser$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messagesSent<T extends DirectoryUser$messagesSentArgs<ExtArgs> = {}>(args?: Subset<T, DirectoryUser$messagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DirectoryUser model
   */
  interface DirectoryUserFieldRefs {
    readonly id: FieldRef<"DirectoryUser", 'String'>
    readonly userId: FieldRef<"DirectoryUser", 'String'>
    readonly name: FieldRef<"DirectoryUser", 'String'>
    readonly avatarUrl: FieldRef<"DirectoryUser", 'String'>
    readonly lastActiveAt: FieldRef<"DirectoryUser", 'DateTime'>
    readonly createdAt: FieldRef<"DirectoryUser", 'DateTime'>
    readonly updatedAt: FieldRef<"DirectoryUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DirectoryUser findUnique
   */
  export type DirectoryUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUser
     */
    select?: DirectoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryUser
     */
    omit?: DirectoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectoryUserInclude<ExtArgs> | null
    /**
     * Filter, which DirectoryUser to fetch.
     */
    where: DirectoryUserWhereUniqueInput
  }

  /**
   * DirectoryUser findUniqueOrThrow
   */
  export type DirectoryUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUser
     */
    select?: DirectoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryUser
     */
    omit?: DirectoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectoryUserInclude<ExtArgs> | null
    /**
     * Filter, which DirectoryUser to fetch.
     */
    where: DirectoryUserWhereUniqueInput
  }

  /**
   * DirectoryUser findFirst
   */
  export type DirectoryUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUser
     */
    select?: DirectoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryUser
     */
    omit?: DirectoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectoryUserInclude<ExtArgs> | null
    /**
     * Filter, which DirectoryUser to fetch.
     */
    where?: DirectoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectoryUsers to fetch.
     */
    orderBy?: DirectoryUserOrderByWithRelationInput | DirectoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectoryUsers.
     */
    cursor?: DirectoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectoryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectoryUsers.
     */
    distinct?: DirectoryUserScalarFieldEnum | DirectoryUserScalarFieldEnum[]
  }

  /**
   * DirectoryUser findFirstOrThrow
   */
  export type DirectoryUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUser
     */
    select?: DirectoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryUser
     */
    omit?: DirectoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectoryUserInclude<ExtArgs> | null
    /**
     * Filter, which DirectoryUser to fetch.
     */
    where?: DirectoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectoryUsers to fetch.
     */
    orderBy?: DirectoryUserOrderByWithRelationInput | DirectoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectoryUsers.
     */
    cursor?: DirectoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectoryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectoryUsers.
     */
    distinct?: DirectoryUserScalarFieldEnum | DirectoryUserScalarFieldEnum[]
  }

  /**
   * DirectoryUser findMany
   */
  export type DirectoryUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUser
     */
    select?: DirectoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryUser
     */
    omit?: DirectoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectoryUserInclude<ExtArgs> | null
    /**
     * Filter, which DirectoryUsers to fetch.
     */
    where?: DirectoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectoryUsers to fetch.
     */
    orderBy?: DirectoryUserOrderByWithRelationInput | DirectoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DirectoryUsers.
     */
    cursor?: DirectoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectoryUsers.
     */
    skip?: number
    distinct?: DirectoryUserScalarFieldEnum | DirectoryUserScalarFieldEnum[]
  }

  /**
   * DirectoryUser create
   */
  export type DirectoryUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUser
     */
    select?: DirectoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryUser
     */
    omit?: DirectoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectoryUserInclude<ExtArgs> | null
    /**
     * The data needed to create a DirectoryUser.
     */
    data: XOR<DirectoryUserCreateInput, DirectoryUserUncheckedCreateInput>
  }

  /**
   * DirectoryUser createMany
   */
  export type DirectoryUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DirectoryUsers.
     */
    data: DirectoryUserCreateManyInput | DirectoryUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DirectoryUser createManyAndReturn
   */
  export type DirectoryUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUser
     */
    select?: DirectoryUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryUser
     */
    omit?: DirectoryUserOmit<ExtArgs> | null
    /**
     * The data used to create many DirectoryUsers.
     */
    data: DirectoryUserCreateManyInput | DirectoryUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DirectoryUser update
   */
  export type DirectoryUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUser
     */
    select?: DirectoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryUser
     */
    omit?: DirectoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectoryUserInclude<ExtArgs> | null
    /**
     * The data needed to update a DirectoryUser.
     */
    data: XOR<DirectoryUserUpdateInput, DirectoryUserUncheckedUpdateInput>
    /**
     * Choose, which DirectoryUser to update.
     */
    where: DirectoryUserWhereUniqueInput
  }

  /**
   * DirectoryUser updateMany
   */
  export type DirectoryUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DirectoryUsers.
     */
    data: XOR<DirectoryUserUpdateManyMutationInput, DirectoryUserUncheckedUpdateManyInput>
    /**
     * Filter which DirectoryUsers to update
     */
    where?: DirectoryUserWhereInput
    /**
     * Limit how many DirectoryUsers to update.
     */
    limit?: number
  }

  /**
   * DirectoryUser updateManyAndReturn
   */
  export type DirectoryUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUser
     */
    select?: DirectoryUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryUser
     */
    omit?: DirectoryUserOmit<ExtArgs> | null
    /**
     * The data used to update DirectoryUsers.
     */
    data: XOR<DirectoryUserUpdateManyMutationInput, DirectoryUserUncheckedUpdateManyInput>
    /**
     * Filter which DirectoryUsers to update
     */
    where?: DirectoryUserWhereInput
    /**
     * Limit how many DirectoryUsers to update.
     */
    limit?: number
  }

  /**
   * DirectoryUser upsert
   */
  export type DirectoryUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUser
     */
    select?: DirectoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryUser
     */
    omit?: DirectoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectoryUserInclude<ExtArgs> | null
    /**
     * The filter to search for the DirectoryUser to update in case it exists.
     */
    where: DirectoryUserWhereUniqueInput
    /**
     * In case the DirectoryUser found by the `where` argument doesn't exist, create a new DirectoryUser with this data.
     */
    create: XOR<DirectoryUserCreateInput, DirectoryUserUncheckedCreateInput>
    /**
     * In case the DirectoryUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DirectoryUserUpdateInput, DirectoryUserUncheckedUpdateInput>
  }

  /**
   * DirectoryUser delete
   */
  export type DirectoryUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUser
     */
    select?: DirectoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryUser
     */
    omit?: DirectoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectoryUserInclude<ExtArgs> | null
    /**
     * Filter which DirectoryUser to delete.
     */
    where: DirectoryUserWhereUniqueInput
  }

  /**
   * DirectoryUser deleteMany
   */
  export type DirectoryUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DirectoryUsers to delete
     */
    where?: DirectoryUserWhereInput
    /**
     * Limit how many DirectoryUsers to delete.
     */
    limit?: number
  }

  /**
   * DirectoryUser.members
   */
  export type DirectoryUser$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMember
     */
    select?: ConversationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMember
     */
    omit?: ConversationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMemberInclude<ExtArgs> | null
    where?: ConversationMemberWhereInput
    orderBy?: ConversationMemberOrderByWithRelationInput | ConversationMemberOrderByWithRelationInput[]
    cursor?: ConversationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationMemberScalarFieldEnum | ConversationMemberScalarFieldEnum[]
  }

  /**
   * DirectoryUser.messagesSent
   */
  export type DirectoryUser$messagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * DirectoryUser without action
   */
  export type DirectoryUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectoryUser
     */
    select?: DirectoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectoryUser
     */
    omit?: DirectoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectoryUserInclude<ExtArgs> | null
  }


  /**
   * Model EmailLog
   */

  export type AggregateEmailLog = {
    _count: EmailLogCountAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  export type EmailLogMinAggregateOutputType = {
    id: string | null
    occurrenceId: string | null
    taskId: string | null
    recipient: string | null
    subject: string | null
    body: string | null
    provider: string | null
    providerMessageId: string | null
    status: $Enums.EmailStatus | null
    error: string | null
    createdAt: Date | null
  }

  export type EmailLogMaxAggregateOutputType = {
    id: string | null
    occurrenceId: string | null
    taskId: string | null
    recipient: string | null
    subject: string | null
    body: string | null
    provider: string | null
    providerMessageId: string | null
    status: $Enums.EmailStatus | null
    error: string | null
    createdAt: Date | null
  }

  export type EmailLogCountAggregateOutputType = {
    id: number
    occurrenceId: number
    taskId: number
    recipient: number
    subject: number
    body: number
    provider: number
    providerMessageId: number
    status: number
    error: number
    createdAt: number
    _all: number
  }


  export type EmailLogMinAggregateInputType = {
    id?: true
    occurrenceId?: true
    taskId?: true
    recipient?: true
    subject?: true
    body?: true
    provider?: true
    providerMessageId?: true
    status?: true
    error?: true
    createdAt?: true
  }

  export type EmailLogMaxAggregateInputType = {
    id?: true
    occurrenceId?: true
    taskId?: true
    recipient?: true
    subject?: true
    body?: true
    provider?: true
    providerMessageId?: true
    status?: true
    error?: true
    createdAt?: true
  }

  export type EmailLogCountAggregateInputType = {
    id?: true
    occurrenceId?: true
    taskId?: true
    recipient?: true
    subject?: true
    body?: true
    provider?: true
    providerMessageId?: true
    status?: true
    error?: true
    createdAt?: true
    _all?: true
  }

  export type EmailLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLog to aggregate.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailLogs
    **/
    _count?: true | EmailLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailLogMaxAggregateInputType
  }

  export type GetEmailLogAggregateType<T extends EmailLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailLog[P]>
      : GetScalarType<T[P], AggregateEmailLog[P]>
  }




  export type EmailLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithAggregationInput | EmailLogOrderByWithAggregationInput[]
    by: EmailLogScalarFieldEnum[] | EmailLogScalarFieldEnum
    having?: EmailLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailLogCountAggregateInputType | true
    _min?: EmailLogMinAggregateInputType
    _max?: EmailLogMaxAggregateInputType
  }

  export type EmailLogGroupByOutputType = {
    id: string
    occurrenceId: string | null
    taskId: string | null
    recipient: string
    subject: string | null
    body: string | null
    provider: string | null
    providerMessageId: string | null
    status: $Enums.EmailStatus
    error: string | null
    createdAt: Date
    _count: EmailLogCountAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  type GetEmailLogGroupByPayload<T extends EmailLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
        }
      >
    >


  export type EmailLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    occurrenceId?: boolean
    taskId?: boolean
    recipient?: boolean
    subject?: boolean
    body?: boolean
    provider?: boolean
    providerMessageId?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
    occurrence?: boolean | EmailLog$occurrenceArgs<ExtArgs>
    task?: boolean | EmailLog$taskArgs<ExtArgs>
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    occurrenceId?: boolean
    taskId?: boolean
    recipient?: boolean
    subject?: boolean
    body?: boolean
    provider?: boolean
    providerMessageId?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
    occurrence?: boolean | EmailLog$occurrenceArgs<ExtArgs>
    task?: boolean | EmailLog$taskArgs<ExtArgs>
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    occurrenceId?: boolean
    taskId?: boolean
    recipient?: boolean
    subject?: boolean
    body?: boolean
    provider?: boolean
    providerMessageId?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
    occurrence?: boolean | EmailLog$occurrenceArgs<ExtArgs>
    task?: boolean | EmailLog$taskArgs<ExtArgs>
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectScalar = {
    id?: boolean
    occurrenceId?: boolean
    taskId?: boolean
    recipient?: boolean
    subject?: boolean
    body?: boolean
    provider?: boolean
    providerMessageId?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
  }

  export type EmailLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "occurrenceId" | "taskId" | "recipient" | "subject" | "body" | "provider" | "providerMessageId" | "status" | "error" | "createdAt", ExtArgs["result"]["emailLog"]>
  export type EmailLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occurrence?: boolean | EmailLog$occurrenceArgs<ExtArgs>
    task?: boolean | EmailLog$taskArgs<ExtArgs>
  }
  export type EmailLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occurrence?: boolean | EmailLog$occurrenceArgs<ExtArgs>
    task?: boolean | EmailLog$taskArgs<ExtArgs>
  }
  export type EmailLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occurrence?: boolean | EmailLog$occurrenceArgs<ExtArgs>
    task?: boolean | EmailLog$taskArgs<ExtArgs>
  }

  export type $EmailLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailLog"
    objects: {
      occurrence: Prisma.$TaskOccurrencePayload<ExtArgs> | null
      task: Prisma.$TaskPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      occurrenceId: string | null
      taskId: string | null
      recipient: string
      subject: string | null
      body: string | null
      provider: string | null
      providerMessageId: string | null
      status: $Enums.EmailStatus
      error: string | null
      createdAt: Date
    }, ExtArgs["result"]["emailLog"]>
    composites: {}
  }

  type EmailLogGetPayload<S extends boolean | null | undefined | EmailLogDefaultArgs> = $Result.GetResult<Prisma.$EmailLogPayload, S>

  type EmailLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailLogCountAggregateInputType | true
    }

  export interface EmailLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailLog'], meta: { name: 'EmailLog' } }
    /**
     * Find zero or one EmailLog that matches the filter.
     * @param {EmailLogFindUniqueArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailLogFindUniqueArgs>(args: SelectSubset<T, EmailLogFindUniqueArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailLogFindUniqueOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailLogFindFirstArgs>(args?: SelectSubset<T, EmailLogFindFirstArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailLogs
     * const emailLogs = await prisma.emailLog.findMany()
     * 
     * // Get first 10 EmailLogs
     * const emailLogs = await prisma.emailLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailLogFindManyArgs>(args?: SelectSubset<T, EmailLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailLog.
     * @param {EmailLogCreateArgs} args - Arguments to create a EmailLog.
     * @example
     * // Create one EmailLog
     * const EmailLog = await prisma.emailLog.create({
     *   data: {
     *     // ... data to create a EmailLog
     *   }
     * })
     * 
     */
    create<T extends EmailLogCreateArgs>(args: SelectSubset<T, EmailLogCreateArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailLogs.
     * @param {EmailLogCreateManyArgs} args - Arguments to create many EmailLogs.
     * @example
     * // Create many EmailLogs
     * const emailLog = await prisma.emailLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailLogCreateManyArgs>(args?: SelectSubset<T, EmailLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailLogs and returns the data saved in the database.
     * @param {EmailLogCreateManyAndReturnArgs} args - Arguments to create many EmailLogs.
     * @example
     * // Create many EmailLogs
     * const emailLog = await prisma.emailLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailLogs and only return the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailLog.
     * @param {EmailLogDeleteArgs} args - Arguments to delete one EmailLog.
     * @example
     * // Delete one EmailLog
     * const EmailLog = await prisma.emailLog.delete({
     *   where: {
     *     // ... filter to delete one EmailLog
     *   }
     * })
     * 
     */
    delete<T extends EmailLogDeleteArgs>(args: SelectSubset<T, EmailLogDeleteArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailLog.
     * @param {EmailLogUpdateArgs} args - Arguments to update one EmailLog.
     * @example
     * // Update one EmailLog
     * const emailLog = await prisma.emailLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailLogUpdateArgs>(args: SelectSubset<T, EmailLogUpdateArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailLogs.
     * @param {EmailLogDeleteManyArgs} args - Arguments to filter EmailLogs to delete.
     * @example
     * // Delete a few EmailLogs
     * const { count } = await prisma.emailLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailLogDeleteManyArgs>(args?: SelectSubset<T, EmailLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailLogs
     * const emailLog = await prisma.emailLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailLogUpdateManyArgs>(args: SelectSubset<T, EmailLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailLogs and returns the data updated in the database.
     * @param {EmailLogUpdateManyAndReturnArgs} args - Arguments to update many EmailLogs.
     * @example
     * // Update many EmailLogs
     * const emailLog = await prisma.emailLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailLogs and only return the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailLogUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailLog.
     * @param {EmailLogUpsertArgs} args - Arguments to update or create a EmailLog.
     * @example
     * // Update or create a EmailLog
     * const emailLog = await prisma.emailLog.upsert({
     *   create: {
     *     // ... data to create a EmailLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailLog we want to update
     *   }
     * })
     */
    upsert<T extends EmailLogUpsertArgs>(args: SelectSubset<T, EmailLogUpsertArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogCountArgs} args - Arguments to filter EmailLogs to count.
     * @example
     * // Count the number of EmailLogs
     * const count = await prisma.emailLog.count({
     *   where: {
     *     // ... the filter for the EmailLogs we want to count
     *   }
     * })
    **/
    count<T extends EmailLogCountArgs>(
      args?: Subset<T, EmailLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailLogAggregateArgs>(args: Subset<T, EmailLogAggregateArgs>): Prisma.PrismaPromise<GetEmailLogAggregateType<T>>

    /**
     * Group by EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailLogGroupByArgs['orderBy'] }
        : { orderBy?: EmailLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailLog model
   */
  readonly fields: EmailLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    occurrence<T extends EmailLog$occurrenceArgs<ExtArgs> = {}>(args?: Subset<T, EmailLog$occurrenceArgs<ExtArgs>>): Prisma__TaskOccurrenceClient<$Result.GetResult<Prisma.$TaskOccurrencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    task<T extends EmailLog$taskArgs<ExtArgs> = {}>(args?: Subset<T, EmailLog$taskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailLog model
   */
  interface EmailLogFieldRefs {
    readonly id: FieldRef<"EmailLog", 'String'>
    readonly occurrenceId: FieldRef<"EmailLog", 'String'>
    readonly taskId: FieldRef<"EmailLog", 'String'>
    readonly recipient: FieldRef<"EmailLog", 'String'>
    readonly subject: FieldRef<"EmailLog", 'String'>
    readonly body: FieldRef<"EmailLog", 'String'>
    readonly provider: FieldRef<"EmailLog", 'String'>
    readonly providerMessageId: FieldRef<"EmailLog", 'String'>
    readonly status: FieldRef<"EmailLog", 'EmailStatus'>
    readonly error: FieldRef<"EmailLog", 'String'>
    readonly createdAt: FieldRef<"EmailLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailLog findUnique
   */
  export type EmailLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog findUniqueOrThrow
   */
  export type EmailLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog findFirst
   */
  export type EmailLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog findFirstOrThrow
   */
  export type EmailLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog findMany
   */
  export type EmailLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLogs to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog create
   */
  export type EmailLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailLog.
     */
    data: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
  }

  /**
   * EmailLog createMany
   */
  export type EmailLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailLogs.
     */
    data: EmailLogCreateManyInput | EmailLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailLog createManyAndReturn
   */
  export type EmailLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * The data used to create many EmailLogs.
     */
    data: EmailLogCreateManyInput | EmailLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailLog update
   */
  export type EmailLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailLog.
     */
    data: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
    /**
     * Choose, which EmailLog to update.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog updateMany
   */
  export type EmailLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailLogs.
     */
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailLogs to update
     */
    where?: EmailLogWhereInput
    /**
     * Limit how many EmailLogs to update.
     */
    limit?: number
  }

  /**
   * EmailLog updateManyAndReturn
   */
  export type EmailLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * The data used to update EmailLogs.
     */
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailLogs to update
     */
    where?: EmailLogWhereInput
    /**
     * Limit how many EmailLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailLog upsert
   */
  export type EmailLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailLog to update in case it exists.
     */
    where: EmailLogWhereUniqueInput
    /**
     * In case the EmailLog found by the `where` argument doesn't exist, create a new EmailLog with this data.
     */
    create: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
    /**
     * In case the EmailLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
  }

  /**
   * EmailLog delete
   */
  export type EmailLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter which EmailLog to delete.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog deleteMany
   */
  export type EmailLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLogs to delete
     */
    where?: EmailLogWhereInput
    /**
     * Limit how many EmailLogs to delete.
     */
    limit?: number
  }

  /**
   * EmailLog.occurrence
   */
  export type EmailLog$occurrenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOccurrence
     */
    select?: TaskOccurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskOccurrence
     */
    omit?: TaskOccurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOccurrenceInclude<ExtArgs> | null
    where?: TaskOccurrenceWhereInput
  }

  /**
   * EmailLog.task
   */
  export type EmailLog$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * EmailLog without action
   */
  export type EmailLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
  }


  /**
   * Model LeaveRequest
   */

  export type AggregateLeaveRequest = {
    _count: LeaveRequestCountAggregateOutputType | null
    _avg: LeaveRequestAvgAggregateOutputType | null
    _sum: LeaveRequestSumAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  export type LeaveRequestAvgAggregateOutputType = {
    days: number | null
  }

  export type LeaveRequestSumAggregateOutputType = {
    days: number | null
  }

  export type LeaveRequestMinAggregateOutputType = {
    id: string | null
    requesterId: string | null
    requesterName: string | null
    requesterEmail: string | null
    type: $Enums.LeaveType | null
    reason: string | null
    startDate: Date | null
    endDate: Date | null
    days: number | null
    status: $Enums.LeaveStatus | null
    approverId: string | null
    adminComment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestMaxAggregateOutputType = {
    id: string | null
    requesterId: string | null
    requesterName: string | null
    requesterEmail: string | null
    type: $Enums.LeaveType | null
    reason: string | null
    startDate: Date | null
    endDate: Date | null
    days: number | null
    status: $Enums.LeaveStatus | null
    approverId: string | null
    adminComment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestCountAggregateOutputType = {
    id: number
    requesterId: number
    requesterName: number
    requesterEmail: number
    type: number
    reason: number
    startDate: number
    endDate: number
    days: number
    status: number
    approverId: number
    adminComment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveRequestAvgAggregateInputType = {
    days?: true
  }

  export type LeaveRequestSumAggregateInputType = {
    days?: true
  }

  export type LeaveRequestMinAggregateInputType = {
    id?: true
    requesterId?: true
    requesterName?: true
    requesterEmail?: true
    type?: true
    reason?: true
    startDate?: true
    endDate?: true
    days?: true
    status?: true
    approverId?: true
    adminComment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestMaxAggregateInputType = {
    id?: true
    requesterId?: true
    requesterName?: true
    requesterEmail?: true
    type?: true
    reason?: true
    startDate?: true
    endDate?: true
    days?: true
    status?: true
    approverId?: true
    adminComment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestCountAggregateInputType = {
    id?: true
    requesterId?: true
    requesterName?: true
    requesterEmail?: true
    type?: true
    reason?: true
    startDate?: true
    endDate?: true
    days?: true
    status?: true
    approverId?: true
    adminComment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequest to aggregate.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveRequests
    **/
    _count?: true | LeaveRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type GetLeaveRequestAggregateType<T extends LeaveRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveRequest[P]>
      : GetScalarType<T[P], AggregateLeaveRequest[P]>
  }




  export type LeaveRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithAggregationInput | LeaveRequestOrderByWithAggregationInput[]
    by: LeaveRequestScalarFieldEnum[] | LeaveRequestScalarFieldEnum
    having?: LeaveRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveRequestCountAggregateInputType | true
    _avg?: LeaveRequestAvgAggregateInputType
    _sum?: LeaveRequestSumAggregateInputType
    _min?: LeaveRequestMinAggregateInputType
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type LeaveRequestGroupByOutputType = {
    id: string
    requesterId: string
    requesterName: string | null
    requesterEmail: string | null
    type: $Enums.LeaveType
    reason: string | null
    startDate: Date
    endDate: Date
    days: number
    status: $Enums.LeaveStatus
    approverId: string | null
    adminComment: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeaveRequestCountAggregateOutputType | null
    _avg: LeaveRequestAvgAggregateOutputType | null
    _sum: LeaveRequestSumAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  type GetLeaveRequestGroupByPayload<T extends LeaveRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
        }
      >
    >


  export type LeaveRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    requesterName?: boolean
    requesterEmail?: boolean
    type?: boolean
    reason?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    status?: boolean
    approverId?: boolean
    adminComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    requesterName?: boolean
    requesterEmail?: boolean
    type?: boolean
    reason?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    status?: boolean
    approverId?: boolean
    adminComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    requesterName?: boolean
    requesterEmail?: boolean
    type?: boolean
    reason?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    status?: boolean
    approverId?: boolean
    adminComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectScalar = {
    id?: boolean
    requesterId?: boolean
    requesterName?: boolean
    requesterEmail?: boolean
    type?: boolean
    reason?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    status?: boolean
    approverId?: boolean
    adminComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requesterId" | "requesterName" | "requesterEmail" | "type" | "reason" | "startDate" | "endDate" | "days" | "status" | "approverId" | "adminComment" | "createdAt" | "updatedAt", ExtArgs["result"]["leaveRequest"]>

  export type $LeaveRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requesterId: string
      requesterName: string | null
      requesterEmail: string | null
      type: $Enums.LeaveType
      reason: string | null
      startDate: Date
      endDate: Date
      days: number
      status: $Enums.LeaveStatus
      approverId: string | null
      adminComment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveRequest"]>
    composites: {}
  }

  type LeaveRequestGetPayload<S extends boolean | null | undefined | LeaveRequestDefaultArgs> = $Result.GetResult<Prisma.$LeaveRequestPayload, S>

  type LeaveRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveRequestCountAggregateInputType | true
    }

  export interface LeaveRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveRequest'], meta: { name: 'LeaveRequest' } }
    /**
     * Find zero or one LeaveRequest that matches the filter.
     * @param {LeaveRequestFindUniqueArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveRequestFindUniqueArgs>(args: SelectSubset<T, LeaveRequestFindUniqueArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaveRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveRequestFindUniqueOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveRequestFindFirstArgs>(args?: SelectSubset<T, LeaveRequestFindFirstArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaveRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany()
     * 
     * // Get first 10 LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveRequestFindManyArgs>(args?: SelectSubset<T, LeaveRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaveRequest.
     * @param {LeaveRequestCreateArgs} args - Arguments to create a LeaveRequest.
     * @example
     * // Create one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.create({
     *   data: {
     *     // ... data to create a LeaveRequest
     *   }
     * })
     * 
     */
    create<T extends LeaveRequestCreateArgs>(args: SelectSubset<T, LeaveRequestCreateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaveRequests.
     * @param {LeaveRequestCreateManyArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveRequestCreateManyArgs>(args?: SelectSubset<T, LeaveRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveRequests and returns the data saved in the database.
     * @param {LeaveRequestCreateManyAndReturnArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveRequests and only return the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaveRequest.
     * @param {LeaveRequestDeleteArgs} args - Arguments to delete one LeaveRequest.
     * @example
     * // Delete one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.delete({
     *   where: {
     *     // ... filter to delete one LeaveRequest
     *   }
     * })
     * 
     */
    delete<T extends LeaveRequestDeleteArgs>(args: SelectSubset<T, LeaveRequestDeleteArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaveRequest.
     * @param {LeaveRequestUpdateArgs} args - Arguments to update one LeaveRequest.
     * @example
     * // Update one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveRequestUpdateArgs>(args: SelectSubset<T, LeaveRequestUpdateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaveRequests.
     * @param {LeaveRequestDeleteManyArgs} args - Arguments to filter LeaveRequests to delete.
     * @example
     * // Delete a few LeaveRequests
     * const { count } = await prisma.leaveRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveRequestDeleteManyArgs>(args?: SelectSubset<T, LeaveRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveRequestUpdateManyArgs>(args: SelectSubset<T, LeaveRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests and returns the data updated in the database.
     * @param {LeaveRequestUpdateManyAndReturnArgs} args - Arguments to update many LeaveRequests.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaveRequests and only return the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaveRequest.
     * @param {LeaveRequestUpsertArgs} args - Arguments to update or create a LeaveRequest.
     * @example
     * // Update or create a LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.upsert({
     *   create: {
     *     // ... data to create a LeaveRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveRequest we want to update
     *   }
     * })
     */
    upsert<T extends LeaveRequestUpsertArgs>(args: SelectSubset<T, LeaveRequestUpsertArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestCountArgs} args - Arguments to filter LeaveRequests to count.
     * @example
     * // Count the number of LeaveRequests
     * const count = await prisma.leaveRequest.count({
     *   where: {
     *     // ... the filter for the LeaveRequests we want to count
     *   }
     * })
    **/
    count<T extends LeaveRequestCountArgs>(
      args?: Subset<T, LeaveRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveRequestAggregateArgs>(args: Subset<T, LeaveRequestAggregateArgs>): Prisma.PrismaPromise<GetLeaveRequestAggregateType<T>>

    /**
     * Group by LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveRequestGroupByArgs['orderBy'] }
        : { orderBy?: LeaveRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveRequest model
   */
  readonly fields: LeaveRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveRequest model
   */
  interface LeaveRequestFieldRefs {
    readonly id: FieldRef<"LeaveRequest", 'String'>
    readonly requesterId: FieldRef<"LeaveRequest", 'String'>
    readonly requesterName: FieldRef<"LeaveRequest", 'String'>
    readonly requesterEmail: FieldRef<"LeaveRequest", 'String'>
    readonly type: FieldRef<"LeaveRequest", 'LeaveType'>
    readonly reason: FieldRef<"LeaveRequest", 'String'>
    readonly startDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly endDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly days: FieldRef<"LeaveRequest", 'Float'>
    readonly status: FieldRef<"LeaveRequest", 'LeaveStatus'>
    readonly approverId: FieldRef<"LeaveRequest", 'String'>
    readonly adminComment: FieldRef<"LeaveRequest", 'String'>
    readonly createdAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveRequest findUnique
   */
  export type LeaveRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findUniqueOrThrow
   */
  export type LeaveRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findFirst
   */
  export type LeaveRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findFirstOrThrow
   */
  export type LeaveRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findMany
   */
  export type LeaveRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Filter, which LeaveRequests to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest create
   */
  export type LeaveRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * The data needed to create a LeaveRequest.
     */
    data: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
  }

  /**
   * LeaveRequest createMany
   */
  export type LeaveRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveRequest createManyAndReturn
   */
  export type LeaveRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveRequest update
   */
  export type LeaveRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * The data needed to update a LeaveRequest.
     */
    data: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
    /**
     * Choose, which LeaveRequest to update.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest updateMany
   */
  export type LeaveRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
    /**
     * Limit how many LeaveRequests to update.
     */
    limit?: number
  }

  /**
   * LeaveRequest updateManyAndReturn
   */
  export type LeaveRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
    /**
     * Limit how many LeaveRequests to update.
     */
    limit?: number
  }

  /**
   * LeaveRequest upsert
   */
  export type LeaveRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * The filter to search for the LeaveRequest to update in case it exists.
     */
    where: LeaveRequestWhereUniqueInput
    /**
     * In case the LeaveRequest found by the `where` argument doesn't exist, create a new LeaveRequest with this data.
     */
    create: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
    /**
     * In case the LeaveRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
  }

  /**
   * LeaveRequest delete
   */
  export type LeaveRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Filter which LeaveRequest to delete.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest deleteMany
   */
  export type LeaveRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequests to delete
     */
    where?: LeaveRequestWhereInput
    /**
     * Limit how many LeaveRequests to delete.
     */
    limit?: number
  }

  /**
   * LeaveRequest without action
   */
  export type LeaveRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
  }


  /**
   * Model License
   */

  export type AggregateLicense = {
    _count: LicenseCountAggregateOutputType | null
    _avg: LicenseAvgAggregateOutputType | null
    _sum: LicenseSumAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  export type LicenseAvgAggregateOutputType = {
    remindOffsets: number | null
    gracePeriodDays: number | null
  }

  export type LicenseSumAggregateOutputType = {
    remindOffsets: number[]
    gracePeriodDays: number | null
  }

  export type LicenseMinAggregateOutputType = {
    id: string | null
    title: string | null
    licenseNumber: string | null
    type: string | null
    holder: string | null
    clientId: string | null
    projectId: string | null
    serviceId: string | null
    url: string | null
    vendorId: string | null
    issuedOn: Date | null
    validFrom: Date | null
    expiresOn: Date | null
    gracePeriodDays: number | null
    muted: boolean | null
    responsibleId: string | null
    status: $Enums.LicenseStatus | null
    nextReminderAt: Date | null
    lastReminderAt: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LicenseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    licenseNumber: string | null
    type: string | null
    holder: string | null
    clientId: string | null
    projectId: string | null
    serviceId: string | null
    url: string | null
    vendorId: string | null
    issuedOn: Date | null
    validFrom: Date | null
    expiresOn: Date | null
    gracePeriodDays: number | null
    muted: boolean | null
    responsibleId: string | null
    status: $Enums.LicenseStatus | null
    nextReminderAt: Date | null
    lastReminderAt: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LicenseCountAggregateOutputType = {
    id: number
    title: number
    licenseNumber: number
    type: number
    holder: number
    clientId: number
    projectId: number
    serviceId: number
    url: number
    vendorId: number
    issuedOn: number
    validFrom: number
    expiresOn: number
    remindOffsets: number
    gracePeriodDays: number
    muted: number
    responsibleId: number
    status: number
    nextReminderAt: number
    lastReminderAt: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LicenseAvgAggregateInputType = {
    remindOffsets?: true
    gracePeriodDays?: true
  }

  export type LicenseSumAggregateInputType = {
    remindOffsets?: true
    gracePeriodDays?: true
  }

  export type LicenseMinAggregateInputType = {
    id?: true
    title?: true
    licenseNumber?: true
    type?: true
    holder?: true
    clientId?: true
    projectId?: true
    serviceId?: true
    url?: true
    vendorId?: true
    issuedOn?: true
    validFrom?: true
    expiresOn?: true
    gracePeriodDays?: true
    muted?: true
    responsibleId?: true
    status?: true
    nextReminderAt?: true
    lastReminderAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LicenseMaxAggregateInputType = {
    id?: true
    title?: true
    licenseNumber?: true
    type?: true
    holder?: true
    clientId?: true
    projectId?: true
    serviceId?: true
    url?: true
    vendorId?: true
    issuedOn?: true
    validFrom?: true
    expiresOn?: true
    gracePeriodDays?: true
    muted?: true
    responsibleId?: true
    status?: true
    nextReminderAt?: true
    lastReminderAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LicenseCountAggregateInputType = {
    id?: true
    title?: true
    licenseNumber?: true
    type?: true
    holder?: true
    clientId?: true
    projectId?: true
    serviceId?: true
    url?: true
    vendorId?: true
    issuedOn?: true
    validFrom?: true
    expiresOn?: true
    remindOffsets?: true
    gracePeriodDays?: true
    muted?: true
    responsibleId?: true
    status?: true
    nextReminderAt?: true
    lastReminderAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LicenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which License to aggregate.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Licenses
    **/
    _count?: true | LicenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LicenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LicenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicenseMaxAggregateInputType
  }

  export type GetLicenseAggregateType<T extends LicenseAggregateArgs> = {
        [P in keyof T & keyof AggregateLicense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicense[P]>
      : GetScalarType<T[P], AggregateLicense[P]>
  }




  export type LicenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseWhereInput
    orderBy?: LicenseOrderByWithAggregationInput | LicenseOrderByWithAggregationInput[]
    by: LicenseScalarFieldEnum[] | LicenseScalarFieldEnum
    having?: LicenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicenseCountAggregateInputType | true
    _avg?: LicenseAvgAggregateInputType
    _sum?: LicenseSumAggregateInputType
    _min?: LicenseMinAggregateInputType
    _max?: LicenseMaxAggregateInputType
  }

  export type LicenseGroupByOutputType = {
    id: string
    title: string
    licenseNumber: string | null
    type: string | null
    holder: string | null
    clientId: string | null
    projectId: string | null
    serviceId: string | null
    url: string | null
    vendorId: string | null
    issuedOn: Date | null
    validFrom: Date | null
    expiresOn: Date
    remindOffsets: number[]
    gracePeriodDays: number | null
    muted: boolean | null
    responsibleId: string | null
    status: $Enums.LicenseStatus | null
    nextReminderAt: Date | null
    lastReminderAt: Date | null
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: LicenseCountAggregateOutputType | null
    _avg: LicenseAvgAggregateOutputType | null
    _sum: LicenseSumAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  type GetLicenseGroupByPayload<T extends LicenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicenseGroupByOutputType[P]>
            : GetScalarType<T[P], LicenseGroupByOutputType[P]>
        }
      >
    >


  export type LicenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    licenseNumber?: boolean
    type?: boolean
    holder?: boolean
    clientId?: boolean
    projectId?: boolean
    serviceId?: boolean
    url?: boolean
    vendorId?: boolean
    issuedOn?: boolean
    validFrom?: boolean
    expiresOn?: boolean
    remindOffsets?: boolean
    gracePeriodDays?: boolean
    muted?: boolean
    responsibleId?: boolean
    status?: boolean
    nextReminderAt?: boolean
    lastReminderAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignees?: boolean | License$assigneesArgs<ExtArgs>
    histories?: boolean | License$historiesArgs<ExtArgs>
    attachments?: boolean | License$attachmentsArgs<ExtArgs>
    scheduledReminders?: boolean | License$scheduledRemindersArgs<ExtArgs>
    _count?: boolean | LicenseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    licenseNumber?: boolean
    type?: boolean
    holder?: boolean
    clientId?: boolean
    projectId?: boolean
    serviceId?: boolean
    url?: boolean
    vendorId?: boolean
    issuedOn?: boolean
    validFrom?: boolean
    expiresOn?: boolean
    remindOffsets?: boolean
    gracePeriodDays?: boolean
    muted?: boolean
    responsibleId?: boolean
    status?: boolean
    nextReminderAt?: boolean
    lastReminderAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    licenseNumber?: boolean
    type?: boolean
    holder?: boolean
    clientId?: boolean
    projectId?: boolean
    serviceId?: boolean
    url?: boolean
    vendorId?: boolean
    issuedOn?: boolean
    validFrom?: boolean
    expiresOn?: boolean
    remindOffsets?: boolean
    gracePeriodDays?: boolean
    muted?: boolean
    responsibleId?: boolean
    status?: boolean
    nextReminderAt?: boolean
    lastReminderAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectScalar = {
    id?: boolean
    title?: boolean
    licenseNumber?: boolean
    type?: boolean
    holder?: boolean
    clientId?: boolean
    projectId?: boolean
    serviceId?: boolean
    url?: boolean
    vendorId?: boolean
    issuedOn?: boolean
    validFrom?: boolean
    expiresOn?: boolean
    remindOffsets?: boolean
    gracePeriodDays?: boolean
    muted?: boolean
    responsibleId?: boolean
    status?: boolean
    nextReminderAt?: boolean
    lastReminderAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LicenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "licenseNumber" | "type" | "holder" | "clientId" | "projectId" | "serviceId" | "url" | "vendorId" | "issuedOn" | "validFrom" | "expiresOn" | "remindOffsets" | "gracePeriodDays" | "muted" | "responsibleId" | "status" | "nextReminderAt" | "lastReminderAt" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["license"]>
  export type LicenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignees?: boolean | License$assigneesArgs<ExtArgs>
    histories?: boolean | License$historiesArgs<ExtArgs>
    attachments?: boolean | License$attachmentsArgs<ExtArgs>
    scheduledReminders?: boolean | License$scheduledRemindersArgs<ExtArgs>
    _count?: boolean | LicenseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LicenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LicenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LicensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "License"
    objects: {
      assignees: Prisma.$LicenseAssigneePayload<ExtArgs>[]
      histories: Prisma.$LicenseHistoryPayload<ExtArgs>[]
      attachments: Prisma.$LicenseAttachmentPayload<ExtArgs>[]
      scheduledReminders: Prisma.$ScheduledReminderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      licenseNumber: string | null
      type: string | null
      holder: string | null
      clientId: string | null
      projectId: string | null
      serviceId: string | null
      url: string | null
      vendorId: string | null
      issuedOn: Date | null
      validFrom: Date | null
      expiresOn: Date
      remindOffsets: number[]
      gracePeriodDays: number | null
      muted: boolean | null
      responsibleId: string | null
      status: $Enums.LicenseStatus | null
      nextReminderAt: Date | null
      lastReminderAt: Date | null
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["license"]>
    composites: {}
  }

  type LicenseGetPayload<S extends boolean | null | undefined | LicenseDefaultArgs> = $Result.GetResult<Prisma.$LicensePayload, S>

  type LicenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LicenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LicenseCountAggregateInputType | true
    }

  export interface LicenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['License'], meta: { name: 'License' } }
    /**
     * Find zero or one License that matches the filter.
     * @param {LicenseFindUniqueArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicenseFindUniqueArgs>(args: SelectSubset<T, LicenseFindUniqueArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one License that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LicenseFindUniqueOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicenseFindUniqueOrThrowArgs>(args: SelectSubset<T, LicenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first License that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicenseFindFirstArgs>(args?: SelectSubset<T, LicenseFindFirstArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first License that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicenseFindFirstOrThrowArgs>(args?: SelectSubset<T, LicenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Licenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Licenses
     * const licenses = await prisma.license.findMany()
     * 
     * // Get first 10 Licenses
     * const licenses = await prisma.license.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const licenseWithIdOnly = await prisma.license.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LicenseFindManyArgs>(args?: SelectSubset<T, LicenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a License.
     * @param {LicenseCreateArgs} args - Arguments to create a License.
     * @example
     * // Create one License
     * const License = await prisma.license.create({
     *   data: {
     *     // ... data to create a License
     *   }
     * })
     * 
     */
    create<T extends LicenseCreateArgs>(args: SelectSubset<T, LicenseCreateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Licenses.
     * @param {LicenseCreateManyArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const license = await prisma.license.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicenseCreateManyArgs>(args?: SelectSubset<T, LicenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Licenses and returns the data saved in the database.
     * @param {LicenseCreateManyAndReturnArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const license = await prisma.license.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Licenses and only return the `id`
     * const licenseWithIdOnly = await prisma.license.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LicenseCreateManyAndReturnArgs>(args?: SelectSubset<T, LicenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a License.
     * @param {LicenseDeleteArgs} args - Arguments to delete one License.
     * @example
     * // Delete one License
     * const License = await prisma.license.delete({
     *   where: {
     *     // ... filter to delete one License
     *   }
     * })
     * 
     */
    delete<T extends LicenseDeleteArgs>(args: SelectSubset<T, LicenseDeleteArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one License.
     * @param {LicenseUpdateArgs} args - Arguments to update one License.
     * @example
     * // Update one License
     * const license = await prisma.license.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicenseUpdateArgs>(args: SelectSubset<T, LicenseUpdateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Licenses.
     * @param {LicenseDeleteManyArgs} args - Arguments to filter Licenses to delete.
     * @example
     * // Delete a few Licenses
     * const { count } = await prisma.license.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicenseDeleteManyArgs>(args?: SelectSubset<T, LicenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Licenses
     * const license = await prisma.license.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicenseUpdateManyArgs>(args: SelectSubset<T, LicenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenses and returns the data updated in the database.
     * @param {LicenseUpdateManyAndReturnArgs} args - Arguments to update many Licenses.
     * @example
     * // Update many Licenses
     * const license = await prisma.license.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Licenses and only return the `id`
     * const licenseWithIdOnly = await prisma.license.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LicenseUpdateManyAndReturnArgs>(args: SelectSubset<T, LicenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one License.
     * @param {LicenseUpsertArgs} args - Arguments to update or create a License.
     * @example
     * // Update or create a License
     * const license = await prisma.license.upsert({
     *   create: {
     *     // ... data to create a License
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the License we want to update
     *   }
     * })
     */
    upsert<T extends LicenseUpsertArgs>(args: SelectSubset<T, LicenseUpsertArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseCountArgs} args - Arguments to filter Licenses to count.
     * @example
     * // Count the number of Licenses
     * const count = await prisma.license.count({
     *   where: {
     *     // ... the filter for the Licenses we want to count
     *   }
     * })
    **/
    count<T extends LicenseCountArgs>(
      args?: Subset<T, LicenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicenseAggregateArgs>(args: Subset<T, LicenseAggregateArgs>): Prisma.PrismaPromise<GetLicenseAggregateType<T>>

    /**
     * Group by License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicenseGroupByArgs['orderBy'] }
        : { orderBy?: LicenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the License model
   */
  readonly fields: LicenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for License.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignees<T extends License$assigneesArgs<ExtArgs> = {}>(args?: Subset<T, License$assigneesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenseAssigneePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    histories<T extends License$historiesArgs<ExtArgs> = {}>(args?: Subset<T, License$historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenseHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends License$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, License$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenseAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduledReminders<T extends License$scheduledRemindersArgs<ExtArgs> = {}>(args?: Subset<T, License$scheduledRemindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the License model
   */
  interface LicenseFieldRefs {
    readonly id: FieldRef<"License", 'String'>
    readonly title: FieldRef<"License", 'String'>
    readonly licenseNumber: FieldRef<"License", 'String'>
    readonly type: FieldRef<"License", 'String'>
    readonly holder: FieldRef<"License", 'String'>
    readonly clientId: FieldRef<"License", 'String'>
    readonly projectId: FieldRef<"License", 'String'>
    readonly serviceId: FieldRef<"License", 'String'>
    readonly url: FieldRef<"License", 'String'>
    readonly vendorId: FieldRef<"License", 'String'>
    readonly issuedOn: FieldRef<"License", 'DateTime'>
    readonly validFrom: FieldRef<"License", 'DateTime'>
    readonly expiresOn: FieldRef<"License", 'DateTime'>
    readonly remindOffsets: FieldRef<"License", 'Int[]'>
    readonly gracePeriodDays: FieldRef<"License", 'Int'>
    readonly muted: FieldRef<"License", 'Boolean'>
    readonly responsibleId: FieldRef<"License", 'String'>
    readonly status: FieldRef<"License", 'LicenseStatus'>
    readonly nextReminderAt: FieldRef<"License", 'DateTime'>
    readonly lastReminderAt: FieldRef<"License", 'DateTime'>
    readonly createdById: FieldRef<"License", 'String'>
    readonly createdAt: FieldRef<"License", 'DateTime'>
    readonly updatedAt: FieldRef<"License", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * License findUnique
   */
  export type LicenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License findUniqueOrThrow
   */
  export type LicenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License findFirst
   */
  export type LicenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License findFirstOrThrow
   */
  export type LicenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License findMany
   */
  export type LicenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which Licenses to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License create
   */
  export type LicenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The data needed to create a License.
     */
    data: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
  }

  /**
   * License createMany
   */
  export type LicenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Licenses.
     */
    data: LicenseCreateManyInput | LicenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * License createManyAndReturn
   */
  export type LicenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * The data used to create many Licenses.
     */
    data: LicenseCreateManyInput | LicenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * License update
   */
  export type LicenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The data needed to update a License.
     */
    data: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
    /**
     * Choose, which License to update.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License updateMany
   */
  export type LicenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Licenses.
     */
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyInput>
    /**
     * Filter which Licenses to update
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to update.
     */
    limit?: number
  }

  /**
   * License updateManyAndReturn
   */
  export type LicenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * The data used to update Licenses.
     */
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyInput>
    /**
     * Filter which Licenses to update
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to update.
     */
    limit?: number
  }

  /**
   * License upsert
   */
  export type LicenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The filter to search for the License to update in case it exists.
     */
    where: LicenseWhereUniqueInput
    /**
     * In case the License found by the `where` argument doesn't exist, create a new License with this data.
     */
    create: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
    /**
     * In case the License was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
  }

  /**
   * License delete
   */
  export type LicenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter which License to delete.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License deleteMany
   */
  export type LicenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Licenses to delete
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to delete.
     */
    limit?: number
  }

  /**
   * License.assignees
   */
  export type License$assigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeInclude<ExtArgs> | null
    where?: LicenseAssigneeWhereInput
    orderBy?: LicenseAssigneeOrderByWithRelationInput | LicenseAssigneeOrderByWithRelationInput[]
    cursor?: LicenseAssigneeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LicenseAssigneeScalarFieldEnum | LicenseAssigneeScalarFieldEnum[]
  }

  /**
   * License.histories
   */
  export type License$historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryInclude<ExtArgs> | null
    where?: LicenseHistoryWhereInput
    orderBy?: LicenseHistoryOrderByWithRelationInput | LicenseHistoryOrderByWithRelationInput[]
    cursor?: LicenseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LicenseHistoryScalarFieldEnum | LicenseHistoryScalarFieldEnum[]
  }

  /**
   * License.attachments
   */
  export type License$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentInclude<ExtArgs> | null
    where?: LicenseAttachmentWhereInput
    orderBy?: LicenseAttachmentOrderByWithRelationInput | LicenseAttachmentOrderByWithRelationInput[]
    cursor?: LicenseAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LicenseAttachmentScalarFieldEnum | LicenseAttachmentScalarFieldEnum[]
  }

  /**
   * License.scheduledReminders
   */
  export type License$scheduledRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderInclude<ExtArgs> | null
    where?: ScheduledReminderWhereInput
    orderBy?: ScheduledReminderOrderByWithRelationInput | ScheduledReminderOrderByWithRelationInput[]
    cursor?: ScheduledReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledReminderScalarFieldEnum | ScheduledReminderScalarFieldEnum[]
  }

  /**
   * License without action
   */
  export type LicenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
  }


  /**
   * Model LicenseAssignee
   */

  export type AggregateLicenseAssignee = {
    _count: LicenseAssigneeCountAggregateOutputType | null
    _min: LicenseAssigneeMinAggregateOutputType | null
    _max: LicenseAssigneeMaxAggregateOutputType | null
  }

  export type LicenseAssigneeMinAggregateOutputType = {
    licenseId: string | null
    userId: string | null
    role: $Enums.LicenseAssigneeRole | null
  }

  export type LicenseAssigneeMaxAggregateOutputType = {
    licenseId: string | null
    userId: string | null
    role: $Enums.LicenseAssigneeRole | null
  }

  export type LicenseAssigneeCountAggregateOutputType = {
    licenseId: number
    userId: number
    role: number
    _all: number
  }


  export type LicenseAssigneeMinAggregateInputType = {
    licenseId?: true
    userId?: true
    role?: true
  }

  export type LicenseAssigneeMaxAggregateInputType = {
    licenseId?: true
    userId?: true
    role?: true
  }

  export type LicenseAssigneeCountAggregateInputType = {
    licenseId?: true
    userId?: true
    role?: true
    _all?: true
  }

  export type LicenseAssigneeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LicenseAssignee to aggregate.
     */
    where?: LicenseAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicenseAssignees to fetch.
     */
    orderBy?: LicenseAssigneeOrderByWithRelationInput | LicenseAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicenseAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicenseAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicenseAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LicenseAssignees
    **/
    _count?: true | LicenseAssigneeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicenseAssigneeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicenseAssigneeMaxAggregateInputType
  }

  export type GetLicenseAssigneeAggregateType<T extends LicenseAssigneeAggregateArgs> = {
        [P in keyof T & keyof AggregateLicenseAssignee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicenseAssignee[P]>
      : GetScalarType<T[P], AggregateLicenseAssignee[P]>
  }




  export type LicenseAssigneeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseAssigneeWhereInput
    orderBy?: LicenseAssigneeOrderByWithAggregationInput | LicenseAssigneeOrderByWithAggregationInput[]
    by: LicenseAssigneeScalarFieldEnum[] | LicenseAssigneeScalarFieldEnum
    having?: LicenseAssigneeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicenseAssigneeCountAggregateInputType | true
    _min?: LicenseAssigneeMinAggregateInputType
    _max?: LicenseAssigneeMaxAggregateInputType
  }

  export type LicenseAssigneeGroupByOutputType = {
    licenseId: string
    userId: string
    role: $Enums.LicenseAssigneeRole
    _count: LicenseAssigneeCountAggregateOutputType | null
    _min: LicenseAssigneeMinAggregateOutputType | null
    _max: LicenseAssigneeMaxAggregateOutputType | null
  }

  type GetLicenseAssigneeGroupByPayload<T extends LicenseAssigneeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicenseAssigneeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicenseAssigneeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicenseAssigneeGroupByOutputType[P]>
            : GetScalarType<T[P], LicenseAssigneeGroupByOutputType[P]>
        }
      >
    >


  export type LicenseAssigneeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    licenseId?: boolean
    userId?: boolean
    role?: boolean
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["licenseAssignee"]>

  export type LicenseAssigneeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    licenseId?: boolean
    userId?: boolean
    role?: boolean
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["licenseAssignee"]>

  export type LicenseAssigneeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    licenseId?: boolean
    userId?: boolean
    role?: boolean
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["licenseAssignee"]>

  export type LicenseAssigneeSelectScalar = {
    licenseId?: boolean
    userId?: boolean
    role?: boolean
  }

  export type LicenseAssigneeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"licenseId" | "userId" | "role", ExtArgs["result"]["licenseAssignee"]>
  export type LicenseAssigneeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }
  export type LicenseAssigneeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }
  export type LicenseAssigneeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }

  export type $LicenseAssigneePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LicenseAssignee"
    objects: {
      license: Prisma.$LicensePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      licenseId: string
      userId: string
      role: $Enums.LicenseAssigneeRole
    }, ExtArgs["result"]["licenseAssignee"]>
    composites: {}
  }

  type LicenseAssigneeGetPayload<S extends boolean | null | undefined | LicenseAssigneeDefaultArgs> = $Result.GetResult<Prisma.$LicenseAssigneePayload, S>

  type LicenseAssigneeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LicenseAssigneeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LicenseAssigneeCountAggregateInputType | true
    }

  export interface LicenseAssigneeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LicenseAssignee'], meta: { name: 'LicenseAssignee' } }
    /**
     * Find zero or one LicenseAssignee that matches the filter.
     * @param {LicenseAssigneeFindUniqueArgs} args - Arguments to find a LicenseAssignee
     * @example
     * // Get one LicenseAssignee
     * const licenseAssignee = await prisma.licenseAssignee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicenseAssigneeFindUniqueArgs>(args: SelectSubset<T, LicenseAssigneeFindUniqueArgs<ExtArgs>>): Prisma__LicenseAssigneeClient<$Result.GetResult<Prisma.$LicenseAssigneePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LicenseAssignee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LicenseAssigneeFindUniqueOrThrowArgs} args - Arguments to find a LicenseAssignee
     * @example
     * // Get one LicenseAssignee
     * const licenseAssignee = await prisma.licenseAssignee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicenseAssigneeFindUniqueOrThrowArgs>(args: SelectSubset<T, LicenseAssigneeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicenseAssigneeClient<$Result.GetResult<Prisma.$LicenseAssigneePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LicenseAssignee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAssigneeFindFirstArgs} args - Arguments to find a LicenseAssignee
     * @example
     * // Get one LicenseAssignee
     * const licenseAssignee = await prisma.licenseAssignee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicenseAssigneeFindFirstArgs>(args?: SelectSubset<T, LicenseAssigneeFindFirstArgs<ExtArgs>>): Prisma__LicenseAssigneeClient<$Result.GetResult<Prisma.$LicenseAssigneePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LicenseAssignee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAssigneeFindFirstOrThrowArgs} args - Arguments to find a LicenseAssignee
     * @example
     * // Get one LicenseAssignee
     * const licenseAssignee = await prisma.licenseAssignee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicenseAssigneeFindFirstOrThrowArgs>(args?: SelectSubset<T, LicenseAssigneeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicenseAssigneeClient<$Result.GetResult<Prisma.$LicenseAssigneePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LicenseAssignees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAssigneeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LicenseAssignees
     * const licenseAssignees = await prisma.licenseAssignee.findMany()
     * 
     * // Get first 10 LicenseAssignees
     * const licenseAssignees = await prisma.licenseAssignee.findMany({ take: 10 })
     * 
     * // Only select the `licenseId`
     * const licenseAssigneeWithLicenseIdOnly = await prisma.licenseAssignee.findMany({ select: { licenseId: true } })
     * 
     */
    findMany<T extends LicenseAssigneeFindManyArgs>(args?: SelectSubset<T, LicenseAssigneeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenseAssigneePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LicenseAssignee.
     * @param {LicenseAssigneeCreateArgs} args - Arguments to create a LicenseAssignee.
     * @example
     * // Create one LicenseAssignee
     * const LicenseAssignee = await prisma.licenseAssignee.create({
     *   data: {
     *     // ... data to create a LicenseAssignee
     *   }
     * })
     * 
     */
    create<T extends LicenseAssigneeCreateArgs>(args: SelectSubset<T, LicenseAssigneeCreateArgs<ExtArgs>>): Prisma__LicenseAssigneeClient<$Result.GetResult<Prisma.$LicenseAssigneePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LicenseAssignees.
     * @param {LicenseAssigneeCreateManyArgs} args - Arguments to create many LicenseAssignees.
     * @example
     * // Create many LicenseAssignees
     * const licenseAssignee = await prisma.licenseAssignee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicenseAssigneeCreateManyArgs>(args?: SelectSubset<T, LicenseAssigneeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LicenseAssignees and returns the data saved in the database.
     * @param {LicenseAssigneeCreateManyAndReturnArgs} args - Arguments to create many LicenseAssignees.
     * @example
     * // Create many LicenseAssignees
     * const licenseAssignee = await prisma.licenseAssignee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LicenseAssignees and only return the `licenseId`
     * const licenseAssigneeWithLicenseIdOnly = await prisma.licenseAssignee.createManyAndReturn({
     *   select: { licenseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LicenseAssigneeCreateManyAndReturnArgs>(args?: SelectSubset<T, LicenseAssigneeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenseAssigneePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LicenseAssignee.
     * @param {LicenseAssigneeDeleteArgs} args - Arguments to delete one LicenseAssignee.
     * @example
     * // Delete one LicenseAssignee
     * const LicenseAssignee = await prisma.licenseAssignee.delete({
     *   where: {
     *     // ... filter to delete one LicenseAssignee
     *   }
     * })
     * 
     */
    delete<T extends LicenseAssigneeDeleteArgs>(args: SelectSubset<T, LicenseAssigneeDeleteArgs<ExtArgs>>): Prisma__LicenseAssigneeClient<$Result.GetResult<Prisma.$LicenseAssigneePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LicenseAssignee.
     * @param {LicenseAssigneeUpdateArgs} args - Arguments to update one LicenseAssignee.
     * @example
     * // Update one LicenseAssignee
     * const licenseAssignee = await prisma.licenseAssignee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicenseAssigneeUpdateArgs>(args: SelectSubset<T, LicenseAssigneeUpdateArgs<ExtArgs>>): Prisma__LicenseAssigneeClient<$Result.GetResult<Prisma.$LicenseAssigneePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LicenseAssignees.
     * @param {LicenseAssigneeDeleteManyArgs} args - Arguments to filter LicenseAssignees to delete.
     * @example
     * // Delete a few LicenseAssignees
     * const { count } = await prisma.licenseAssignee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicenseAssigneeDeleteManyArgs>(args?: SelectSubset<T, LicenseAssigneeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LicenseAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAssigneeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LicenseAssignees
     * const licenseAssignee = await prisma.licenseAssignee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicenseAssigneeUpdateManyArgs>(args: SelectSubset<T, LicenseAssigneeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LicenseAssignees and returns the data updated in the database.
     * @param {LicenseAssigneeUpdateManyAndReturnArgs} args - Arguments to update many LicenseAssignees.
     * @example
     * // Update many LicenseAssignees
     * const licenseAssignee = await prisma.licenseAssignee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LicenseAssignees and only return the `licenseId`
     * const licenseAssigneeWithLicenseIdOnly = await prisma.licenseAssignee.updateManyAndReturn({
     *   select: { licenseId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LicenseAssigneeUpdateManyAndReturnArgs>(args: SelectSubset<T, LicenseAssigneeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenseAssigneePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LicenseAssignee.
     * @param {LicenseAssigneeUpsertArgs} args - Arguments to update or create a LicenseAssignee.
     * @example
     * // Update or create a LicenseAssignee
     * const licenseAssignee = await prisma.licenseAssignee.upsert({
     *   create: {
     *     // ... data to create a LicenseAssignee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LicenseAssignee we want to update
     *   }
     * })
     */
    upsert<T extends LicenseAssigneeUpsertArgs>(args: SelectSubset<T, LicenseAssigneeUpsertArgs<ExtArgs>>): Prisma__LicenseAssigneeClient<$Result.GetResult<Prisma.$LicenseAssigneePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LicenseAssignees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAssigneeCountArgs} args - Arguments to filter LicenseAssignees to count.
     * @example
     * // Count the number of LicenseAssignees
     * const count = await prisma.licenseAssignee.count({
     *   where: {
     *     // ... the filter for the LicenseAssignees we want to count
     *   }
     * })
    **/
    count<T extends LicenseAssigneeCountArgs>(
      args?: Subset<T, LicenseAssigneeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicenseAssigneeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LicenseAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAssigneeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicenseAssigneeAggregateArgs>(args: Subset<T, LicenseAssigneeAggregateArgs>): Prisma.PrismaPromise<GetLicenseAssigneeAggregateType<T>>

    /**
     * Group by LicenseAssignee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAssigneeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicenseAssigneeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicenseAssigneeGroupByArgs['orderBy'] }
        : { orderBy?: LicenseAssigneeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicenseAssigneeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicenseAssigneeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LicenseAssignee model
   */
  readonly fields: LicenseAssigneeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LicenseAssignee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicenseAssigneeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    license<T extends LicenseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LicenseDefaultArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LicenseAssignee model
   */
  interface LicenseAssigneeFieldRefs {
    readonly licenseId: FieldRef<"LicenseAssignee", 'String'>
    readonly userId: FieldRef<"LicenseAssignee", 'String'>
    readonly role: FieldRef<"LicenseAssignee", 'LicenseAssigneeRole'>
  }
    

  // Custom InputTypes
  /**
   * LicenseAssignee findUnique
   */
  export type LicenseAssigneeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which LicenseAssignee to fetch.
     */
    where: LicenseAssigneeWhereUniqueInput
  }

  /**
   * LicenseAssignee findUniqueOrThrow
   */
  export type LicenseAssigneeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which LicenseAssignee to fetch.
     */
    where: LicenseAssigneeWhereUniqueInput
  }

  /**
   * LicenseAssignee findFirst
   */
  export type LicenseAssigneeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which LicenseAssignee to fetch.
     */
    where?: LicenseAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicenseAssignees to fetch.
     */
    orderBy?: LicenseAssigneeOrderByWithRelationInput | LicenseAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LicenseAssignees.
     */
    cursor?: LicenseAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicenseAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicenseAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LicenseAssignees.
     */
    distinct?: LicenseAssigneeScalarFieldEnum | LicenseAssigneeScalarFieldEnum[]
  }

  /**
   * LicenseAssignee findFirstOrThrow
   */
  export type LicenseAssigneeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which LicenseAssignee to fetch.
     */
    where?: LicenseAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicenseAssignees to fetch.
     */
    orderBy?: LicenseAssigneeOrderByWithRelationInput | LicenseAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LicenseAssignees.
     */
    cursor?: LicenseAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicenseAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicenseAssignees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LicenseAssignees.
     */
    distinct?: LicenseAssigneeScalarFieldEnum | LicenseAssigneeScalarFieldEnum[]
  }

  /**
   * LicenseAssignee findMany
   */
  export type LicenseAssigneeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeInclude<ExtArgs> | null
    /**
     * Filter, which LicenseAssignees to fetch.
     */
    where?: LicenseAssigneeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicenseAssignees to fetch.
     */
    orderBy?: LicenseAssigneeOrderByWithRelationInput | LicenseAssigneeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LicenseAssignees.
     */
    cursor?: LicenseAssigneeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicenseAssignees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicenseAssignees.
     */
    skip?: number
    distinct?: LicenseAssigneeScalarFieldEnum | LicenseAssigneeScalarFieldEnum[]
  }

  /**
   * LicenseAssignee create
   */
  export type LicenseAssigneeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeInclude<ExtArgs> | null
    /**
     * The data needed to create a LicenseAssignee.
     */
    data: XOR<LicenseAssigneeCreateInput, LicenseAssigneeUncheckedCreateInput>
  }

  /**
   * LicenseAssignee createMany
   */
  export type LicenseAssigneeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LicenseAssignees.
     */
    data: LicenseAssigneeCreateManyInput | LicenseAssigneeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LicenseAssignee createManyAndReturn
   */
  export type LicenseAssigneeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * The data used to create many LicenseAssignees.
     */
    data: LicenseAssigneeCreateManyInput | LicenseAssigneeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LicenseAssignee update
   */
  export type LicenseAssigneeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeInclude<ExtArgs> | null
    /**
     * The data needed to update a LicenseAssignee.
     */
    data: XOR<LicenseAssigneeUpdateInput, LicenseAssigneeUncheckedUpdateInput>
    /**
     * Choose, which LicenseAssignee to update.
     */
    where: LicenseAssigneeWhereUniqueInput
  }

  /**
   * LicenseAssignee updateMany
   */
  export type LicenseAssigneeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LicenseAssignees.
     */
    data: XOR<LicenseAssigneeUpdateManyMutationInput, LicenseAssigneeUncheckedUpdateManyInput>
    /**
     * Filter which LicenseAssignees to update
     */
    where?: LicenseAssigneeWhereInput
    /**
     * Limit how many LicenseAssignees to update.
     */
    limit?: number
  }

  /**
   * LicenseAssignee updateManyAndReturn
   */
  export type LicenseAssigneeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * The data used to update LicenseAssignees.
     */
    data: XOR<LicenseAssigneeUpdateManyMutationInput, LicenseAssigneeUncheckedUpdateManyInput>
    /**
     * Filter which LicenseAssignees to update
     */
    where?: LicenseAssigneeWhereInput
    /**
     * Limit how many LicenseAssignees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LicenseAssignee upsert
   */
  export type LicenseAssigneeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeInclude<ExtArgs> | null
    /**
     * The filter to search for the LicenseAssignee to update in case it exists.
     */
    where: LicenseAssigneeWhereUniqueInput
    /**
     * In case the LicenseAssignee found by the `where` argument doesn't exist, create a new LicenseAssignee with this data.
     */
    create: XOR<LicenseAssigneeCreateInput, LicenseAssigneeUncheckedCreateInput>
    /**
     * In case the LicenseAssignee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicenseAssigneeUpdateInput, LicenseAssigneeUncheckedUpdateInput>
  }

  /**
   * LicenseAssignee delete
   */
  export type LicenseAssigneeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeInclude<ExtArgs> | null
    /**
     * Filter which LicenseAssignee to delete.
     */
    where: LicenseAssigneeWhereUniqueInput
  }

  /**
   * LicenseAssignee deleteMany
   */
  export type LicenseAssigneeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LicenseAssignees to delete
     */
    where?: LicenseAssigneeWhereInput
    /**
     * Limit how many LicenseAssignees to delete.
     */
    limit?: number
  }

  /**
   * LicenseAssignee without action
   */
  export type LicenseAssigneeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAssignee
     */
    select?: LicenseAssigneeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAssignee
     */
    omit?: LicenseAssigneeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAssigneeInclude<ExtArgs> | null
  }


  /**
   * Model LicenseHistory
   */

  export type AggregateLicenseHistory = {
    _count: LicenseHistoryCountAggregateOutputType | null
    _min: LicenseHistoryMinAggregateOutputType | null
    _max: LicenseHistoryMaxAggregateOutputType | null
  }

  export type LicenseHistoryMinAggregateOutputType = {
    id: string | null
    licenseId: string | null
    action: string | null
    actorId: string | null
    at: Date | null
  }

  export type LicenseHistoryMaxAggregateOutputType = {
    id: string | null
    licenseId: string | null
    action: string | null
    actorId: string | null
    at: Date | null
  }

  export type LicenseHistoryCountAggregateOutputType = {
    id: number
    licenseId: number
    action: number
    payload: number
    actorId: number
    at: number
    _all: number
  }


  export type LicenseHistoryMinAggregateInputType = {
    id?: true
    licenseId?: true
    action?: true
    actorId?: true
    at?: true
  }

  export type LicenseHistoryMaxAggregateInputType = {
    id?: true
    licenseId?: true
    action?: true
    actorId?: true
    at?: true
  }

  export type LicenseHistoryCountAggregateInputType = {
    id?: true
    licenseId?: true
    action?: true
    payload?: true
    actorId?: true
    at?: true
    _all?: true
  }

  export type LicenseHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LicenseHistory to aggregate.
     */
    where?: LicenseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicenseHistories to fetch.
     */
    orderBy?: LicenseHistoryOrderByWithRelationInput | LicenseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicenseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicenseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicenseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LicenseHistories
    **/
    _count?: true | LicenseHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicenseHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicenseHistoryMaxAggregateInputType
  }

  export type GetLicenseHistoryAggregateType<T extends LicenseHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLicenseHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicenseHistory[P]>
      : GetScalarType<T[P], AggregateLicenseHistory[P]>
  }




  export type LicenseHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseHistoryWhereInput
    orderBy?: LicenseHistoryOrderByWithAggregationInput | LicenseHistoryOrderByWithAggregationInput[]
    by: LicenseHistoryScalarFieldEnum[] | LicenseHistoryScalarFieldEnum
    having?: LicenseHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicenseHistoryCountAggregateInputType | true
    _min?: LicenseHistoryMinAggregateInputType
    _max?: LicenseHistoryMaxAggregateInputType
  }

  export type LicenseHistoryGroupByOutputType = {
    id: string
    licenseId: string
    action: string
    payload: JsonValue | null
    actorId: string | null
    at: Date
    _count: LicenseHistoryCountAggregateOutputType | null
    _min: LicenseHistoryMinAggregateOutputType | null
    _max: LicenseHistoryMaxAggregateOutputType | null
  }

  type GetLicenseHistoryGroupByPayload<T extends LicenseHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicenseHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicenseHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicenseHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], LicenseHistoryGroupByOutputType[P]>
        }
      >
    >


  export type LicenseHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseId?: boolean
    action?: boolean
    payload?: boolean
    actorId?: boolean
    at?: boolean
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["licenseHistory"]>

  export type LicenseHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseId?: boolean
    action?: boolean
    payload?: boolean
    actorId?: boolean
    at?: boolean
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["licenseHistory"]>

  export type LicenseHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseId?: boolean
    action?: boolean
    payload?: boolean
    actorId?: boolean
    at?: boolean
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["licenseHistory"]>

  export type LicenseHistorySelectScalar = {
    id?: boolean
    licenseId?: boolean
    action?: boolean
    payload?: boolean
    actorId?: boolean
    at?: boolean
  }

  export type LicenseHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "licenseId" | "action" | "payload" | "actorId" | "at", ExtArgs["result"]["licenseHistory"]>
  export type LicenseHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }
  export type LicenseHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }
  export type LicenseHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }

  export type $LicenseHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LicenseHistory"
    objects: {
      license: Prisma.$LicensePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      licenseId: string
      action: string
      payload: Prisma.JsonValue | null
      actorId: string | null
      at: Date
    }, ExtArgs["result"]["licenseHistory"]>
    composites: {}
  }

  type LicenseHistoryGetPayload<S extends boolean | null | undefined | LicenseHistoryDefaultArgs> = $Result.GetResult<Prisma.$LicenseHistoryPayload, S>

  type LicenseHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LicenseHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LicenseHistoryCountAggregateInputType | true
    }

  export interface LicenseHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LicenseHistory'], meta: { name: 'LicenseHistory' } }
    /**
     * Find zero or one LicenseHistory that matches the filter.
     * @param {LicenseHistoryFindUniqueArgs} args - Arguments to find a LicenseHistory
     * @example
     * // Get one LicenseHistory
     * const licenseHistory = await prisma.licenseHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicenseHistoryFindUniqueArgs>(args: SelectSubset<T, LicenseHistoryFindUniqueArgs<ExtArgs>>): Prisma__LicenseHistoryClient<$Result.GetResult<Prisma.$LicenseHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LicenseHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LicenseHistoryFindUniqueOrThrowArgs} args - Arguments to find a LicenseHistory
     * @example
     * // Get one LicenseHistory
     * const licenseHistory = await prisma.licenseHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicenseHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, LicenseHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicenseHistoryClient<$Result.GetResult<Prisma.$LicenseHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LicenseHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseHistoryFindFirstArgs} args - Arguments to find a LicenseHistory
     * @example
     * // Get one LicenseHistory
     * const licenseHistory = await prisma.licenseHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicenseHistoryFindFirstArgs>(args?: SelectSubset<T, LicenseHistoryFindFirstArgs<ExtArgs>>): Prisma__LicenseHistoryClient<$Result.GetResult<Prisma.$LicenseHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LicenseHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseHistoryFindFirstOrThrowArgs} args - Arguments to find a LicenseHistory
     * @example
     * // Get one LicenseHistory
     * const licenseHistory = await prisma.licenseHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicenseHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, LicenseHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicenseHistoryClient<$Result.GetResult<Prisma.$LicenseHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LicenseHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LicenseHistories
     * const licenseHistories = await prisma.licenseHistory.findMany()
     * 
     * // Get first 10 LicenseHistories
     * const licenseHistories = await prisma.licenseHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const licenseHistoryWithIdOnly = await prisma.licenseHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LicenseHistoryFindManyArgs>(args?: SelectSubset<T, LicenseHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenseHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LicenseHistory.
     * @param {LicenseHistoryCreateArgs} args - Arguments to create a LicenseHistory.
     * @example
     * // Create one LicenseHistory
     * const LicenseHistory = await prisma.licenseHistory.create({
     *   data: {
     *     // ... data to create a LicenseHistory
     *   }
     * })
     * 
     */
    create<T extends LicenseHistoryCreateArgs>(args: SelectSubset<T, LicenseHistoryCreateArgs<ExtArgs>>): Prisma__LicenseHistoryClient<$Result.GetResult<Prisma.$LicenseHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LicenseHistories.
     * @param {LicenseHistoryCreateManyArgs} args - Arguments to create many LicenseHistories.
     * @example
     * // Create many LicenseHistories
     * const licenseHistory = await prisma.licenseHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicenseHistoryCreateManyArgs>(args?: SelectSubset<T, LicenseHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LicenseHistories and returns the data saved in the database.
     * @param {LicenseHistoryCreateManyAndReturnArgs} args - Arguments to create many LicenseHistories.
     * @example
     * // Create many LicenseHistories
     * const licenseHistory = await prisma.licenseHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LicenseHistories and only return the `id`
     * const licenseHistoryWithIdOnly = await prisma.licenseHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LicenseHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, LicenseHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenseHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LicenseHistory.
     * @param {LicenseHistoryDeleteArgs} args - Arguments to delete one LicenseHistory.
     * @example
     * // Delete one LicenseHistory
     * const LicenseHistory = await prisma.licenseHistory.delete({
     *   where: {
     *     // ... filter to delete one LicenseHistory
     *   }
     * })
     * 
     */
    delete<T extends LicenseHistoryDeleteArgs>(args: SelectSubset<T, LicenseHistoryDeleteArgs<ExtArgs>>): Prisma__LicenseHistoryClient<$Result.GetResult<Prisma.$LicenseHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LicenseHistory.
     * @param {LicenseHistoryUpdateArgs} args - Arguments to update one LicenseHistory.
     * @example
     * // Update one LicenseHistory
     * const licenseHistory = await prisma.licenseHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicenseHistoryUpdateArgs>(args: SelectSubset<T, LicenseHistoryUpdateArgs<ExtArgs>>): Prisma__LicenseHistoryClient<$Result.GetResult<Prisma.$LicenseHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LicenseHistories.
     * @param {LicenseHistoryDeleteManyArgs} args - Arguments to filter LicenseHistories to delete.
     * @example
     * // Delete a few LicenseHistories
     * const { count } = await prisma.licenseHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicenseHistoryDeleteManyArgs>(args?: SelectSubset<T, LicenseHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LicenseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LicenseHistories
     * const licenseHistory = await prisma.licenseHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicenseHistoryUpdateManyArgs>(args: SelectSubset<T, LicenseHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LicenseHistories and returns the data updated in the database.
     * @param {LicenseHistoryUpdateManyAndReturnArgs} args - Arguments to update many LicenseHistories.
     * @example
     * // Update many LicenseHistories
     * const licenseHistory = await prisma.licenseHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LicenseHistories and only return the `id`
     * const licenseHistoryWithIdOnly = await prisma.licenseHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LicenseHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, LicenseHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenseHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LicenseHistory.
     * @param {LicenseHistoryUpsertArgs} args - Arguments to update or create a LicenseHistory.
     * @example
     * // Update or create a LicenseHistory
     * const licenseHistory = await prisma.licenseHistory.upsert({
     *   create: {
     *     // ... data to create a LicenseHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LicenseHistory we want to update
     *   }
     * })
     */
    upsert<T extends LicenseHistoryUpsertArgs>(args: SelectSubset<T, LicenseHistoryUpsertArgs<ExtArgs>>): Prisma__LicenseHistoryClient<$Result.GetResult<Prisma.$LicenseHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LicenseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseHistoryCountArgs} args - Arguments to filter LicenseHistories to count.
     * @example
     * // Count the number of LicenseHistories
     * const count = await prisma.licenseHistory.count({
     *   where: {
     *     // ... the filter for the LicenseHistories we want to count
     *   }
     * })
    **/
    count<T extends LicenseHistoryCountArgs>(
      args?: Subset<T, LicenseHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicenseHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LicenseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicenseHistoryAggregateArgs>(args: Subset<T, LicenseHistoryAggregateArgs>): Prisma.PrismaPromise<GetLicenseHistoryAggregateType<T>>

    /**
     * Group by LicenseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicenseHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicenseHistoryGroupByArgs['orderBy'] }
        : { orderBy?: LicenseHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicenseHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicenseHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LicenseHistory model
   */
  readonly fields: LicenseHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LicenseHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicenseHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    license<T extends LicenseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LicenseDefaultArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LicenseHistory model
   */
  interface LicenseHistoryFieldRefs {
    readonly id: FieldRef<"LicenseHistory", 'String'>
    readonly licenseId: FieldRef<"LicenseHistory", 'String'>
    readonly action: FieldRef<"LicenseHistory", 'String'>
    readonly payload: FieldRef<"LicenseHistory", 'Json'>
    readonly actorId: FieldRef<"LicenseHistory", 'String'>
    readonly at: FieldRef<"LicenseHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LicenseHistory findUnique
   */
  export type LicenseHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LicenseHistory to fetch.
     */
    where: LicenseHistoryWhereUniqueInput
  }

  /**
   * LicenseHistory findUniqueOrThrow
   */
  export type LicenseHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LicenseHistory to fetch.
     */
    where: LicenseHistoryWhereUniqueInput
  }

  /**
   * LicenseHistory findFirst
   */
  export type LicenseHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LicenseHistory to fetch.
     */
    where?: LicenseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicenseHistories to fetch.
     */
    orderBy?: LicenseHistoryOrderByWithRelationInput | LicenseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LicenseHistories.
     */
    cursor?: LicenseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicenseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicenseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LicenseHistories.
     */
    distinct?: LicenseHistoryScalarFieldEnum | LicenseHistoryScalarFieldEnum[]
  }

  /**
   * LicenseHistory findFirstOrThrow
   */
  export type LicenseHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LicenseHistory to fetch.
     */
    where?: LicenseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicenseHistories to fetch.
     */
    orderBy?: LicenseHistoryOrderByWithRelationInput | LicenseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LicenseHistories.
     */
    cursor?: LicenseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicenseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicenseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LicenseHistories.
     */
    distinct?: LicenseHistoryScalarFieldEnum | LicenseHistoryScalarFieldEnum[]
  }

  /**
   * LicenseHistory findMany
   */
  export type LicenseHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LicenseHistories to fetch.
     */
    where?: LicenseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicenseHistories to fetch.
     */
    orderBy?: LicenseHistoryOrderByWithRelationInput | LicenseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LicenseHistories.
     */
    cursor?: LicenseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicenseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicenseHistories.
     */
    skip?: number
    distinct?: LicenseHistoryScalarFieldEnum | LicenseHistoryScalarFieldEnum[]
  }

  /**
   * LicenseHistory create
   */
  export type LicenseHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a LicenseHistory.
     */
    data: XOR<LicenseHistoryCreateInput, LicenseHistoryUncheckedCreateInput>
  }

  /**
   * LicenseHistory createMany
   */
  export type LicenseHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LicenseHistories.
     */
    data: LicenseHistoryCreateManyInput | LicenseHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LicenseHistory createManyAndReturn
   */
  export type LicenseHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many LicenseHistories.
     */
    data: LicenseHistoryCreateManyInput | LicenseHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LicenseHistory update
   */
  export type LicenseHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a LicenseHistory.
     */
    data: XOR<LicenseHistoryUpdateInput, LicenseHistoryUncheckedUpdateInput>
    /**
     * Choose, which LicenseHistory to update.
     */
    where: LicenseHistoryWhereUniqueInput
  }

  /**
   * LicenseHistory updateMany
   */
  export type LicenseHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LicenseHistories.
     */
    data: XOR<LicenseHistoryUpdateManyMutationInput, LicenseHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LicenseHistories to update
     */
    where?: LicenseHistoryWhereInput
    /**
     * Limit how many LicenseHistories to update.
     */
    limit?: number
  }

  /**
   * LicenseHistory updateManyAndReturn
   */
  export type LicenseHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * The data used to update LicenseHistories.
     */
    data: XOR<LicenseHistoryUpdateManyMutationInput, LicenseHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LicenseHistories to update
     */
    where?: LicenseHistoryWhereInput
    /**
     * Limit how many LicenseHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LicenseHistory upsert
   */
  export type LicenseHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the LicenseHistory to update in case it exists.
     */
    where: LicenseHistoryWhereUniqueInput
    /**
     * In case the LicenseHistory found by the `where` argument doesn't exist, create a new LicenseHistory with this data.
     */
    create: XOR<LicenseHistoryCreateInput, LicenseHistoryUncheckedCreateInput>
    /**
     * In case the LicenseHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicenseHistoryUpdateInput, LicenseHistoryUncheckedUpdateInput>
  }

  /**
   * LicenseHistory delete
   */
  export type LicenseHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryInclude<ExtArgs> | null
    /**
     * Filter which LicenseHistory to delete.
     */
    where: LicenseHistoryWhereUniqueInput
  }

  /**
   * LicenseHistory deleteMany
   */
  export type LicenseHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LicenseHistories to delete
     */
    where?: LicenseHistoryWhereInput
    /**
     * Limit how many LicenseHistories to delete.
     */
    limit?: number
  }

  /**
   * LicenseHistory without action
   */
  export type LicenseHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseHistory
     */
    select?: LicenseHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseHistory
     */
    omit?: LicenseHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseHistoryInclude<ExtArgs> | null
  }


  /**
   * Model LicenseAttachment
   */

  export type AggregateLicenseAttachment = {
    _count: LicenseAttachmentCountAggregateOutputType | null
    _avg: LicenseAttachmentAvgAggregateOutputType | null
    _sum: LicenseAttachmentSumAggregateOutputType | null
    _min: LicenseAttachmentMinAggregateOutputType | null
    _max: LicenseAttachmentMaxAggregateOutputType | null
  }

  export type LicenseAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type LicenseAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type LicenseAttachmentMinAggregateOutputType = {
    id: string | null
    licenseId: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    spacesKey: string | null
    cachedUrl: string | null
    uploadedAt: Date | null
  }

  export type LicenseAttachmentMaxAggregateOutputType = {
    id: string | null
    licenseId: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    spacesKey: string | null
    cachedUrl: string | null
    uploadedAt: Date | null
  }

  export type LicenseAttachmentCountAggregateOutputType = {
    id: number
    licenseId: number
    fileName: number
    fileSize: number
    mimeType: number
    spacesKey: number
    cachedUrl: number
    uploadedAt: number
    _all: number
  }


  export type LicenseAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type LicenseAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type LicenseAttachmentMinAggregateInputType = {
    id?: true
    licenseId?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    spacesKey?: true
    cachedUrl?: true
    uploadedAt?: true
  }

  export type LicenseAttachmentMaxAggregateInputType = {
    id?: true
    licenseId?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    spacesKey?: true
    cachedUrl?: true
    uploadedAt?: true
  }

  export type LicenseAttachmentCountAggregateInputType = {
    id?: true
    licenseId?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    spacesKey?: true
    cachedUrl?: true
    uploadedAt?: true
    _all?: true
  }

  export type LicenseAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LicenseAttachment to aggregate.
     */
    where?: LicenseAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicenseAttachments to fetch.
     */
    orderBy?: LicenseAttachmentOrderByWithRelationInput | LicenseAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicenseAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicenseAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicenseAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LicenseAttachments
    **/
    _count?: true | LicenseAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LicenseAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LicenseAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicenseAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicenseAttachmentMaxAggregateInputType
  }

  export type GetLicenseAttachmentAggregateType<T extends LicenseAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateLicenseAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicenseAttachment[P]>
      : GetScalarType<T[P], AggregateLicenseAttachment[P]>
  }




  export type LicenseAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseAttachmentWhereInput
    orderBy?: LicenseAttachmentOrderByWithAggregationInput | LicenseAttachmentOrderByWithAggregationInput[]
    by: LicenseAttachmentScalarFieldEnum[] | LicenseAttachmentScalarFieldEnum
    having?: LicenseAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicenseAttachmentCountAggregateInputType | true
    _avg?: LicenseAttachmentAvgAggregateInputType
    _sum?: LicenseAttachmentSumAggregateInputType
    _min?: LicenseAttachmentMinAggregateInputType
    _max?: LicenseAttachmentMaxAggregateInputType
  }

  export type LicenseAttachmentGroupByOutputType = {
    id: string
    licenseId: string
    fileName: string
    fileSize: number
    mimeType: string
    spacesKey: string
    cachedUrl: string | null
    uploadedAt: Date
    _count: LicenseAttachmentCountAggregateOutputType | null
    _avg: LicenseAttachmentAvgAggregateOutputType | null
    _sum: LicenseAttachmentSumAggregateOutputType | null
    _min: LicenseAttachmentMinAggregateOutputType | null
    _max: LicenseAttachmentMaxAggregateOutputType | null
  }

  type GetLicenseAttachmentGroupByPayload<T extends LicenseAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicenseAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicenseAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicenseAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], LicenseAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type LicenseAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseId?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    spacesKey?: boolean
    cachedUrl?: boolean
    uploadedAt?: boolean
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["licenseAttachment"]>

  export type LicenseAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseId?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    spacesKey?: boolean
    cachedUrl?: boolean
    uploadedAt?: boolean
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["licenseAttachment"]>

  export type LicenseAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseId?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    spacesKey?: boolean
    cachedUrl?: boolean
    uploadedAt?: boolean
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["licenseAttachment"]>

  export type LicenseAttachmentSelectScalar = {
    id?: boolean
    licenseId?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    spacesKey?: boolean
    cachedUrl?: boolean
    uploadedAt?: boolean
  }

  export type LicenseAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "licenseId" | "fileName" | "fileSize" | "mimeType" | "spacesKey" | "cachedUrl" | "uploadedAt", ExtArgs["result"]["licenseAttachment"]>
  export type LicenseAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }
  export type LicenseAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }
  export type LicenseAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }

  export type $LicenseAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LicenseAttachment"
    objects: {
      license: Prisma.$LicensePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      licenseId: string
      fileName: string
      fileSize: number
      mimeType: string
      spacesKey: string
      cachedUrl: string | null
      uploadedAt: Date
    }, ExtArgs["result"]["licenseAttachment"]>
    composites: {}
  }

  type LicenseAttachmentGetPayload<S extends boolean | null | undefined | LicenseAttachmentDefaultArgs> = $Result.GetResult<Prisma.$LicenseAttachmentPayload, S>

  type LicenseAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LicenseAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LicenseAttachmentCountAggregateInputType | true
    }

  export interface LicenseAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LicenseAttachment'], meta: { name: 'LicenseAttachment' } }
    /**
     * Find zero or one LicenseAttachment that matches the filter.
     * @param {LicenseAttachmentFindUniqueArgs} args - Arguments to find a LicenseAttachment
     * @example
     * // Get one LicenseAttachment
     * const licenseAttachment = await prisma.licenseAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicenseAttachmentFindUniqueArgs>(args: SelectSubset<T, LicenseAttachmentFindUniqueArgs<ExtArgs>>): Prisma__LicenseAttachmentClient<$Result.GetResult<Prisma.$LicenseAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LicenseAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LicenseAttachmentFindUniqueOrThrowArgs} args - Arguments to find a LicenseAttachment
     * @example
     * // Get one LicenseAttachment
     * const licenseAttachment = await prisma.licenseAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicenseAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, LicenseAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicenseAttachmentClient<$Result.GetResult<Prisma.$LicenseAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LicenseAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAttachmentFindFirstArgs} args - Arguments to find a LicenseAttachment
     * @example
     * // Get one LicenseAttachment
     * const licenseAttachment = await prisma.licenseAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicenseAttachmentFindFirstArgs>(args?: SelectSubset<T, LicenseAttachmentFindFirstArgs<ExtArgs>>): Prisma__LicenseAttachmentClient<$Result.GetResult<Prisma.$LicenseAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LicenseAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAttachmentFindFirstOrThrowArgs} args - Arguments to find a LicenseAttachment
     * @example
     * // Get one LicenseAttachment
     * const licenseAttachment = await prisma.licenseAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicenseAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, LicenseAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicenseAttachmentClient<$Result.GetResult<Prisma.$LicenseAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LicenseAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LicenseAttachments
     * const licenseAttachments = await prisma.licenseAttachment.findMany()
     * 
     * // Get first 10 LicenseAttachments
     * const licenseAttachments = await prisma.licenseAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const licenseAttachmentWithIdOnly = await prisma.licenseAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LicenseAttachmentFindManyArgs>(args?: SelectSubset<T, LicenseAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenseAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LicenseAttachment.
     * @param {LicenseAttachmentCreateArgs} args - Arguments to create a LicenseAttachment.
     * @example
     * // Create one LicenseAttachment
     * const LicenseAttachment = await prisma.licenseAttachment.create({
     *   data: {
     *     // ... data to create a LicenseAttachment
     *   }
     * })
     * 
     */
    create<T extends LicenseAttachmentCreateArgs>(args: SelectSubset<T, LicenseAttachmentCreateArgs<ExtArgs>>): Prisma__LicenseAttachmentClient<$Result.GetResult<Prisma.$LicenseAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LicenseAttachments.
     * @param {LicenseAttachmentCreateManyArgs} args - Arguments to create many LicenseAttachments.
     * @example
     * // Create many LicenseAttachments
     * const licenseAttachment = await prisma.licenseAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicenseAttachmentCreateManyArgs>(args?: SelectSubset<T, LicenseAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LicenseAttachments and returns the data saved in the database.
     * @param {LicenseAttachmentCreateManyAndReturnArgs} args - Arguments to create many LicenseAttachments.
     * @example
     * // Create many LicenseAttachments
     * const licenseAttachment = await prisma.licenseAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LicenseAttachments and only return the `id`
     * const licenseAttachmentWithIdOnly = await prisma.licenseAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LicenseAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, LicenseAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenseAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LicenseAttachment.
     * @param {LicenseAttachmentDeleteArgs} args - Arguments to delete one LicenseAttachment.
     * @example
     * // Delete one LicenseAttachment
     * const LicenseAttachment = await prisma.licenseAttachment.delete({
     *   where: {
     *     // ... filter to delete one LicenseAttachment
     *   }
     * })
     * 
     */
    delete<T extends LicenseAttachmentDeleteArgs>(args: SelectSubset<T, LicenseAttachmentDeleteArgs<ExtArgs>>): Prisma__LicenseAttachmentClient<$Result.GetResult<Prisma.$LicenseAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LicenseAttachment.
     * @param {LicenseAttachmentUpdateArgs} args - Arguments to update one LicenseAttachment.
     * @example
     * // Update one LicenseAttachment
     * const licenseAttachment = await prisma.licenseAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicenseAttachmentUpdateArgs>(args: SelectSubset<T, LicenseAttachmentUpdateArgs<ExtArgs>>): Prisma__LicenseAttachmentClient<$Result.GetResult<Prisma.$LicenseAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LicenseAttachments.
     * @param {LicenseAttachmentDeleteManyArgs} args - Arguments to filter LicenseAttachments to delete.
     * @example
     * // Delete a few LicenseAttachments
     * const { count } = await prisma.licenseAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicenseAttachmentDeleteManyArgs>(args?: SelectSubset<T, LicenseAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LicenseAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LicenseAttachments
     * const licenseAttachment = await prisma.licenseAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicenseAttachmentUpdateManyArgs>(args: SelectSubset<T, LicenseAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LicenseAttachments and returns the data updated in the database.
     * @param {LicenseAttachmentUpdateManyAndReturnArgs} args - Arguments to update many LicenseAttachments.
     * @example
     * // Update many LicenseAttachments
     * const licenseAttachment = await prisma.licenseAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LicenseAttachments and only return the `id`
     * const licenseAttachmentWithIdOnly = await prisma.licenseAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LicenseAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, LicenseAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenseAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LicenseAttachment.
     * @param {LicenseAttachmentUpsertArgs} args - Arguments to update or create a LicenseAttachment.
     * @example
     * // Update or create a LicenseAttachment
     * const licenseAttachment = await prisma.licenseAttachment.upsert({
     *   create: {
     *     // ... data to create a LicenseAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LicenseAttachment we want to update
     *   }
     * })
     */
    upsert<T extends LicenseAttachmentUpsertArgs>(args: SelectSubset<T, LicenseAttachmentUpsertArgs<ExtArgs>>): Prisma__LicenseAttachmentClient<$Result.GetResult<Prisma.$LicenseAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LicenseAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAttachmentCountArgs} args - Arguments to filter LicenseAttachments to count.
     * @example
     * // Count the number of LicenseAttachments
     * const count = await prisma.licenseAttachment.count({
     *   where: {
     *     // ... the filter for the LicenseAttachments we want to count
     *   }
     * })
    **/
    count<T extends LicenseAttachmentCountArgs>(
      args?: Subset<T, LicenseAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicenseAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LicenseAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicenseAttachmentAggregateArgs>(args: Subset<T, LicenseAttachmentAggregateArgs>): Prisma.PrismaPromise<GetLicenseAttachmentAggregateType<T>>

    /**
     * Group by LicenseAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicenseAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicenseAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: LicenseAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicenseAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicenseAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LicenseAttachment model
   */
  readonly fields: LicenseAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LicenseAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicenseAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    license<T extends LicenseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LicenseDefaultArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LicenseAttachment model
   */
  interface LicenseAttachmentFieldRefs {
    readonly id: FieldRef<"LicenseAttachment", 'String'>
    readonly licenseId: FieldRef<"LicenseAttachment", 'String'>
    readonly fileName: FieldRef<"LicenseAttachment", 'String'>
    readonly fileSize: FieldRef<"LicenseAttachment", 'Int'>
    readonly mimeType: FieldRef<"LicenseAttachment", 'String'>
    readonly spacesKey: FieldRef<"LicenseAttachment", 'String'>
    readonly cachedUrl: FieldRef<"LicenseAttachment", 'String'>
    readonly uploadedAt: FieldRef<"LicenseAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LicenseAttachment findUnique
   */
  export type LicenseAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LicenseAttachment to fetch.
     */
    where: LicenseAttachmentWhereUniqueInput
  }

  /**
   * LicenseAttachment findUniqueOrThrow
   */
  export type LicenseAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LicenseAttachment to fetch.
     */
    where: LicenseAttachmentWhereUniqueInput
  }

  /**
   * LicenseAttachment findFirst
   */
  export type LicenseAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LicenseAttachment to fetch.
     */
    where?: LicenseAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicenseAttachments to fetch.
     */
    orderBy?: LicenseAttachmentOrderByWithRelationInput | LicenseAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LicenseAttachments.
     */
    cursor?: LicenseAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicenseAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicenseAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LicenseAttachments.
     */
    distinct?: LicenseAttachmentScalarFieldEnum | LicenseAttachmentScalarFieldEnum[]
  }

  /**
   * LicenseAttachment findFirstOrThrow
   */
  export type LicenseAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LicenseAttachment to fetch.
     */
    where?: LicenseAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicenseAttachments to fetch.
     */
    orderBy?: LicenseAttachmentOrderByWithRelationInput | LicenseAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LicenseAttachments.
     */
    cursor?: LicenseAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicenseAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicenseAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LicenseAttachments.
     */
    distinct?: LicenseAttachmentScalarFieldEnum | LicenseAttachmentScalarFieldEnum[]
  }

  /**
   * LicenseAttachment findMany
   */
  export type LicenseAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which LicenseAttachments to fetch.
     */
    where?: LicenseAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicenseAttachments to fetch.
     */
    orderBy?: LicenseAttachmentOrderByWithRelationInput | LicenseAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LicenseAttachments.
     */
    cursor?: LicenseAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicenseAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicenseAttachments.
     */
    skip?: number
    distinct?: LicenseAttachmentScalarFieldEnum | LicenseAttachmentScalarFieldEnum[]
  }

  /**
   * LicenseAttachment create
   */
  export type LicenseAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a LicenseAttachment.
     */
    data: XOR<LicenseAttachmentCreateInput, LicenseAttachmentUncheckedCreateInput>
  }

  /**
   * LicenseAttachment createMany
   */
  export type LicenseAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LicenseAttachments.
     */
    data: LicenseAttachmentCreateManyInput | LicenseAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LicenseAttachment createManyAndReturn
   */
  export type LicenseAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many LicenseAttachments.
     */
    data: LicenseAttachmentCreateManyInput | LicenseAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LicenseAttachment update
   */
  export type LicenseAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a LicenseAttachment.
     */
    data: XOR<LicenseAttachmentUpdateInput, LicenseAttachmentUncheckedUpdateInput>
    /**
     * Choose, which LicenseAttachment to update.
     */
    where: LicenseAttachmentWhereUniqueInput
  }

  /**
   * LicenseAttachment updateMany
   */
  export type LicenseAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LicenseAttachments.
     */
    data: XOR<LicenseAttachmentUpdateManyMutationInput, LicenseAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which LicenseAttachments to update
     */
    where?: LicenseAttachmentWhereInput
    /**
     * Limit how many LicenseAttachments to update.
     */
    limit?: number
  }

  /**
   * LicenseAttachment updateManyAndReturn
   */
  export type LicenseAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update LicenseAttachments.
     */
    data: XOR<LicenseAttachmentUpdateManyMutationInput, LicenseAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which LicenseAttachments to update
     */
    where?: LicenseAttachmentWhereInput
    /**
     * Limit how many LicenseAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LicenseAttachment upsert
   */
  export type LicenseAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the LicenseAttachment to update in case it exists.
     */
    where: LicenseAttachmentWhereUniqueInput
    /**
     * In case the LicenseAttachment found by the `where` argument doesn't exist, create a new LicenseAttachment with this data.
     */
    create: XOR<LicenseAttachmentCreateInput, LicenseAttachmentUncheckedCreateInput>
    /**
     * In case the LicenseAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicenseAttachmentUpdateInput, LicenseAttachmentUncheckedUpdateInput>
  }

  /**
   * LicenseAttachment delete
   */
  export type LicenseAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentInclude<ExtArgs> | null
    /**
     * Filter which LicenseAttachment to delete.
     */
    where: LicenseAttachmentWhereUniqueInput
  }

  /**
   * LicenseAttachment deleteMany
   */
  export type LicenseAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LicenseAttachments to delete
     */
    where?: LicenseAttachmentWhereInput
    /**
     * Limit how many LicenseAttachments to delete.
     */
    limit?: number
  }

  /**
   * LicenseAttachment without action
   */
  export type LicenseAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicenseAttachment
     */
    select?: LicenseAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LicenseAttachment
     */
    omit?: LicenseAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledReminder
   */

  export type AggregateScheduledReminder = {
    _count: ScheduledReminderCountAggregateOutputType | null
    _avg: ScheduledReminderAvgAggregateOutputType | null
    _sum: ScheduledReminderSumAggregateOutputType | null
    _min: ScheduledReminderMinAggregateOutputType | null
    _max: ScheduledReminderMaxAggregateOutputType | null
  }

  export type ScheduledReminderAvgAggregateOutputType = {
    offsetDays: number | null
    attempts: number | null
  }

  export type ScheduledReminderSumAggregateOutputType = {
    offsetDays: number | null
    attempts: number | null
  }

  export type ScheduledReminderMinAggregateOutputType = {
    id: string | null
    licenseId: string | null
    orgLocalDay: Date | null
    runAt: Date | null
    offsetDays: number | null
    status: $Enums.ReminderStatus | null
    attempts: number | null
    lastError: string | null
    sentAt: Date | null
  }

  export type ScheduledReminderMaxAggregateOutputType = {
    id: string | null
    licenseId: string | null
    orgLocalDay: Date | null
    runAt: Date | null
    offsetDays: number | null
    status: $Enums.ReminderStatus | null
    attempts: number | null
    lastError: string | null
    sentAt: Date | null
  }

  export type ScheduledReminderCountAggregateOutputType = {
    id: number
    licenseId: number
    orgLocalDay: number
    runAt: number
    offsetDays: number
    status: number
    attempts: number
    lastError: number
    sentAt: number
    meta: number
    _all: number
  }


  export type ScheduledReminderAvgAggregateInputType = {
    offsetDays?: true
    attempts?: true
  }

  export type ScheduledReminderSumAggregateInputType = {
    offsetDays?: true
    attempts?: true
  }

  export type ScheduledReminderMinAggregateInputType = {
    id?: true
    licenseId?: true
    orgLocalDay?: true
    runAt?: true
    offsetDays?: true
    status?: true
    attempts?: true
    lastError?: true
    sentAt?: true
  }

  export type ScheduledReminderMaxAggregateInputType = {
    id?: true
    licenseId?: true
    orgLocalDay?: true
    runAt?: true
    offsetDays?: true
    status?: true
    attempts?: true
    lastError?: true
    sentAt?: true
  }

  export type ScheduledReminderCountAggregateInputType = {
    id?: true
    licenseId?: true
    orgLocalDay?: true
    runAt?: true
    offsetDays?: true
    status?: true
    attempts?: true
    lastError?: true
    sentAt?: true
    meta?: true
    _all?: true
  }

  export type ScheduledReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledReminder to aggregate.
     */
    where?: ScheduledReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReminders to fetch.
     */
    orderBy?: ScheduledReminderOrderByWithRelationInput | ScheduledReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledReminders
    **/
    _count?: true | ScheduledReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduledReminderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduledReminderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledReminderMaxAggregateInputType
  }

  export type GetScheduledReminderAggregateType<T extends ScheduledReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledReminder[P]>
      : GetScalarType<T[P], AggregateScheduledReminder[P]>
  }




  export type ScheduledReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledReminderWhereInput
    orderBy?: ScheduledReminderOrderByWithAggregationInput | ScheduledReminderOrderByWithAggregationInput[]
    by: ScheduledReminderScalarFieldEnum[] | ScheduledReminderScalarFieldEnum
    having?: ScheduledReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledReminderCountAggregateInputType | true
    _avg?: ScheduledReminderAvgAggregateInputType
    _sum?: ScheduledReminderSumAggregateInputType
    _min?: ScheduledReminderMinAggregateInputType
    _max?: ScheduledReminderMaxAggregateInputType
  }

  export type ScheduledReminderGroupByOutputType = {
    id: string
    licenseId: string
    orgLocalDay: Date
    runAt: Date
    offsetDays: number
    status: $Enums.ReminderStatus
    attempts: number
    lastError: string | null
    sentAt: Date | null
    meta: JsonValue | null
    _count: ScheduledReminderCountAggregateOutputType | null
    _avg: ScheduledReminderAvgAggregateOutputType | null
    _sum: ScheduledReminderSumAggregateOutputType | null
    _min: ScheduledReminderMinAggregateOutputType | null
    _max: ScheduledReminderMaxAggregateOutputType | null
  }

  type GetScheduledReminderGroupByPayload<T extends ScheduledReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledReminderGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledReminderGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseId?: boolean
    orgLocalDay?: boolean
    runAt?: boolean
    offsetDays?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    sentAt?: boolean
    meta?: boolean
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledReminder"]>

  export type ScheduledReminderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseId?: boolean
    orgLocalDay?: boolean
    runAt?: boolean
    offsetDays?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    sentAt?: boolean
    meta?: boolean
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledReminder"]>

  export type ScheduledReminderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseId?: boolean
    orgLocalDay?: boolean
    runAt?: boolean
    offsetDays?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    sentAt?: boolean
    meta?: boolean
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledReminder"]>

  export type ScheduledReminderSelectScalar = {
    id?: boolean
    licenseId?: boolean
    orgLocalDay?: boolean
    runAt?: boolean
    offsetDays?: boolean
    status?: boolean
    attempts?: boolean
    lastError?: boolean
    sentAt?: boolean
    meta?: boolean
  }

  export type ScheduledReminderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "licenseId" | "orgLocalDay" | "runAt" | "offsetDays" | "status" | "attempts" | "lastError" | "sentAt" | "meta", ExtArgs["result"]["scheduledReminder"]>
  export type ScheduledReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }
  export type ScheduledReminderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }
  export type ScheduledReminderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    license?: boolean | LicenseDefaultArgs<ExtArgs>
  }

  export type $ScheduledReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledReminder"
    objects: {
      license: Prisma.$LicensePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      licenseId: string
      orgLocalDay: Date
      runAt: Date
      offsetDays: number
      status: $Enums.ReminderStatus
      attempts: number
      lastError: string | null
      sentAt: Date | null
      meta: Prisma.JsonValue | null
    }, ExtArgs["result"]["scheduledReminder"]>
    composites: {}
  }

  type ScheduledReminderGetPayload<S extends boolean | null | undefined | ScheduledReminderDefaultArgs> = $Result.GetResult<Prisma.$ScheduledReminderPayload, S>

  type ScheduledReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduledReminderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduledReminderCountAggregateInputType | true
    }

  export interface ScheduledReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledReminder'], meta: { name: 'ScheduledReminder' } }
    /**
     * Find zero or one ScheduledReminder that matches the filter.
     * @param {ScheduledReminderFindUniqueArgs} args - Arguments to find a ScheduledReminder
     * @example
     * // Get one ScheduledReminder
     * const scheduledReminder = await prisma.scheduledReminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledReminderFindUniqueArgs>(args: SelectSubset<T, ScheduledReminderFindUniqueArgs<ExtArgs>>): Prisma__ScheduledReminderClient<$Result.GetResult<Prisma.$ScheduledReminderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduledReminder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduledReminderFindUniqueOrThrowArgs} args - Arguments to find a ScheduledReminder
     * @example
     * // Get one ScheduledReminder
     * const scheduledReminder = await prisma.scheduledReminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledReminderClient<$Result.GetResult<Prisma.$ScheduledReminderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledReminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReminderFindFirstArgs} args - Arguments to find a ScheduledReminder
     * @example
     * // Get one ScheduledReminder
     * const scheduledReminder = await prisma.scheduledReminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledReminderFindFirstArgs>(args?: SelectSubset<T, ScheduledReminderFindFirstArgs<ExtArgs>>): Prisma__ScheduledReminderClient<$Result.GetResult<Prisma.$ScheduledReminderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledReminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReminderFindFirstOrThrowArgs} args - Arguments to find a ScheduledReminder
     * @example
     * // Get one ScheduledReminder
     * const scheduledReminder = await prisma.scheduledReminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledReminderClient<$Result.GetResult<Prisma.$ScheduledReminderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduledReminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledReminders
     * const scheduledReminders = await prisma.scheduledReminder.findMany()
     * 
     * // Get first 10 ScheduledReminders
     * const scheduledReminders = await prisma.scheduledReminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledReminderWithIdOnly = await prisma.scheduledReminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledReminderFindManyArgs>(args?: SelectSubset<T, ScheduledReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduledReminder.
     * @param {ScheduledReminderCreateArgs} args - Arguments to create a ScheduledReminder.
     * @example
     * // Create one ScheduledReminder
     * const ScheduledReminder = await prisma.scheduledReminder.create({
     *   data: {
     *     // ... data to create a ScheduledReminder
     *   }
     * })
     * 
     */
    create<T extends ScheduledReminderCreateArgs>(args: SelectSubset<T, ScheduledReminderCreateArgs<ExtArgs>>): Prisma__ScheduledReminderClient<$Result.GetResult<Prisma.$ScheduledReminderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduledReminders.
     * @param {ScheduledReminderCreateManyArgs} args - Arguments to create many ScheduledReminders.
     * @example
     * // Create many ScheduledReminders
     * const scheduledReminder = await prisma.scheduledReminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledReminderCreateManyArgs>(args?: SelectSubset<T, ScheduledReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledReminders and returns the data saved in the database.
     * @param {ScheduledReminderCreateManyAndReturnArgs} args - Arguments to create many ScheduledReminders.
     * @example
     * // Create many ScheduledReminders
     * const scheduledReminder = await prisma.scheduledReminder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledReminders and only return the `id`
     * const scheduledReminderWithIdOnly = await prisma.scheduledReminder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledReminderCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledReminderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReminderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduledReminder.
     * @param {ScheduledReminderDeleteArgs} args - Arguments to delete one ScheduledReminder.
     * @example
     * // Delete one ScheduledReminder
     * const ScheduledReminder = await prisma.scheduledReminder.delete({
     *   where: {
     *     // ... filter to delete one ScheduledReminder
     *   }
     * })
     * 
     */
    delete<T extends ScheduledReminderDeleteArgs>(args: SelectSubset<T, ScheduledReminderDeleteArgs<ExtArgs>>): Prisma__ScheduledReminderClient<$Result.GetResult<Prisma.$ScheduledReminderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduledReminder.
     * @param {ScheduledReminderUpdateArgs} args - Arguments to update one ScheduledReminder.
     * @example
     * // Update one ScheduledReminder
     * const scheduledReminder = await prisma.scheduledReminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledReminderUpdateArgs>(args: SelectSubset<T, ScheduledReminderUpdateArgs<ExtArgs>>): Prisma__ScheduledReminderClient<$Result.GetResult<Prisma.$ScheduledReminderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduledReminders.
     * @param {ScheduledReminderDeleteManyArgs} args - Arguments to filter ScheduledReminders to delete.
     * @example
     * // Delete a few ScheduledReminders
     * const { count } = await prisma.scheduledReminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledReminderDeleteManyArgs>(args?: SelectSubset<T, ScheduledReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledReminders
     * const scheduledReminder = await prisma.scheduledReminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledReminderUpdateManyArgs>(args: SelectSubset<T, ScheduledReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledReminders and returns the data updated in the database.
     * @param {ScheduledReminderUpdateManyAndReturnArgs} args - Arguments to update many ScheduledReminders.
     * @example
     * // Update many ScheduledReminders
     * const scheduledReminder = await prisma.scheduledReminder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduledReminders and only return the `id`
     * const scheduledReminderWithIdOnly = await prisma.scheduledReminder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduledReminderUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduledReminderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledReminderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduledReminder.
     * @param {ScheduledReminderUpsertArgs} args - Arguments to update or create a ScheduledReminder.
     * @example
     * // Update or create a ScheduledReminder
     * const scheduledReminder = await prisma.scheduledReminder.upsert({
     *   create: {
     *     // ... data to create a ScheduledReminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledReminder we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledReminderUpsertArgs>(args: SelectSubset<T, ScheduledReminderUpsertArgs<ExtArgs>>): Prisma__ScheduledReminderClient<$Result.GetResult<Prisma.$ScheduledReminderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduledReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReminderCountArgs} args - Arguments to filter ScheduledReminders to count.
     * @example
     * // Count the number of ScheduledReminders
     * const count = await prisma.scheduledReminder.count({
     *   where: {
     *     // ... the filter for the ScheduledReminders we want to count
     *   }
     * })
    **/
    count<T extends ScheduledReminderCountArgs>(
      args?: Subset<T, ScheduledReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledReminderAggregateArgs>(args: Subset<T, ScheduledReminderAggregateArgs>): Prisma.PrismaPromise<GetScheduledReminderAggregateType<T>>

    /**
     * Group by ScheduledReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledReminderGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledReminder model
   */
  readonly fields: ScheduledReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledReminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    license<T extends LicenseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LicenseDefaultArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledReminder model
   */
  interface ScheduledReminderFieldRefs {
    readonly id: FieldRef<"ScheduledReminder", 'String'>
    readonly licenseId: FieldRef<"ScheduledReminder", 'String'>
    readonly orgLocalDay: FieldRef<"ScheduledReminder", 'DateTime'>
    readonly runAt: FieldRef<"ScheduledReminder", 'DateTime'>
    readonly offsetDays: FieldRef<"ScheduledReminder", 'Int'>
    readonly status: FieldRef<"ScheduledReminder", 'ReminderStatus'>
    readonly attempts: FieldRef<"ScheduledReminder", 'Int'>
    readonly lastError: FieldRef<"ScheduledReminder", 'String'>
    readonly sentAt: FieldRef<"ScheduledReminder", 'DateTime'>
    readonly meta: FieldRef<"ScheduledReminder", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledReminder findUnique
   */
  export type ScheduledReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReminder to fetch.
     */
    where: ScheduledReminderWhereUniqueInput
  }

  /**
   * ScheduledReminder findUniqueOrThrow
   */
  export type ScheduledReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReminder to fetch.
     */
    where: ScheduledReminderWhereUniqueInput
  }

  /**
   * ScheduledReminder findFirst
   */
  export type ScheduledReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReminder to fetch.
     */
    where?: ScheduledReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReminders to fetch.
     */
    orderBy?: ScheduledReminderOrderByWithRelationInput | ScheduledReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledReminders.
     */
    cursor?: ScheduledReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledReminders.
     */
    distinct?: ScheduledReminderScalarFieldEnum | ScheduledReminderScalarFieldEnum[]
  }

  /**
   * ScheduledReminder findFirstOrThrow
   */
  export type ScheduledReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReminder to fetch.
     */
    where?: ScheduledReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReminders to fetch.
     */
    orderBy?: ScheduledReminderOrderByWithRelationInput | ScheduledReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledReminders.
     */
    cursor?: ScheduledReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledReminders.
     */
    distinct?: ScheduledReminderScalarFieldEnum | ScheduledReminderScalarFieldEnum[]
  }

  /**
   * ScheduledReminder findMany
   */
  export type ScheduledReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledReminders to fetch.
     */
    where?: ScheduledReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledReminders to fetch.
     */
    orderBy?: ScheduledReminderOrderByWithRelationInput | ScheduledReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledReminders.
     */
    cursor?: ScheduledReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledReminders.
     */
    skip?: number
    distinct?: ScheduledReminderScalarFieldEnum | ScheduledReminderScalarFieldEnum[]
  }

  /**
   * ScheduledReminder create
   */
  export type ScheduledReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledReminder.
     */
    data: XOR<ScheduledReminderCreateInput, ScheduledReminderUncheckedCreateInput>
  }

  /**
   * ScheduledReminder createMany
   */
  export type ScheduledReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledReminders.
     */
    data: ScheduledReminderCreateManyInput | ScheduledReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledReminder createManyAndReturn
   */
  export type ScheduledReminderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduledReminders.
     */
    data: ScheduledReminderCreateManyInput | ScheduledReminderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledReminder update
   */
  export type ScheduledReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledReminder.
     */
    data: XOR<ScheduledReminderUpdateInput, ScheduledReminderUncheckedUpdateInput>
    /**
     * Choose, which ScheduledReminder to update.
     */
    where: ScheduledReminderWhereUniqueInput
  }

  /**
   * ScheduledReminder updateMany
   */
  export type ScheduledReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledReminders.
     */
    data: XOR<ScheduledReminderUpdateManyMutationInput, ScheduledReminderUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledReminders to update
     */
    where?: ScheduledReminderWhereInput
    /**
     * Limit how many ScheduledReminders to update.
     */
    limit?: number
  }

  /**
   * ScheduledReminder updateManyAndReturn
   */
  export type ScheduledReminderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * The data used to update ScheduledReminders.
     */
    data: XOR<ScheduledReminderUpdateManyMutationInput, ScheduledReminderUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledReminders to update
     */
    where?: ScheduledReminderWhereInput
    /**
     * Limit how many ScheduledReminders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledReminder upsert
   */
  export type ScheduledReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledReminder to update in case it exists.
     */
    where: ScheduledReminderWhereUniqueInput
    /**
     * In case the ScheduledReminder found by the `where` argument doesn't exist, create a new ScheduledReminder with this data.
     */
    create: XOR<ScheduledReminderCreateInput, ScheduledReminderUncheckedCreateInput>
    /**
     * In case the ScheduledReminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledReminderUpdateInput, ScheduledReminderUncheckedUpdateInput>
  }

  /**
   * ScheduledReminder delete
   */
  export type ScheduledReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderInclude<ExtArgs> | null
    /**
     * Filter which ScheduledReminder to delete.
     */
    where: ScheduledReminderWhereUniqueInput
  }

  /**
   * ScheduledReminder deleteMany
   */
  export type ScheduledReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledReminders to delete
     */
    where?: ScheduledReminderWhereInput
    /**
     * Limit how many ScheduledReminders to delete.
     */
    limit?: number
  }

  /**
   * ScheduledReminder without action
   */
  export type ScheduledReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledReminder
     */
    select?: ScheduledReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledReminder
     */
    omit?: ScheduledReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledReminderInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    mobile: 'mobile',
    email: 'email',
    gstNumber: 'gstNumber',
    panNumber: 'panNumber',
    address: 'address',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    clientCommunication: 'clientCommunication',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    head: 'head',
    taskId: 'taskId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    clientId: 'clientId',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    dueDate: 'dueDate',
    assignedToId: 'assignedToId',
    priority: 'priority',
    remarks: 'remarks',
    status: 'status',
    recurrenceRule: 'recurrenceRule',
    recurrenceEndDate: 'recurrenceEndDate',
    isRecurring: 'isRecurring',
    lastGeneratedUntil: 'lastGeneratedUntil',
    retainSubtasks: 'retainSubtasks',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientMailSendCount: 'clientMailSendCount'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskCustomFieldScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    name: 'name',
    type: 'type',
    options: 'options',
    createdAt: 'createdAt'
  };

  export type TaskCustomFieldScalarFieldEnum = (typeof TaskCustomFieldScalarFieldEnum)[keyof typeof TaskCustomFieldScalarFieldEnum]


  export const TaskCustomValueScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    fieldId: 'fieldId',
    value: 'value'
  };

  export type TaskCustomValueScalarFieldEnum = (typeof TaskCustomValueScalarFieldEnum)[keyof typeof TaskCustomValueScalarFieldEnum]


  export const TaskOccurrenceScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    dueDate: 'dueDate',
    assignedToId: 'assignedToId',
    priority: 'priority',
    remarks: 'remarks',
    status: 'status',
    occurrenceIndex: 'occurrenceIndex',
    isCompleted: 'isCompleted',
    completedAt: 'completedAt',
    completedBy: 'completedBy',
    completionNote: 'completionNote',
    clientId: 'clientId',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sequentialId: 'sequentialId',
    clientMailSendCount: 'clientMailSendCount',
    startEmailSent: 'startEmailSent',
    startEmailSentAt: 'startEmailSentAt'
  };

  export type TaskOccurrenceScalarFieldEnum = (typeof TaskOccurrenceScalarFieldEnum)[keyof typeof TaskOccurrenceScalarFieldEnum]


  export const TaskAssigneeScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    userId: 'userId'
  };

  export type TaskAssigneeScalarFieldEnum = (typeof TaskAssigneeScalarFieldEnum)[keyof typeof TaskAssigneeScalarFieldEnum]


  export const TaskOccurrenceAssigneeScalarFieldEnum: {
    id: 'id',
    occurrenceId: 'occurrenceId',
    userId: 'userId'
  };

  export type TaskOccurrenceAssigneeScalarFieldEnum = (typeof TaskOccurrenceAssigneeScalarFieldEnum)[keyof typeof TaskOccurrenceAssigneeScalarFieldEnum]


  export const TaskAttachmentScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    key: 'key',
    createdAt: 'createdAt'
  };

  export type TaskAttachmentScalarFieldEnum = (typeof TaskAttachmentScalarFieldEnum)[keyof typeof TaskAttachmentScalarFieldEnum]


  export const TaskOccurrenceAttachmentScalarFieldEnum: {
    id: 'id',
    occurrenceId: 'occurrenceId',
    key: 'key',
    createdAt: 'createdAt'
  };

  export type TaskOccurrenceAttachmentScalarFieldEnum = (typeof TaskOccurrenceAttachmentScalarFieldEnum)[keyof typeof TaskOccurrenceAttachmentScalarFieldEnum]


  export const CompletionLogScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    occurrenceAt: 'occurrenceAt',
    type: 'type',
    completedBy: 'completedBy',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type CompletionLogScalarFieldEnum = (typeof CompletionLogScalarFieldEnum)[keyof typeof CompletionLogScalarFieldEnum]


  export const ReminderScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    occurrenceAt: 'occurrenceAt',
    remindAt: 'remindAt',
    channel: 'channel',
    payload: 'payload',
    sent: 'sent',
    sentAt: 'sentAt',
    createdAt: 'createdAt'
  };

  export type ReminderScalarFieldEnum = (typeof ReminderScalarFieldEnum)[keyof typeof ReminderScalarFieldEnum]


  export const CalendarEntryScalarFieldEnum: {
    id: 'id',
    createdById: 'createdById',
    type: 'type',
    title: 'title',
    description: 'description',
    start: 'start',
    end: 'end',
    allDay: 'allDay',
    freq: 'freq',
    interval: 'interval',
    until: 'until',
    count: 'count',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarEntryScalarFieldEnum = (typeof CalendarEntryScalarFieldEnum)[keyof typeof CalendarEntryScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    recipientId: 'recipientId',
    actorId: 'actorId',
    taskId: 'taskId',
    occurrenceId: 'occurrenceId',
    type: 'type',
    title: 'title',
    body: 'body',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    isGroup: 'isGroup',
    title: 'title',
    createdById: 'createdById',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ConversationMemberScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    userId: 'userId',
    role: 'role'
  };

  export type ConversationMemberScalarFieldEnum = (typeof ConversationMemberScalarFieldEnum)[keyof typeof ConversationMemberScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    body: 'body',
    attachments: 'attachments',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageReadScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    readAt: 'readAt'
  };

  export type MessageReadScalarFieldEnum = (typeof MessageReadScalarFieldEnum)[keyof typeof MessageReadScalarFieldEnum]


  export const DirectoryUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    avatarUrl: 'avatarUrl',
    lastActiveAt: 'lastActiveAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DirectoryUserScalarFieldEnum = (typeof DirectoryUserScalarFieldEnum)[keyof typeof DirectoryUserScalarFieldEnum]


  export const EmailLogScalarFieldEnum: {
    id: 'id',
    occurrenceId: 'occurrenceId',
    taskId: 'taskId',
    recipient: 'recipient',
    subject: 'subject',
    body: 'body',
    provider: 'provider',
    providerMessageId: 'providerMessageId',
    status: 'status',
    error: 'error',
    createdAt: 'createdAt'
  };

  export type EmailLogScalarFieldEnum = (typeof EmailLogScalarFieldEnum)[keyof typeof EmailLogScalarFieldEnum]


  export const LeaveRequestScalarFieldEnum: {
    id: 'id',
    requesterId: 'requesterId',
    requesterName: 'requesterName',
    requesterEmail: 'requesterEmail',
    type: 'type',
    reason: 'reason',
    startDate: 'startDate',
    endDate: 'endDate',
    days: 'days',
    status: 'status',
    approverId: 'approverId',
    adminComment: 'adminComment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


  export const LicenseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    licenseNumber: 'licenseNumber',
    type: 'type',
    holder: 'holder',
    clientId: 'clientId',
    projectId: 'projectId',
    serviceId: 'serviceId',
    url: 'url',
    vendorId: 'vendorId',
    issuedOn: 'issuedOn',
    validFrom: 'validFrom',
    expiresOn: 'expiresOn',
    remindOffsets: 'remindOffsets',
    gracePeriodDays: 'gracePeriodDays',
    muted: 'muted',
    responsibleId: 'responsibleId',
    status: 'status',
    nextReminderAt: 'nextReminderAt',
    lastReminderAt: 'lastReminderAt',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LicenseScalarFieldEnum = (typeof LicenseScalarFieldEnum)[keyof typeof LicenseScalarFieldEnum]


  export const LicenseAssigneeScalarFieldEnum: {
    licenseId: 'licenseId',
    userId: 'userId',
    role: 'role'
  };

  export type LicenseAssigneeScalarFieldEnum = (typeof LicenseAssigneeScalarFieldEnum)[keyof typeof LicenseAssigneeScalarFieldEnum]


  export const LicenseHistoryScalarFieldEnum: {
    id: 'id',
    licenseId: 'licenseId',
    action: 'action',
    payload: 'payload',
    actorId: 'actorId',
    at: 'at'
  };

  export type LicenseHistoryScalarFieldEnum = (typeof LicenseHistoryScalarFieldEnum)[keyof typeof LicenseHistoryScalarFieldEnum]


  export const LicenseAttachmentScalarFieldEnum: {
    id: 'id',
    licenseId: 'licenseId',
    fileName: 'fileName',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    spacesKey: 'spacesKey',
    cachedUrl: 'cachedUrl',
    uploadedAt: 'uploadedAt'
  };

  export type LicenseAttachmentScalarFieldEnum = (typeof LicenseAttachmentScalarFieldEnum)[keyof typeof LicenseAttachmentScalarFieldEnum]


  export const ScheduledReminderScalarFieldEnum: {
    id: 'id',
    licenseId: 'licenseId',
    orgLocalDay: 'orgLocalDay',
    runAt: 'runAt',
    offsetDays: 'offsetDays',
    status: 'status',
    attempts: 'attempts',
    lastError: 'lastError',
    sentAt: 'sentAt',
    meta: 'meta'
  };

  export type ScheduledReminderScalarFieldEnum = (typeof ScheduledReminderScalarFieldEnum)[keyof typeof ScheduledReminderScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ClientStatus'
   */
  export type EnumClientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientStatus'>
    


  /**
   * Reference to a field of type 'ClientStatus[]'
   */
  export type ListEnumClientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'LogType'
   */
  export type EnumLogTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogType'>
    


  /**
   * Reference to a field of type 'LogType[]'
   */
  export type ListEnumLogTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'CalendarEntryType'
   */
  export type EnumCalendarEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarEntryType'>
    


  /**
   * Reference to a field of type 'CalendarEntryType[]'
   */
  export type ListEnumCalendarEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarEntryType[]'>
    


  /**
   * Reference to a field of type 'RecurrenceFreq'
   */
  export type EnumRecurrenceFreqFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurrenceFreq'>
    


  /**
   * Reference to a field of type 'RecurrenceFreq[]'
   */
  export type ListEnumRecurrenceFreqFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurrenceFreq[]'>
    


  /**
   * Reference to a field of type 'EmailStatus'
   */
  export type EnumEmailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailStatus'>
    


  /**
   * Reference to a field of type 'EmailStatus[]'
   */
  export type ListEnumEmailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailStatus[]'>
    


  /**
   * Reference to a field of type 'LeaveType'
   */
  export type EnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType'>
    


  /**
   * Reference to a field of type 'LeaveType[]'
   */
  export type ListEnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'LeaveStatus'
   */
  export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


  /**
   * Reference to a field of type 'LeaveStatus[]'
   */
  export type ListEnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus[]'>
    


  /**
   * Reference to a field of type 'LicenseStatus'
   */
  export type EnumLicenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseStatus'>
    


  /**
   * Reference to a field of type 'LicenseStatus[]'
   */
  export type ListEnumLicenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseStatus[]'>
    


  /**
   * Reference to a field of type 'LicenseAssigneeRole'
   */
  export type EnumLicenseAssigneeRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseAssigneeRole'>
    


  /**
   * Reference to a field of type 'LicenseAssigneeRole[]'
   */
  export type ListEnumLicenseAssigneeRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseAssigneeRole[]'>
    


  /**
   * Reference to a field of type 'ReminderStatus'
   */
  export type EnumReminderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderStatus'>
    


  /**
   * Reference to a field of type 'ReminderStatus[]'
   */
  export type ListEnumReminderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    mobile?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    gstNumber?: StringNullableFilter<"Client"> | string | null
    panNumber?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    state?: StringNullableFilter<"Client"> | string | null
    pincode?: StringNullableFilter<"Client"> | string | null
    clientCommunication?: BoolNullableFilter<"Client"> | boolean | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    status?: EnumClientStatusFilter<"Client"> | $Enums.ClientStatus
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    mobile?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    gstNumber?: SortOrderInput | SortOrder
    panNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    clientCommunication?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    mobile?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    gstNumber?: StringNullableFilter<"Client"> | string | null
    panNumber?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    state?: StringNullableFilter<"Client"> | string | null
    pincode?: StringNullableFilter<"Client"> | string | null
    clientCommunication?: BoolNullableFilter<"Client"> | boolean | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    status?: EnumClientStatusFilter<"Client"> | $Enums.ClientStatus
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    mobile?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    gstNumber?: SortOrderInput | SortOrder
    panNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    clientCommunication?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    mobile?: StringNullableWithAggregatesFilter<"Client"> | string | null
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    gstNumber?: StringNullableWithAggregatesFilter<"Client"> | string | null
    panNumber?: StringNullableWithAggregatesFilter<"Client"> | string | null
    address?: StringNullableWithAggregatesFilter<"Client"> | string | null
    city?: StringNullableWithAggregatesFilter<"Client"> | string | null
    state?: StringNullableWithAggregatesFilter<"Client"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"Client"> | string | null
    clientCommunication?: BoolNullableWithAggregatesFilter<"Client"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    status?: EnumClientStatusWithAggregatesFilter<"Client"> | $Enums.ClientStatus
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    head?: StringNullableFilter<"Project"> | string | null
    taskId?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    tasks?: TaskListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    head?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    head?: StringNullableFilter<"Project"> | string | null
    taskId?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    tasks?: TaskListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    head?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    head?: StringNullableWithAggregatesFilter<"Project"> | string | null
    taskId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    taskId?: IntFilter<"Task"> | number
    clientId?: StringNullableFilter<"Task"> | string | null
    projectId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    startDate?: DateTimeFilter<"Task"> | Date | string
    dueDate?: DateTimeFilter<"Task"> | Date | string
    assignedToId?: StringNullableFilter<"Task"> | string | null
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    remarks?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    recurrenceRule?: StringNullableFilter<"Task"> | string | null
    recurrenceEndDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    isRecurring?: BoolFilter<"Task"> | boolean
    lastGeneratedUntil?: DateTimeNullableFilter<"Task"> | Date | string | null
    retainSubtasks?: BoolFilter<"Task"> | boolean
    createdById?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    clientMailSendCount?: IntFilter<"Task"> | number
    assignees?: TaskAssigneeListRelationFilter
    occurrences?: TaskOccurrenceListRelationFilter
    reminders?: ReminderListRelationFilter
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    attachments?: TaskAttachmentListRelationFilter
    customValues?: TaskCustomValueListRelationFilter
    emailLogs?: EmailLogListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    priority?: SortOrder
    remarks?: SortOrderInput | SortOrder
    status?: SortOrder
    recurrenceRule?: SortOrderInput | SortOrder
    recurrenceEndDate?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    lastGeneratedUntil?: SortOrderInput | SortOrder
    retainSubtasks?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientMailSendCount?: SortOrder
    assignees?: TaskAssigneeOrderByRelationAggregateInput
    occurrences?: TaskOccurrenceOrderByRelationAggregateInput
    reminders?: ReminderOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
    attachments?: TaskAttachmentOrderByRelationAggregateInput
    customValues?: TaskCustomValueOrderByRelationAggregateInput
    emailLogs?: EmailLogOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_taskId?: TaskProjectIdTaskIdCompoundUniqueInput
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    taskId?: IntFilter<"Task"> | number
    clientId?: StringNullableFilter<"Task"> | string | null
    projectId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    startDate?: DateTimeFilter<"Task"> | Date | string
    dueDate?: DateTimeFilter<"Task"> | Date | string
    assignedToId?: StringNullableFilter<"Task"> | string | null
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    remarks?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    recurrenceRule?: StringNullableFilter<"Task"> | string | null
    recurrenceEndDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    isRecurring?: BoolFilter<"Task"> | boolean
    lastGeneratedUntil?: DateTimeNullableFilter<"Task"> | Date | string | null
    retainSubtasks?: BoolFilter<"Task"> | boolean
    createdById?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    clientMailSendCount?: IntFilter<"Task"> | number
    assignees?: TaskAssigneeListRelationFilter
    occurrences?: TaskOccurrenceListRelationFilter
    reminders?: ReminderListRelationFilter
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    attachments?: TaskAttachmentListRelationFilter
    customValues?: TaskCustomValueListRelationFilter
    emailLogs?: EmailLogListRelationFilter
  }, "id" | "projectId_taskId">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    priority?: SortOrder
    remarks?: SortOrderInput | SortOrder
    status?: SortOrder
    recurrenceRule?: SortOrderInput | SortOrder
    recurrenceEndDate?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    lastGeneratedUntil?: SortOrderInput | SortOrder
    retainSubtasks?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientMailSendCount?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    taskId?: IntWithAggregatesFilter<"Task"> | number
    clientId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    assignedToId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    priority?: EnumPriorityWithAggregatesFilter<"Task"> | $Enums.Priority
    remarks?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    recurrenceRule?: StringNullableWithAggregatesFilter<"Task"> | string | null
    recurrenceEndDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    isRecurring?: BoolWithAggregatesFilter<"Task"> | boolean
    lastGeneratedUntil?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    retainSubtasks?: BoolWithAggregatesFilter<"Task"> | boolean
    createdById?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    clientMailSendCount?: IntWithAggregatesFilter<"Task"> | number
  }

  export type TaskCustomFieldWhereInput = {
    AND?: TaskCustomFieldWhereInput | TaskCustomFieldWhereInput[]
    OR?: TaskCustomFieldWhereInput[]
    NOT?: TaskCustomFieldWhereInput | TaskCustomFieldWhereInput[]
    id?: StringFilter<"TaskCustomField"> | string
    orgId?: StringFilter<"TaskCustomField"> | string
    name?: StringFilter<"TaskCustomField"> | string
    type?: StringFilter<"TaskCustomField"> | string
    options?: StringNullableListFilter<"TaskCustomField">
    createdAt?: DateTimeFilter<"TaskCustomField"> | Date | string
    values?: TaskCustomValueListRelationFilter
  }

  export type TaskCustomFieldOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    options?: SortOrder
    createdAt?: SortOrder
    values?: TaskCustomValueOrderByRelationAggregateInput
  }

  export type TaskCustomFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskCustomFieldWhereInput | TaskCustomFieldWhereInput[]
    OR?: TaskCustomFieldWhereInput[]
    NOT?: TaskCustomFieldWhereInput | TaskCustomFieldWhereInput[]
    orgId?: StringFilter<"TaskCustomField"> | string
    name?: StringFilter<"TaskCustomField"> | string
    type?: StringFilter<"TaskCustomField"> | string
    options?: StringNullableListFilter<"TaskCustomField">
    createdAt?: DateTimeFilter<"TaskCustomField"> | Date | string
    values?: TaskCustomValueListRelationFilter
  }, "id">

  export type TaskCustomFieldOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    options?: SortOrder
    createdAt?: SortOrder
    _count?: TaskCustomFieldCountOrderByAggregateInput
    _max?: TaskCustomFieldMaxOrderByAggregateInput
    _min?: TaskCustomFieldMinOrderByAggregateInput
  }

  export type TaskCustomFieldScalarWhereWithAggregatesInput = {
    AND?: TaskCustomFieldScalarWhereWithAggregatesInput | TaskCustomFieldScalarWhereWithAggregatesInput[]
    OR?: TaskCustomFieldScalarWhereWithAggregatesInput[]
    NOT?: TaskCustomFieldScalarWhereWithAggregatesInput | TaskCustomFieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskCustomField"> | string
    orgId?: StringWithAggregatesFilter<"TaskCustomField"> | string
    name?: StringWithAggregatesFilter<"TaskCustomField"> | string
    type?: StringWithAggregatesFilter<"TaskCustomField"> | string
    options?: StringNullableListFilter<"TaskCustomField">
    createdAt?: DateTimeWithAggregatesFilter<"TaskCustomField"> | Date | string
  }

  export type TaskCustomValueWhereInput = {
    AND?: TaskCustomValueWhereInput | TaskCustomValueWhereInput[]
    OR?: TaskCustomValueWhereInput[]
    NOT?: TaskCustomValueWhereInput | TaskCustomValueWhereInput[]
    id?: StringFilter<"TaskCustomValue"> | string
    taskId?: StringFilter<"TaskCustomValue"> | string
    fieldId?: StringFilter<"TaskCustomValue"> | string
    value?: StringFilter<"TaskCustomValue"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    field?: XOR<TaskCustomFieldScalarRelationFilter, TaskCustomFieldWhereInput>
  }

  export type TaskCustomValueOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
    task?: TaskOrderByWithRelationInput
    field?: TaskCustomFieldOrderByWithRelationInput
  }

  export type TaskCustomValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskCustomValueWhereInput | TaskCustomValueWhereInput[]
    OR?: TaskCustomValueWhereInput[]
    NOT?: TaskCustomValueWhereInput | TaskCustomValueWhereInput[]
    taskId?: StringFilter<"TaskCustomValue"> | string
    fieldId?: StringFilter<"TaskCustomValue"> | string
    value?: StringFilter<"TaskCustomValue"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    field?: XOR<TaskCustomFieldScalarRelationFilter, TaskCustomFieldWhereInput>
  }, "id">

  export type TaskCustomValueOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
    _count?: TaskCustomValueCountOrderByAggregateInput
    _max?: TaskCustomValueMaxOrderByAggregateInput
    _min?: TaskCustomValueMinOrderByAggregateInput
  }

  export type TaskCustomValueScalarWhereWithAggregatesInput = {
    AND?: TaskCustomValueScalarWhereWithAggregatesInput | TaskCustomValueScalarWhereWithAggregatesInput[]
    OR?: TaskCustomValueScalarWhereWithAggregatesInput[]
    NOT?: TaskCustomValueScalarWhereWithAggregatesInput | TaskCustomValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskCustomValue"> | string
    taskId?: StringWithAggregatesFilter<"TaskCustomValue"> | string
    fieldId?: StringWithAggregatesFilter<"TaskCustomValue"> | string
    value?: StringWithAggregatesFilter<"TaskCustomValue"> | string
  }

  export type TaskOccurrenceWhereInput = {
    AND?: TaskOccurrenceWhereInput | TaskOccurrenceWhereInput[]
    OR?: TaskOccurrenceWhereInput[]
    NOT?: TaskOccurrenceWhereInput | TaskOccurrenceWhereInput[]
    id?: StringFilter<"TaskOccurrence"> | string
    taskId?: StringFilter<"TaskOccurrence"> | string
    title?: StringFilter<"TaskOccurrence"> | string
    description?: StringNullableFilter<"TaskOccurrence"> | string | null
    startDate?: DateTimeFilter<"TaskOccurrence"> | Date | string
    dueDate?: DateTimeFilter<"TaskOccurrence"> | Date | string
    assignedToId?: StringNullableFilter<"TaskOccurrence"> | string | null
    priority?: EnumPriorityFilter<"TaskOccurrence"> | $Enums.Priority
    remarks?: StringNullableFilter<"TaskOccurrence"> | string | null
    status?: EnumTaskStatusFilter<"TaskOccurrence"> | $Enums.TaskStatus
    occurrenceIndex?: IntFilter<"TaskOccurrence"> | number
    isCompleted?: BoolFilter<"TaskOccurrence"> | boolean
    completedAt?: DateTimeNullableFilter<"TaskOccurrence"> | Date | string | null
    completedBy?: StringNullableFilter<"TaskOccurrence"> | string | null
    completionNote?: StringNullableFilter<"TaskOccurrence"> | string | null
    clientId?: StringNullableFilter<"TaskOccurrence"> | string | null
    projectId?: StringNullableFilter<"TaskOccurrence"> | string | null
    createdAt?: DateTimeFilter<"TaskOccurrence"> | Date | string
    updatedAt?: DateTimeFilter<"TaskOccurrence"> | Date | string
    sequentialId?: IntFilter<"TaskOccurrence"> | number
    clientMailSendCount?: IntFilter<"TaskOccurrence"> | number
    startEmailSent?: BoolFilter<"TaskOccurrence"> | boolean
    startEmailSentAt?: DateTimeNullableFilter<"TaskOccurrence"> | Date | string | null
    assignees?: TaskOccurrenceAssigneeListRelationFilter
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    attachments?: TaskOccurrenceAttachmentListRelationFilter
    emailLogs?: EmailLogListRelationFilter
  }

  export type TaskOccurrenceOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    priority?: SortOrder
    remarks?: SortOrderInput | SortOrder
    status?: SortOrder
    occurrenceIndex?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    completedBy?: SortOrderInput | SortOrder
    completionNote?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sequentialId?: SortOrder
    clientMailSendCount?: SortOrder
    startEmailSent?: SortOrder
    startEmailSentAt?: SortOrderInput | SortOrder
    assignees?: TaskOccurrenceAssigneeOrderByRelationAggregateInput
    task?: TaskOrderByWithRelationInput
    attachments?: TaskOccurrenceAttachmentOrderByRelationAggregateInput
    emailLogs?: EmailLogOrderByRelationAggregateInput
  }

  export type TaskOccurrenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taskId_occurrenceIndex?: TaskOccurrenceTaskIdOccurrenceIndexCompoundUniqueInput
    AND?: TaskOccurrenceWhereInput | TaskOccurrenceWhereInput[]
    OR?: TaskOccurrenceWhereInput[]
    NOT?: TaskOccurrenceWhereInput | TaskOccurrenceWhereInput[]
    taskId?: StringFilter<"TaskOccurrence"> | string
    title?: StringFilter<"TaskOccurrence"> | string
    description?: StringNullableFilter<"TaskOccurrence"> | string | null
    startDate?: DateTimeFilter<"TaskOccurrence"> | Date | string
    dueDate?: DateTimeFilter<"TaskOccurrence"> | Date | string
    assignedToId?: StringNullableFilter<"TaskOccurrence"> | string | null
    priority?: EnumPriorityFilter<"TaskOccurrence"> | $Enums.Priority
    remarks?: StringNullableFilter<"TaskOccurrence"> | string | null
    status?: EnumTaskStatusFilter<"TaskOccurrence"> | $Enums.TaskStatus
    occurrenceIndex?: IntFilter<"TaskOccurrence"> | number
    isCompleted?: BoolFilter<"TaskOccurrence"> | boolean
    completedAt?: DateTimeNullableFilter<"TaskOccurrence"> | Date | string | null
    completedBy?: StringNullableFilter<"TaskOccurrence"> | string | null
    completionNote?: StringNullableFilter<"TaskOccurrence"> | string | null
    clientId?: StringNullableFilter<"TaskOccurrence"> | string | null
    projectId?: StringNullableFilter<"TaskOccurrence"> | string | null
    createdAt?: DateTimeFilter<"TaskOccurrence"> | Date | string
    updatedAt?: DateTimeFilter<"TaskOccurrence"> | Date | string
    sequentialId?: IntFilter<"TaskOccurrence"> | number
    clientMailSendCount?: IntFilter<"TaskOccurrence"> | number
    startEmailSent?: BoolFilter<"TaskOccurrence"> | boolean
    startEmailSentAt?: DateTimeNullableFilter<"TaskOccurrence"> | Date | string | null
    assignees?: TaskOccurrenceAssigneeListRelationFilter
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    attachments?: TaskOccurrenceAttachmentListRelationFilter
    emailLogs?: EmailLogListRelationFilter
  }, "id" | "taskId_occurrenceIndex">

  export type TaskOccurrenceOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    priority?: SortOrder
    remarks?: SortOrderInput | SortOrder
    status?: SortOrder
    occurrenceIndex?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    completedBy?: SortOrderInput | SortOrder
    completionNote?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sequentialId?: SortOrder
    clientMailSendCount?: SortOrder
    startEmailSent?: SortOrder
    startEmailSentAt?: SortOrderInput | SortOrder
    _count?: TaskOccurrenceCountOrderByAggregateInput
    _avg?: TaskOccurrenceAvgOrderByAggregateInput
    _max?: TaskOccurrenceMaxOrderByAggregateInput
    _min?: TaskOccurrenceMinOrderByAggregateInput
    _sum?: TaskOccurrenceSumOrderByAggregateInput
  }

  export type TaskOccurrenceScalarWhereWithAggregatesInput = {
    AND?: TaskOccurrenceScalarWhereWithAggregatesInput | TaskOccurrenceScalarWhereWithAggregatesInput[]
    OR?: TaskOccurrenceScalarWhereWithAggregatesInput[]
    NOT?: TaskOccurrenceScalarWhereWithAggregatesInput | TaskOccurrenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskOccurrence"> | string
    taskId?: StringWithAggregatesFilter<"TaskOccurrence"> | string
    title?: StringWithAggregatesFilter<"TaskOccurrence"> | string
    description?: StringNullableWithAggregatesFilter<"TaskOccurrence"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"TaskOccurrence"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"TaskOccurrence"> | Date | string
    assignedToId?: StringNullableWithAggregatesFilter<"TaskOccurrence"> | string | null
    priority?: EnumPriorityWithAggregatesFilter<"TaskOccurrence"> | $Enums.Priority
    remarks?: StringNullableWithAggregatesFilter<"TaskOccurrence"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"TaskOccurrence"> | $Enums.TaskStatus
    occurrenceIndex?: IntWithAggregatesFilter<"TaskOccurrence"> | number
    isCompleted?: BoolWithAggregatesFilter<"TaskOccurrence"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"TaskOccurrence"> | Date | string | null
    completedBy?: StringNullableWithAggregatesFilter<"TaskOccurrence"> | string | null
    completionNote?: StringNullableWithAggregatesFilter<"TaskOccurrence"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"TaskOccurrence"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"TaskOccurrence"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaskOccurrence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaskOccurrence"> | Date | string
    sequentialId?: IntWithAggregatesFilter<"TaskOccurrence"> | number
    clientMailSendCount?: IntWithAggregatesFilter<"TaskOccurrence"> | number
    startEmailSent?: BoolWithAggregatesFilter<"TaskOccurrence"> | boolean
    startEmailSentAt?: DateTimeNullableWithAggregatesFilter<"TaskOccurrence"> | Date | string | null
  }

  export type TaskAssigneeWhereInput = {
    AND?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    OR?: TaskAssigneeWhereInput[]
    NOT?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    id?: StringFilter<"TaskAssignee"> | string
    taskId?: StringFilter<"TaskAssignee"> | string
    userId?: StringFilter<"TaskAssignee"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskAssigneeOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    task?: TaskOrderByWithRelationInput
  }

  export type TaskAssigneeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taskId_userId?: TaskAssigneeTaskId_userIdCompoundUniqueInput
    AND?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    OR?: TaskAssigneeWhereInput[]
    NOT?: TaskAssigneeWhereInput | TaskAssigneeWhereInput[]
    taskId?: StringFilter<"TaskAssignee"> | string
    userId?: StringFilter<"TaskAssignee"> | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "taskId_userId">

  export type TaskAssigneeOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    _count?: TaskAssigneeCountOrderByAggregateInput
    _max?: TaskAssigneeMaxOrderByAggregateInput
    _min?: TaskAssigneeMinOrderByAggregateInput
  }

  export type TaskAssigneeScalarWhereWithAggregatesInput = {
    AND?: TaskAssigneeScalarWhereWithAggregatesInput | TaskAssigneeScalarWhereWithAggregatesInput[]
    OR?: TaskAssigneeScalarWhereWithAggregatesInput[]
    NOT?: TaskAssigneeScalarWhereWithAggregatesInput | TaskAssigneeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskAssignee"> | string
    taskId?: StringWithAggregatesFilter<"TaskAssignee"> | string
    userId?: StringWithAggregatesFilter<"TaskAssignee"> | string
  }

  export type TaskOccurrenceAssigneeWhereInput = {
    AND?: TaskOccurrenceAssigneeWhereInput | TaskOccurrenceAssigneeWhereInput[]
    OR?: TaskOccurrenceAssigneeWhereInput[]
    NOT?: TaskOccurrenceAssigneeWhereInput | TaskOccurrenceAssigneeWhereInput[]
    id?: StringFilter<"TaskOccurrenceAssignee"> | string
    occurrenceId?: StringFilter<"TaskOccurrenceAssignee"> | string
    userId?: StringFilter<"TaskOccurrenceAssignee"> | string
    occurrence?: XOR<TaskOccurrenceScalarRelationFilter, TaskOccurrenceWhereInput>
  }

  export type TaskOccurrenceAssigneeOrderByWithRelationInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    userId?: SortOrder
    occurrence?: TaskOccurrenceOrderByWithRelationInput
  }

  export type TaskOccurrenceAssigneeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    occurrenceId_userId?: TaskOccurrenceAssigneeOccurrenceId_userIdCompoundUniqueInput
    AND?: TaskOccurrenceAssigneeWhereInput | TaskOccurrenceAssigneeWhereInput[]
    OR?: TaskOccurrenceAssigneeWhereInput[]
    NOT?: TaskOccurrenceAssigneeWhereInput | TaskOccurrenceAssigneeWhereInput[]
    occurrenceId?: StringFilter<"TaskOccurrenceAssignee"> | string
    userId?: StringFilter<"TaskOccurrenceAssignee"> | string
    occurrence?: XOR<TaskOccurrenceScalarRelationFilter, TaskOccurrenceWhereInput>
  }, "id" | "occurrenceId_userId">

  export type TaskOccurrenceAssigneeOrderByWithAggregationInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    userId?: SortOrder
    _count?: TaskOccurrenceAssigneeCountOrderByAggregateInput
    _max?: TaskOccurrenceAssigneeMaxOrderByAggregateInput
    _min?: TaskOccurrenceAssigneeMinOrderByAggregateInput
  }

  export type TaskOccurrenceAssigneeScalarWhereWithAggregatesInput = {
    AND?: TaskOccurrenceAssigneeScalarWhereWithAggregatesInput | TaskOccurrenceAssigneeScalarWhereWithAggregatesInput[]
    OR?: TaskOccurrenceAssigneeScalarWhereWithAggregatesInput[]
    NOT?: TaskOccurrenceAssigneeScalarWhereWithAggregatesInput | TaskOccurrenceAssigneeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskOccurrenceAssignee"> | string
    occurrenceId?: StringWithAggregatesFilter<"TaskOccurrenceAssignee"> | string
    userId?: StringWithAggregatesFilter<"TaskOccurrenceAssignee"> | string
  }

  export type TaskAttachmentWhereInput = {
    AND?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[]
    OR?: TaskAttachmentWhereInput[]
    NOT?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[]
    id?: StringFilter<"TaskAttachment"> | string
    taskId?: StringFilter<"TaskAttachment"> | string
    key?: StringFilter<"TaskAttachment"> | string
    createdAt?: DateTimeFilter<"TaskAttachment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
  }

  export type TaskAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[]
    OR?: TaskAttachmentWhereInput[]
    NOT?: TaskAttachmentWhereInput | TaskAttachmentWhereInput[]
    taskId?: StringFilter<"TaskAttachment"> | string
    key?: StringFilter<"TaskAttachment"> | string
    createdAt?: DateTimeFilter<"TaskAttachment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id">

  export type TaskAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    _count?: TaskAttachmentCountOrderByAggregateInput
    _max?: TaskAttachmentMaxOrderByAggregateInput
    _min?: TaskAttachmentMinOrderByAggregateInput
  }

  export type TaskAttachmentScalarWhereWithAggregatesInput = {
    AND?: TaskAttachmentScalarWhereWithAggregatesInput | TaskAttachmentScalarWhereWithAggregatesInput[]
    OR?: TaskAttachmentScalarWhereWithAggregatesInput[]
    NOT?: TaskAttachmentScalarWhereWithAggregatesInput | TaskAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskAttachment"> | string
    taskId?: StringWithAggregatesFilter<"TaskAttachment"> | string
    key?: StringWithAggregatesFilter<"TaskAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TaskAttachment"> | Date | string
  }

  export type TaskOccurrenceAttachmentWhereInput = {
    AND?: TaskOccurrenceAttachmentWhereInput | TaskOccurrenceAttachmentWhereInput[]
    OR?: TaskOccurrenceAttachmentWhereInput[]
    NOT?: TaskOccurrenceAttachmentWhereInput | TaskOccurrenceAttachmentWhereInput[]
    id?: StringFilter<"TaskOccurrenceAttachment"> | string
    occurrenceId?: StringFilter<"TaskOccurrenceAttachment"> | string
    key?: StringFilter<"TaskOccurrenceAttachment"> | string
    createdAt?: DateTimeFilter<"TaskOccurrenceAttachment"> | Date | string
    occurrence?: XOR<TaskOccurrenceScalarRelationFilter, TaskOccurrenceWhereInput>
  }

  export type TaskOccurrenceAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    occurrence?: TaskOccurrenceOrderByWithRelationInput
  }

  export type TaskOccurrenceAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskOccurrenceAttachmentWhereInput | TaskOccurrenceAttachmentWhereInput[]
    OR?: TaskOccurrenceAttachmentWhereInput[]
    NOT?: TaskOccurrenceAttachmentWhereInput | TaskOccurrenceAttachmentWhereInput[]
    occurrenceId?: StringFilter<"TaskOccurrenceAttachment"> | string
    key?: StringFilter<"TaskOccurrenceAttachment"> | string
    createdAt?: DateTimeFilter<"TaskOccurrenceAttachment"> | Date | string
    occurrence?: XOR<TaskOccurrenceScalarRelationFilter, TaskOccurrenceWhereInput>
  }, "id">

  export type TaskOccurrenceAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    _count?: TaskOccurrenceAttachmentCountOrderByAggregateInput
    _max?: TaskOccurrenceAttachmentMaxOrderByAggregateInput
    _min?: TaskOccurrenceAttachmentMinOrderByAggregateInput
  }

  export type TaskOccurrenceAttachmentScalarWhereWithAggregatesInput = {
    AND?: TaskOccurrenceAttachmentScalarWhereWithAggregatesInput | TaskOccurrenceAttachmentScalarWhereWithAggregatesInput[]
    OR?: TaskOccurrenceAttachmentScalarWhereWithAggregatesInput[]
    NOT?: TaskOccurrenceAttachmentScalarWhereWithAggregatesInput | TaskOccurrenceAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskOccurrenceAttachment"> | string
    occurrenceId?: StringWithAggregatesFilter<"TaskOccurrenceAttachment"> | string
    key?: StringWithAggregatesFilter<"TaskOccurrenceAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TaskOccurrenceAttachment"> | Date | string
  }

  export type CompletionLogWhereInput = {
    AND?: CompletionLogWhereInput | CompletionLogWhereInput[]
    OR?: CompletionLogWhereInput[]
    NOT?: CompletionLogWhereInput | CompletionLogWhereInput[]
    id?: StringFilter<"CompletionLog"> | string
    taskId?: StringFilter<"CompletionLog"> | string
    occurrenceAt?: DateTimeFilter<"CompletionLog"> | Date | string
    type?: EnumLogTypeFilter<"CompletionLog"> | $Enums.LogType
    completedBy?: StringNullableFilter<"CompletionLog"> | string | null
    note?: StringNullableFilter<"CompletionLog"> | string | null
    createdAt?: DateTimeFilter<"CompletionLog"> | Date | string
  }

  export type CompletionLogOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    occurrenceAt?: SortOrder
    type?: SortOrder
    completedBy?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type CompletionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taskId_occurrenceAt?: CompletionLogTaskIdOccurrenceAtCompoundUniqueInput
    AND?: CompletionLogWhereInput | CompletionLogWhereInput[]
    OR?: CompletionLogWhereInput[]
    NOT?: CompletionLogWhereInput | CompletionLogWhereInput[]
    taskId?: StringFilter<"CompletionLog"> | string
    occurrenceAt?: DateTimeFilter<"CompletionLog"> | Date | string
    type?: EnumLogTypeFilter<"CompletionLog"> | $Enums.LogType
    completedBy?: StringNullableFilter<"CompletionLog"> | string | null
    note?: StringNullableFilter<"CompletionLog"> | string | null
    createdAt?: DateTimeFilter<"CompletionLog"> | Date | string
  }, "id" | "taskId_occurrenceAt">

  export type CompletionLogOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    occurrenceAt?: SortOrder
    type?: SortOrder
    completedBy?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CompletionLogCountOrderByAggregateInput
    _max?: CompletionLogMaxOrderByAggregateInput
    _min?: CompletionLogMinOrderByAggregateInput
  }

  export type CompletionLogScalarWhereWithAggregatesInput = {
    AND?: CompletionLogScalarWhereWithAggregatesInput | CompletionLogScalarWhereWithAggregatesInput[]
    OR?: CompletionLogScalarWhereWithAggregatesInput[]
    NOT?: CompletionLogScalarWhereWithAggregatesInput | CompletionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompletionLog"> | string
    taskId?: StringWithAggregatesFilter<"CompletionLog"> | string
    occurrenceAt?: DateTimeWithAggregatesFilter<"CompletionLog"> | Date | string
    type?: EnumLogTypeWithAggregatesFilter<"CompletionLog"> | $Enums.LogType
    completedBy?: StringNullableWithAggregatesFilter<"CompletionLog"> | string | null
    note?: StringNullableWithAggregatesFilter<"CompletionLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompletionLog"> | Date | string
  }

  export type ReminderWhereInput = {
    AND?: ReminderWhereInput | ReminderWhereInput[]
    OR?: ReminderWhereInput[]
    NOT?: ReminderWhereInput | ReminderWhereInput[]
    id?: StringFilter<"Reminder"> | string
    taskId?: StringFilter<"Reminder"> | string
    occurrenceAt?: DateTimeFilter<"Reminder"> | Date | string
    remindAt?: DateTimeFilter<"Reminder"> | Date | string
    channel?: StringNullableFilter<"Reminder"> | string | null
    payload?: JsonNullableFilter<"Reminder">
    sent?: BoolFilter<"Reminder"> | boolean
    sentAt?: DateTimeNullableFilter<"Reminder"> | Date | string | null
    createdAt?: DateTimeFilter<"Reminder"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type ReminderOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    occurrenceAt?: SortOrder
    remindAt?: SortOrder
    channel?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    sent?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
  }

  export type ReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReminderWhereInput | ReminderWhereInput[]
    OR?: ReminderWhereInput[]
    NOT?: ReminderWhereInput | ReminderWhereInput[]
    taskId?: StringFilter<"Reminder"> | string
    occurrenceAt?: DateTimeFilter<"Reminder"> | Date | string
    remindAt?: DateTimeFilter<"Reminder"> | Date | string
    channel?: StringNullableFilter<"Reminder"> | string | null
    payload?: JsonNullableFilter<"Reminder">
    sent?: BoolFilter<"Reminder"> | boolean
    sentAt?: DateTimeNullableFilter<"Reminder"> | Date | string | null
    createdAt?: DateTimeFilter<"Reminder"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id">

  export type ReminderOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    occurrenceAt?: SortOrder
    remindAt?: SortOrder
    channel?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    sent?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReminderCountOrderByAggregateInput
    _max?: ReminderMaxOrderByAggregateInput
    _min?: ReminderMinOrderByAggregateInput
  }

  export type ReminderScalarWhereWithAggregatesInput = {
    AND?: ReminderScalarWhereWithAggregatesInput | ReminderScalarWhereWithAggregatesInput[]
    OR?: ReminderScalarWhereWithAggregatesInput[]
    NOT?: ReminderScalarWhereWithAggregatesInput | ReminderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reminder"> | string
    taskId?: StringWithAggregatesFilter<"Reminder"> | string
    occurrenceAt?: DateTimeWithAggregatesFilter<"Reminder"> | Date | string
    remindAt?: DateTimeWithAggregatesFilter<"Reminder"> | Date | string
    channel?: StringNullableWithAggregatesFilter<"Reminder"> | string | null
    payload?: JsonNullableWithAggregatesFilter<"Reminder">
    sent?: BoolWithAggregatesFilter<"Reminder"> | boolean
    sentAt?: DateTimeNullableWithAggregatesFilter<"Reminder"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Reminder"> | Date | string
  }

  export type CalendarEntryWhereInput = {
    AND?: CalendarEntryWhereInput | CalendarEntryWhereInput[]
    OR?: CalendarEntryWhereInput[]
    NOT?: CalendarEntryWhereInput | CalendarEntryWhereInput[]
    id?: StringFilter<"CalendarEntry"> | string
    createdById?: StringFilter<"CalendarEntry"> | string
    type?: EnumCalendarEntryTypeFilter<"CalendarEntry"> | $Enums.CalendarEntryType
    title?: StringFilter<"CalendarEntry"> | string
    description?: StringNullableFilter<"CalendarEntry"> | string | null
    start?: DateTimeFilter<"CalendarEntry"> | Date | string
    end?: DateTimeNullableFilter<"CalendarEntry"> | Date | string | null
    allDay?: BoolFilter<"CalendarEntry"> | boolean
    freq?: EnumRecurrenceFreqNullableFilter<"CalendarEntry"> | $Enums.RecurrenceFreq | null
    interval?: IntNullableFilter<"CalendarEntry"> | number | null
    until?: DateTimeNullableFilter<"CalendarEntry"> | Date | string | null
    count?: IntNullableFilter<"CalendarEntry"> | number | null
    createdAt?: DateTimeFilter<"CalendarEntry"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEntry"> | Date | string
  }

  export type CalendarEntryOrderByWithRelationInput = {
    id?: SortOrder
    createdById?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    allDay?: SortOrder
    freq?: SortOrderInput | SortOrder
    interval?: SortOrderInput | SortOrder
    until?: SortOrderInput | SortOrder
    count?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CalendarEntryWhereInput | CalendarEntryWhereInput[]
    OR?: CalendarEntryWhereInput[]
    NOT?: CalendarEntryWhereInput | CalendarEntryWhereInput[]
    createdById?: StringFilter<"CalendarEntry"> | string
    type?: EnumCalendarEntryTypeFilter<"CalendarEntry"> | $Enums.CalendarEntryType
    title?: StringFilter<"CalendarEntry"> | string
    description?: StringNullableFilter<"CalendarEntry"> | string | null
    start?: DateTimeFilter<"CalendarEntry"> | Date | string
    end?: DateTimeNullableFilter<"CalendarEntry"> | Date | string | null
    allDay?: BoolFilter<"CalendarEntry"> | boolean
    freq?: EnumRecurrenceFreqNullableFilter<"CalendarEntry"> | $Enums.RecurrenceFreq | null
    interval?: IntNullableFilter<"CalendarEntry"> | number | null
    until?: DateTimeNullableFilter<"CalendarEntry"> | Date | string | null
    count?: IntNullableFilter<"CalendarEntry"> | number | null
    createdAt?: DateTimeFilter<"CalendarEntry"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEntry"> | Date | string
  }, "id">

  export type CalendarEntryOrderByWithAggregationInput = {
    id?: SortOrder
    createdById?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    allDay?: SortOrder
    freq?: SortOrderInput | SortOrder
    interval?: SortOrderInput | SortOrder
    until?: SortOrderInput | SortOrder
    count?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarEntryCountOrderByAggregateInput
    _avg?: CalendarEntryAvgOrderByAggregateInput
    _max?: CalendarEntryMaxOrderByAggregateInput
    _min?: CalendarEntryMinOrderByAggregateInput
    _sum?: CalendarEntrySumOrderByAggregateInput
  }

  export type CalendarEntryScalarWhereWithAggregatesInput = {
    AND?: CalendarEntryScalarWhereWithAggregatesInput | CalendarEntryScalarWhereWithAggregatesInput[]
    OR?: CalendarEntryScalarWhereWithAggregatesInput[]
    NOT?: CalendarEntryScalarWhereWithAggregatesInput | CalendarEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarEntry"> | string
    createdById?: StringWithAggregatesFilter<"CalendarEntry"> | string
    type?: EnumCalendarEntryTypeWithAggregatesFilter<"CalendarEntry"> | $Enums.CalendarEntryType
    title?: StringWithAggregatesFilter<"CalendarEntry"> | string
    description?: StringNullableWithAggregatesFilter<"CalendarEntry"> | string | null
    start?: DateTimeWithAggregatesFilter<"CalendarEntry"> | Date | string
    end?: DateTimeNullableWithAggregatesFilter<"CalendarEntry"> | Date | string | null
    allDay?: BoolWithAggregatesFilter<"CalendarEntry"> | boolean
    freq?: EnumRecurrenceFreqNullableWithAggregatesFilter<"CalendarEntry"> | $Enums.RecurrenceFreq | null
    interval?: IntNullableWithAggregatesFilter<"CalendarEntry"> | number | null
    until?: DateTimeNullableWithAggregatesFilter<"CalendarEntry"> | Date | string | null
    count?: IntNullableWithAggregatesFilter<"CalendarEntry"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CalendarEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarEntry"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    actorId?: StringNullableFilter<"Notification"> | string | null
    taskId?: StringNullableFilter<"Notification"> | string | null
    occurrenceId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    actorId?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    occurrenceId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    recipientId?: StringFilter<"Notification"> | string
    actorId?: StringNullableFilter<"Notification"> | string | null
    taskId?: StringNullableFilter<"Notification"> | string | null
    occurrenceId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    actorId?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    occurrenceId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    recipientId?: StringWithAggregatesFilter<"Notification"> | string
    actorId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    taskId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    occurrenceId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    isGroup?: BoolFilter<"Conversation"> | boolean
    title?: StringNullableFilter<"Conversation"> | string | null
    createdById?: StringFilter<"Conversation"> | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    members?: ConversationMemberListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrderInput | SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    members?: ConversationMemberOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    isGroup?: BoolFilter<"Conversation"> | boolean
    title?: StringNullableFilter<"Conversation"> | string | null
    createdById?: StringFilter<"Conversation"> | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    members?: ConversationMemberListRelationFilter
    messages?: MessageListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrderInput | SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    isGroup?: BoolWithAggregatesFilter<"Conversation"> | boolean
    title?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    createdById?: StringWithAggregatesFilter<"Conversation"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type ConversationMemberWhereInput = {
    AND?: ConversationMemberWhereInput | ConversationMemberWhereInput[]
    OR?: ConversationMemberWhereInput[]
    NOT?: ConversationMemberWhereInput | ConversationMemberWhereInput[]
    id?: StringFilter<"ConversationMember"> | string
    conversationId?: StringFilter<"ConversationMember"> | string
    userId?: StringFilter<"ConversationMember"> | string
    role?: StringNullableFilter<"ConversationMember"> | string | null
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    user?: XOR<DirectoryUserScalarRelationFilter, DirectoryUserWhereInput>
  }

  export type ConversationMemberOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrderInput | SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: DirectoryUserOrderByWithRelationInput
  }

  export type ConversationMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversationId_userId?: ConversationMemberConversationIdUserIdCompoundUniqueInput
    AND?: ConversationMemberWhereInput | ConversationMemberWhereInput[]
    OR?: ConversationMemberWhereInput[]
    NOT?: ConversationMemberWhereInput | ConversationMemberWhereInput[]
    conversationId?: StringFilter<"ConversationMember"> | string
    userId?: StringFilter<"ConversationMember"> | string
    role?: StringNullableFilter<"ConversationMember"> | string | null
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    user?: XOR<DirectoryUserScalarRelationFilter, DirectoryUserWhereInput>
  }, "id" | "conversationId_userId">

  export type ConversationMemberOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrderInput | SortOrder
    _count?: ConversationMemberCountOrderByAggregateInput
    _max?: ConversationMemberMaxOrderByAggregateInput
    _min?: ConversationMemberMinOrderByAggregateInput
  }

  export type ConversationMemberScalarWhereWithAggregatesInput = {
    AND?: ConversationMemberScalarWhereWithAggregatesInput | ConversationMemberScalarWhereWithAggregatesInput[]
    OR?: ConversationMemberScalarWhereWithAggregatesInput[]
    NOT?: ConversationMemberScalarWhereWithAggregatesInput | ConversationMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationMember"> | string
    conversationId?: StringWithAggregatesFilter<"ConversationMember"> | string
    userId?: StringWithAggregatesFilter<"ConversationMember"> | string
    role?: StringNullableWithAggregatesFilter<"ConversationMember"> | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    body?: StringNullableFilter<"Message"> | string | null
    attachments?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<DirectoryUserScalarRelationFilter, DirectoryUserWhereInput>
    reads?: MessageReadListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    body?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: DirectoryUserOrderByWithRelationInput
    reads?: MessageReadOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    body?: StringNullableFilter<"Message"> | string | null
    attachments?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<DirectoryUserScalarRelationFilter, DirectoryUserWhereInput>
    reads?: MessageReadListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    body?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    body?: StringNullableWithAggregatesFilter<"Message"> | string | null
    attachments?: JsonNullableWithAggregatesFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type MessageReadWhereInput = {
    AND?: MessageReadWhereInput | MessageReadWhereInput[]
    OR?: MessageReadWhereInput[]
    NOT?: MessageReadWhereInput | MessageReadWhereInput[]
    id?: StringFilter<"MessageRead"> | string
    messageId?: StringFilter<"MessageRead"> | string
    userId?: StringFilter<"MessageRead"> | string
    readAt?: DateTimeFilter<"MessageRead"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }

  export type MessageReadOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type MessageReadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId?: MessageReadMessageId_userIdCompoundUniqueInput
    AND?: MessageReadWhereInput | MessageReadWhereInput[]
    OR?: MessageReadWhereInput[]
    NOT?: MessageReadWhereInput | MessageReadWhereInput[]
    messageId?: StringFilter<"MessageRead"> | string
    userId?: StringFilter<"MessageRead"> | string
    readAt?: DateTimeFilter<"MessageRead"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }, "id" | "messageId_userId">

  export type MessageReadOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    _count?: MessageReadCountOrderByAggregateInput
    _max?: MessageReadMaxOrderByAggregateInput
    _min?: MessageReadMinOrderByAggregateInput
  }

  export type MessageReadScalarWhereWithAggregatesInput = {
    AND?: MessageReadScalarWhereWithAggregatesInput | MessageReadScalarWhereWithAggregatesInput[]
    OR?: MessageReadScalarWhereWithAggregatesInput[]
    NOT?: MessageReadScalarWhereWithAggregatesInput | MessageReadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageRead"> | string
    messageId?: StringWithAggregatesFilter<"MessageRead"> | string
    userId?: StringWithAggregatesFilter<"MessageRead"> | string
    readAt?: DateTimeWithAggregatesFilter<"MessageRead"> | Date | string
  }

  export type DirectoryUserWhereInput = {
    AND?: DirectoryUserWhereInput | DirectoryUserWhereInput[]
    OR?: DirectoryUserWhereInput[]
    NOT?: DirectoryUserWhereInput | DirectoryUserWhereInput[]
    id?: StringFilter<"DirectoryUser"> | string
    userId?: StringFilter<"DirectoryUser"> | string
    name?: StringFilter<"DirectoryUser"> | string
    avatarUrl?: StringNullableFilter<"DirectoryUser"> | string | null
    lastActiveAt?: DateTimeNullableFilter<"DirectoryUser"> | Date | string | null
    createdAt?: DateTimeFilter<"DirectoryUser"> | Date | string
    updatedAt?: DateTimeFilter<"DirectoryUser"> | Date | string
    members?: ConversationMemberListRelationFilter
    messagesSent?: MessageListRelationFilter
  }

  export type DirectoryUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: ConversationMemberOrderByRelationAggregateInput
    messagesSent?: MessageOrderByRelationAggregateInput
  }

  export type DirectoryUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DirectoryUserWhereInput | DirectoryUserWhereInput[]
    OR?: DirectoryUserWhereInput[]
    NOT?: DirectoryUserWhereInput | DirectoryUserWhereInput[]
    name?: StringFilter<"DirectoryUser"> | string
    avatarUrl?: StringNullableFilter<"DirectoryUser"> | string | null
    lastActiveAt?: DateTimeNullableFilter<"DirectoryUser"> | Date | string | null
    createdAt?: DateTimeFilter<"DirectoryUser"> | Date | string
    updatedAt?: DateTimeFilter<"DirectoryUser"> | Date | string
    members?: ConversationMemberListRelationFilter
    messagesSent?: MessageListRelationFilter
  }, "id" | "userId">

  export type DirectoryUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DirectoryUserCountOrderByAggregateInput
    _max?: DirectoryUserMaxOrderByAggregateInput
    _min?: DirectoryUserMinOrderByAggregateInput
  }

  export type DirectoryUserScalarWhereWithAggregatesInput = {
    AND?: DirectoryUserScalarWhereWithAggregatesInput | DirectoryUserScalarWhereWithAggregatesInput[]
    OR?: DirectoryUserScalarWhereWithAggregatesInput[]
    NOT?: DirectoryUserScalarWhereWithAggregatesInput | DirectoryUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DirectoryUser"> | string
    userId?: StringWithAggregatesFilter<"DirectoryUser"> | string
    name?: StringWithAggregatesFilter<"DirectoryUser"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"DirectoryUser"> | string | null
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"DirectoryUser"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DirectoryUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DirectoryUser"> | Date | string
  }

  export type EmailLogWhereInput = {
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    id?: StringFilter<"EmailLog"> | string
    occurrenceId?: StringNullableFilter<"EmailLog"> | string | null
    taskId?: StringNullableFilter<"EmailLog"> | string | null
    recipient?: StringFilter<"EmailLog"> | string
    subject?: StringNullableFilter<"EmailLog"> | string | null
    body?: StringNullableFilter<"EmailLog"> | string | null
    provider?: StringNullableFilter<"EmailLog"> | string | null
    providerMessageId?: StringNullableFilter<"EmailLog"> | string | null
    status?: EnumEmailStatusFilter<"EmailLog"> | $Enums.EmailStatus
    error?: StringNullableFilter<"EmailLog"> | string | null
    createdAt?: DateTimeFilter<"EmailLog"> | Date | string
    occurrence?: XOR<TaskOccurrenceNullableScalarRelationFilter, TaskOccurrenceWhereInput> | null
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
  }

  export type EmailLogOrderByWithRelationInput = {
    id?: SortOrder
    occurrenceId?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    recipient?: SortOrder
    subject?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    providerMessageId?: SortOrderInput | SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    occurrence?: TaskOccurrenceOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type EmailLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    occurrenceId?: StringNullableFilter<"EmailLog"> | string | null
    taskId?: StringNullableFilter<"EmailLog"> | string | null
    recipient?: StringFilter<"EmailLog"> | string
    subject?: StringNullableFilter<"EmailLog"> | string | null
    body?: StringNullableFilter<"EmailLog"> | string | null
    provider?: StringNullableFilter<"EmailLog"> | string | null
    providerMessageId?: StringNullableFilter<"EmailLog"> | string | null
    status?: EnumEmailStatusFilter<"EmailLog"> | $Enums.EmailStatus
    error?: StringNullableFilter<"EmailLog"> | string | null
    createdAt?: DateTimeFilter<"EmailLog"> | Date | string
    occurrence?: XOR<TaskOccurrenceNullableScalarRelationFilter, TaskOccurrenceWhereInput> | null
    task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null
  }, "id">

  export type EmailLogOrderByWithAggregationInput = {
    id?: SortOrder
    occurrenceId?: SortOrderInput | SortOrder
    taskId?: SortOrderInput | SortOrder
    recipient?: SortOrder
    subject?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    providerMessageId?: SortOrderInput | SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailLogCountOrderByAggregateInput
    _max?: EmailLogMaxOrderByAggregateInput
    _min?: EmailLogMinOrderByAggregateInput
  }

  export type EmailLogScalarWhereWithAggregatesInput = {
    AND?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    OR?: EmailLogScalarWhereWithAggregatesInput[]
    NOT?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailLog"> | string
    occurrenceId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    taskId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    recipient?: StringWithAggregatesFilter<"EmailLog"> | string
    subject?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    body?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    provider?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    providerMessageId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    status?: EnumEmailStatusWithAggregatesFilter<"EmailLog"> | $Enums.EmailStatus
    error?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailLog"> | Date | string
  }

  export type LeaveRequestWhereInput = {
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    requesterId?: StringFilter<"LeaveRequest"> | string
    requesterName?: StringNullableFilter<"LeaveRequest"> | string | null
    requesterEmail?: StringNullableFilter<"LeaveRequest"> | string | null
    type?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    days?: FloatFilter<"LeaveRequest"> | number
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    approverId?: StringNullableFilter<"LeaveRequest"> | string | null
    adminComment?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
  }

  export type LeaveRequestOrderByWithRelationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    requesterName?: SortOrderInput | SortOrder
    requesterEmail?: SortOrderInput | SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    status?: SortOrder
    approverId?: SortOrderInput | SortOrder
    adminComment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    requesterId?: StringFilter<"LeaveRequest"> | string
    requesterName?: StringNullableFilter<"LeaveRequest"> | string | null
    requesterEmail?: StringNullableFilter<"LeaveRequest"> | string | null
    type?: EnumLeaveTypeFilter<"LeaveRequest"> | $Enums.LeaveType
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    days?: FloatFilter<"LeaveRequest"> | number
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    approverId?: StringNullableFilter<"LeaveRequest"> | string | null
    adminComment?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
  }, "id">

  export type LeaveRequestOrderByWithAggregationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    requesterName?: SortOrderInput | SortOrder
    requesterEmail?: SortOrderInput | SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    status?: SortOrder
    approverId?: SortOrderInput | SortOrder
    adminComment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveRequestCountOrderByAggregateInput
    _avg?: LeaveRequestAvgOrderByAggregateInput
    _max?: LeaveRequestMaxOrderByAggregateInput
    _min?: LeaveRequestMinOrderByAggregateInput
    _sum?: LeaveRequestSumOrderByAggregateInput
  }

  export type LeaveRequestScalarWhereWithAggregatesInput = {
    AND?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    OR?: LeaveRequestScalarWhereWithAggregatesInput[]
    NOT?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveRequest"> | string
    requesterId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    requesterName?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    requesterEmail?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    type?: EnumLeaveTypeWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveType
    reason?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    days?: FloatWithAggregatesFilter<"LeaveRequest"> | number
    status?: EnumLeaveStatusWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveStatus
    approverId?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    adminComment?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
  }

  export type LicenseWhereInput = {
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    id?: StringFilter<"License"> | string
    title?: StringFilter<"License"> | string
    licenseNumber?: StringNullableFilter<"License"> | string | null
    type?: StringNullableFilter<"License"> | string | null
    holder?: StringNullableFilter<"License"> | string | null
    clientId?: StringNullableFilter<"License"> | string | null
    projectId?: StringNullableFilter<"License"> | string | null
    serviceId?: StringNullableFilter<"License"> | string | null
    url?: StringNullableFilter<"License"> | string | null
    vendorId?: StringNullableFilter<"License"> | string | null
    issuedOn?: DateTimeNullableFilter<"License"> | Date | string | null
    validFrom?: DateTimeNullableFilter<"License"> | Date | string | null
    expiresOn?: DateTimeFilter<"License"> | Date | string
    remindOffsets?: IntNullableListFilter<"License">
    gracePeriodDays?: IntNullableFilter<"License"> | number | null
    muted?: BoolNullableFilter<"License"> | boolean | null
    responsibleId?: StringNullableFilter<"License"> | string | null
    status?: EnumLicenseStatusNullableFilter<"License"> | $Enums.LicenseStatus | null
    nextReminderAt?: DateTimeNullableFilter<"License"> | Date | string | null
    lastReminderAt?: DateTimeNullableFilter<"License"> | Date | string | null
    createdById?: StringNullableFilter<"License"> | string | null
    createdAt?: DateTimeFilter<"License"> | Date | string
    updatedAt?: DateTimeFilter<"License"> | Date | string
    assignees?: LicenseAssigneeListRelationFilter
    histories?: LicenseHistoryListRelationFilter
    attachments?: LicenseAttachmentListRelationFilter
    scheduledReminders?: ScheduledReminderListRelationFilter
  }

  export type LicenseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    holder?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    issuedOn?: SortOrderInput | SortOrder
    validFrom?: SortOrderInput | SortOrder
    expiresOn?: SortOrder
    remindOffsets?: SortOrder
    gracePeriodDays?: SortOrderInput | SortOrder
    muted?: SortOrderInput | SortOrder
    responsibleId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    nextReminderAt?: SortOrderInput | SortOrder
    lastReminderAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignees?: LicenseAssigneeOrderByRelationAggregateInput
    histories?: LicenseHistoryOrderByRelationAggregateInput
    attachments?: LicenseAttachmentOrderByRelationAggregateInput
    scheduledReminders?: ScheduledReminderOrderByRelationAggregateInput
  }

  export type LicenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    title?: StringFilter<"License"> | string
    licenseNumber?: StringNullableFilter<"License"> | string | null
    type?: StringNullableFilter<"License"> | string | null
    holder?: StringNullableFilter<"License"> | string | null
    clientId?: StringNullableFilter<"License"> | string | null
    projectId?: StringNullableFilter<"License"> | string | null
    serviceId?: StringNullableFilter<"License"> | string | null
    url?: StringNullableFilter<"License"> | string | null
    vendorId?: StringNullableFilter<"License"> | string | null
    issuedOn?: DateTimeNullableFilter<"License"> | Date | string | null
    validFrom?: DateTimeNullableFilter<"License"> | Date | string | null
    expiresOn?: DateTimeFilter<"License"> | Date | string
    remindOffsets?: IntNullableListFilter<"License">
    gracePeriodDays?: IntNullableFilter<"License"> | number | null
    muted?: BoolNullableFilter<"License"> | boolean | null
    responsibleId?: StringNullableFilter<"License"> | string | null
    status?: EnumLicenseStatusNullableFilter<"License"> | $Enums.LicenseStatus | null
    nextReminderAt?: DateTimeNullableFilter<"License"> | Date | string | null
    lastReminderAt?: DateTimeNullableFilter<"License"> | Date | string | null
    createdById?: StringNullableFilter<"License"> | string | null
    createdAt?: DateTimeFilter<"License"> | Date | string
    updatedAt?: DateTimeFilter<"License"> | Date | string
    assignees?: LicenseAssigneeListRelationFilter
    histories?: LicenseHistoryListRelationFilter
    attachments?: LicenseAttachmentListRelationFilter
    scheduledReminders?: ScheduledReminderListRelationFilter
  }, "id">

  export type LicenseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    holder?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    issuedOn?: SortOrderInput | SortOrder
    validFrom?: SortOrderInput | SortOrder
    expiresOn?: SortOrder
    remindOffsets?: SortOrder
    gracePeriodDays?: SortOrderInput | SortOrder
    muted?: SortOrderInput | SortOrder
    responsibleId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    nextReminderAt?: SortOrderInput | SortOrder
    lastReminderAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LicenseCountOrderByAggregateInput
    _avg?: LicenseAvgOrderByAggregateInput
    _max?: LicenseMaxOrderByAggregateInput
    _min?: LicenseMinOrderByAggregateInput
    _sum?: LicenseSumOrderByAggregateInput
  }

  export type LicenseScalarWhereWithAggregatesInput = {
    AND?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    OR?: LicenseScalarWhereWithAggregatesInput[]
    NOT?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"License"> | string
    title?: StringWithAggregatesFilter<"License"> | string
    licenseNumber?: StringNullableWithAggregatesFilter<"License"> | string | null
    type?: StringNullableWithAggregatesFilter<"License"> | string | null
    holder?: StringNullableWithAggregatesFilter<"License"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"License"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"License"> | string | null
    serviceId?: StringNullableWithAggregatesFilter<"License"> | string | null
    url?: StringNullableWithAggregatesFilter<"License"> | string | null
    vendorId?: StringNullableWithAggregatesFilter<"License"> | string | null
    issuedOn?: DateTimeNullableWithAggregatesFilter<"License"> | Date | string | null
    validFrom?: DateTimeNullableWithAggregatesFilter<"License"> | Date | string | null
    expiresOn?: DateTimeWithAggregatesFilter<"License"> | Date | string
    remindOffsets?: IntNullableListFilter<"License">
    gracePeriodDays?: IntNullableWithAggregatesFilter<"License"> | number | null
    muted?: BoolNullableWithAggregatesFilter<"License"> | boolean | null
    responsibleId?: StringNullableWithAggregatesFilter<"License"> | string | null
    status?: EnumLicenseStatusNullableWithAggregatesFilter<"License"> | $Enums.LicenseStatus | null
    nextReminderAt?: DateTimeNullableWithAggregatesFilter<"License"> | Date | string | null
    lastReminderAt?: DateTimeNullableWithAggregatesFilter<"License"> | Date | string | null
    createdById?: StringNullableWithAggregatesFilter<"License"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"License"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"License"> | Date | string
  }

  export type LicenseAssigneeWhereInput = {
    AND?: LicenseAssigneeWhereInput | LicenseAssigneeWhereInput[]
    OR?: LicenseAssigneeWhereInput[]
    NOT?: LicenseAssigneeWhereInput | LicenseAssigneeWhereInput[]
    licenseId?: StringFilter<"LicenseAssignee"> | string
    userId?: StringFilter<"LicenseAssignee"> | string
    role?: EnumLicenseAssigneeRoleFilter<"LicenseAssignee"> | $Enums.LicenseAssigneeRole
    license?: XOR<LicenseScalarRelationFilter, LicenseWhereInput>
  }

  export type LicenseAssigneeOrderByWithRelationInput = {
    licenseId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    license?: LicenseOrderByWithRelationInput
  }

  export type LicenseAssigneeWhereUniqueInput = Prisma.AtLeast<{
    licenseId_userId?: LicenseAssigneeLicenseIdUserIdCompoundUniqueInput
    AND?: LicenseAssigneeWhereInput | LicenseAssigneeWhereInput[]
    OR?: LicenseAssigneeWhereInput[]
    NOT?: LicenseAssigneeWhereInput | LicenseAssigneeWhereInput[]
    licenseId?: StringFilter<"LicenseAssignee"> | string
    userId?: StringFilter<"LicenseAssignee"> | string
    role?: EnumLicenseAssigneeRoleFilter<"LicenseAssignee"> | $Enums.LicenseAssigneeRole
    license?: XOR<LicenseScalarRelationFilter, LicenseWhereInput>
  }, "licenseId_userId">

  export type LicenseAssigneeOrderByWithAggregationInput = {
    licenseId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    _count?: LicenseAssigneeCountOrderByAggregateInput
    _max?: LicenseAssigneeMaxOrderByAggregateInput
    _min?: LicenseAssigneeMinOrderByAggregateInput
  }

  export type LicenseAssigneeScalarWhereWithAggregatesInput = {
    AND?: LicenseAssigneeScalarWhereWithAggregatesInput | LicenseAssigneeScalarWhereWithAggregatesInput[]
    OR?: LicenseAssigneeScalarWhereWithAggregatesInput[]
    NOT?: LicenseAssigneeScalarWhereWithAggregatesInput | LicenseAssigneeScalarWhereWithAggregatesInput[]
    licenseId?: StringWithAggregatesFilter<"LicenseAssignee"> | string
    userId?: StringWithAggregatesFilter<"LicenseAssignee"> | string
    role?: EnumLicenseAssigneeRoleWithAggregatesFilter<"LicenseAssignee"> | $Enums.LicenseAssigneeRole
  }

  export type LicenseHistoryWhereInput = {
    AND?: LicenseHistoryWhereInput | LicenseHistoryWhereInput[]
    OR?: LicenseHistoryWhereInput[]
    NOT?: LicenseHistoryWhereInput | LicenseHistoryWhereInput[]
    id?: StringFilter<"LicenseHistory"> | string
    licenseId?: StringFilter<"LicenseHistory"> | string
    action?: StringFilter<"LicenseHistory"> | string
    payload?: JsonNullableFilter<"LicenseHistory">
    actorId?: StringNullableFilter<"LicenseHistory"> | string | null
    at?: DateTimeFilter<"LicenseHistory"> | Date | string
    license?: XOR<LicenseScalarRelationFilter, LicenseWhereInput>
  }

  export type LicenseHistoryOrderByWithRelationInput = {
    id?: SortOrder
    licenseId?: SortOrder
    action?: SortOrder
    payload?: SortOrderInput | SortOrder
    actorId?: SortOrderInput | SortOrder
    at?: SortOrder
    license?: LicenseOrderByWithRelationInput
  }

  export type LicenseHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LicenseHistoryWhereInput | LicenseHistoryWhereInput[]
    OR?: LicenseHistoryWhereInput[]
    NOT?: LicenseHistoryWhereInput | LicenseHistoryWhereInput[]
    licenseId?: StringFilter<"LicenseHistory"> | string
    action?: StringFilter<"LicenseHistory"> | string
    payload?: JsonNullableFilter<"LicenseHistory">
    actorId?: StringNullableFilter<"LicenseHistory"> | string | null
    at?: DateTimeFilter<"LicenseHistory"> | Date | string
    license?: XOR<LicenseScalarRelationFilter, LicenseWhereInput>
  }, "id">

  export type LicenseHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    licenseId?: SortOrder
    action?: SortOrder
    payload?: SortOrderInput | SortOrder
    actorId?: SortOrderInput | SortOrder
    at?: SortOrder
    _count?: LicenseHistoryCountOrderByAggregateInput
    _max?: LicenseHistoryMaxOrderByAggregateInput
    _min?: LicenseHistoryMinOrderByAggregateInput
  }

  export type LicenseHistoryScalarWhereWithAggregatesInput = {
    AND?: LicenseHistoryScalarWhereWithAggregatesInput | LicenseHistoryScalarWhereWithAggregatesInput[]
    OR?: LicenseHistoryScalarWhereWithAggregatesInput[]
    NOT?: LicenseHistoryScalarWhereWithAggregatesInput | LicenseHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LicenseHistory"> | string
    licenseId?: StringWithAggregatesFilter<"LicenseHistory"> | string
    action?: StringWithAggregatesFilter<"LicenseHistory"> | string
    payload?: JsonNullableWithAggregatesFilter<"LicenseHistory">
    actorId?: StringNullableWithAggregatesFilter<"LicenseHistory"> | string | null
    at?: DateTimeWithAggregatesFilter<"LicenseHistory"> | Date | string
  }

  export type LicenseAttachmentWhereInput = {
    AND?: LicenseAttachmentWhereInput | LicenseAttachmentWhereInput[]
    OR?: LicenseAttachmentWhereInput[]
    NOT?: LicenseAttachmentWhereInput | LicenseAttachmentWhereInput[]
    id?: StringFilter<"LicenseAttachment"> | string
    licenseId?: StringFilter<"LicenseAttachment"> | string
    fileName?: StringFilter<"LicenseAttachment"> | string
    fileSize?: IntFilter<"LicenseAttachment"> | number
    mimeType?: StringFilter<"LicenseAttachment"> | string
    spacesKey?: StringFilter<"LicenseAttachment"> | string
    cachedUrl?: StringNullableFilter<"LicenseAttachment"> | string | null
    uploadedAt?: DateTimeFilter<"LicenseAttachment"> | Date | string
    license?: XOR<LicenseScalarRelationFilter, LicenseWhereInput>
  }

  export type LicenseAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    licenseId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    spacesKey?: SortOrder
    cachedUrl?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    license?: LicenseOrderByWithRelationInput
  }

  export type LicenseAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LicenseAttachmentWhereInput | LicenseAttachmentWhereInput[]
    OR?: LicenseAttachmentWhereInput[]
    NOT?: LicenseAttachmentWhereInput | LicenseAttachmentWhereInput[]
    licenseId?: StringFilter<"LicenseAttachment"> | string
    fileName?: StringFilter<"LicenseAttachment"> | string
    fileSize?: IntFilter<"LicenseAttachment"> | number
    mimeType?: StringFilter<"LicenseAttachment"> | string
    spacesKey?: StringFilter<"LicenseAttachment"> | string
    cachedUrl?: StringNullableFilter<"LicenseAttachment"> | string | null
    uploadedAt?: DateTimeFilter<"LicenseAttachment"> | Date | string
    license?: XOR<LicenseScalarRelationFilter, LicenseWhereInput>
  }, "id">

  export type LicenseAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    licenseId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    spacesKey?: SortOrder
    cachedUrl?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: LicenseAttachmentCountOrderByAggregateInput
    _avg?: LicenseAttachmentAvgOrderByAggregateInput
    _max?: LicenseAttachmentMaxOrderByAggregateInput
    _min?: LicenseAttachmentMinOrderByAggregateInput
    _sum?: LicenseAttachmentSumOrderByAggregateInput
  }

  export type LicenseAttachmentScalarWhereWithAggregatesInput = {
    AND?: LicenseAttachmentScalarWhereWithAggregatesInput | LicenseAttachmentScalarWhereWithAggregatesInput[]
    OR?: LicenseAttachmentScalarWhereWithAggregatesInput[]
    NOT?: LicenseAttachmentScalarWhereWithAggregatesInput | LicenseAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LicenseAttachment"> | string
    licenseId?: StringWithAggregatesFilter<"LicenseAttachment"> | string
    fileName?: StringWithAggregatesFilter<"LicenseAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"LicenseAttachment"> | number
    mimeType?: StringWithAggregatesFilter<"LicenseAttachment"> | string
    spacesKey?: StringWithAggregatesFilter<"LicenseAttachment"> | string
    cachedUrl?: StringNullableWithAggregatesFilter<"LicenseAttachment"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"LicenseAttachment"> | Date | string
  }

  export type ScheduledReminderWhereInput = {
    AND?: ScheduledReminderWhereInput | ScheduledReminderWhereInput[]
    OR?: ScheduledReminderWhereInput[]
    NOT?: ScheduledReminderWhereInput | ScheduledReminderWhereInput[]
    id?: StringFilter<"ScheduledReminder"> | string
    licenseId?: StringFilter<"ScheduledReminder"> | string
    orgLocalDay?: DateTimeFilter<"ScheduledReminder"> | Date | string
    runAt?: DateTimeFilter<"ScheduledReminder"> | Date | string
    offsetDays?: IntFilter<"ScheduledReminder"> | number
    status?: EnumReminderStatusFilter<"ScheduledReminder"> | $Enums.ReminderStatus
    attempts?: IntFilter<"ScheduledReminder"> | number
    lastError?: StringNullableFilter<"ScheduledReminder"> | string | null
    sentAt?: DateTimeNullableFilter<"ScheduledReminder"> | Date | string | null
    meta?: JsonNullableFilter<"ScheduledReminder">
    license?: XOR<LicenseScalarRelationFilter, LicenseWhereInput>
  }

  export type ScheduledReminderOrderByWithRelationInput = {
    id?: SortOrder
    licenseId?: SortOrder
    orgLocalDay?: SortOrder
    runAt?: SortOrder
    offsetDays?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    license?: LicenseOrderByWithRelationInput
  }

  export type ScheduledReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    licenseId_offsetDays?: ScheduledReminderLicenseIdOffsetDaysCompoundUniqueInput
    AND?: ScheduledReminderWhereInput | ScheduledReminderWhereInput[]
    OR?: ScheduledReminderWhereInput[]
    NOT?: ScheduledReminderWhereInput | ScheduledReminderWhereInput[]
    licenseId?: StringFilter<"ScheduledReminder"> | string
    orgLocalDay?: DateTimeFilter<"ScheduledReminder"> | Date | string
    runAt?: DateTimeFilter<"ScheduledReminder"> | Date | string
    offsetDays?: IntFilter<"ScheduledReminder"> | number
    status?: EnumReminderStatusFilter<"ScheduledReminder"> | $Enums.ReminderStatus
    attempts?: IntFilter<"ScheduledReminder"> | number
    lastError?: StringNullableFilter<"ScheduledReminder"> | string | null
    sentAt?: DateTimeNullableFilter<"ScheduledReminder"> | Date | string | null
    meta?: JsonNullableFilter<"ScheduledReminder">
    license?: XOR<LicenseScalarRelationFilter, LicenseWhereInput>
  }, "id" | "licenseId_offsetDays">

  export type ScheduledReminderOrderByWithAggregationInput = {
    id?: SortOrder
    licenseId?: SortOrder
    orgLocalDay?: SortOrder
    runAt?: SortOrder
    offsetDays?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    _count?: ScheduledReminderCountOrderByAggregateInput
    _avg?: ScheduledReminderAvgOrderByAggregateInput
    _max?: ScheduledReminderMaxOrderByAggregateInput
    _min?: ScheduledReminderMinOrderByAggregateInput
    _sum?: ScheduledReminderSumOrderByAggregateInput
  }

  export type ScheduledReminderScalarWhereWithAggregatesInput = {
    AND?: ScheduledReminderScalarWhereWithAggregatesInput | ScheduledReminderScalarWhereWithAggregatesInput[]
    OR?: ScheduledReminderScalarWhereWithAggregatesInput[]
    NOT?: ScheduledReminderScalarWhereWithAggregatesInput | ScheduledReminderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledReminder"> | string
    licenseId?: StringWithAggregatesFilter<"ScheduledReminder"> | string
    orgLocalDay?: DateTimeWithAggregatesFilter<"ScheduledReminder"> | Date | string
    runAt?: DateTimeWithAggregatesFilter<"ScheduledReminder"> | Date | string
    offsetDays?: IntWithAggregatesFilter<"ScheduledReminder"> | number
    status?: EnumReminderStatusWithAggregatesFilter<"ScheduledReminder"> | $Enums.ReminderStatus
    attempts?: IntWithAggregatesFilter<"ScheduledReminder"> | number
    lastError?: StringNullableWithAggregatesFilter<"ScheduledReminder"> | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"ScheduledReminder"> | Date | string | null
    meta?: JsonNullableWithAggregatesFilter<"ScheduledReminder">
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    mobile?: string | null
    email?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    clientCommunication?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.ClientStatus
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name: string
    mobile?: string | null
    email?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    clientCommunication?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.ClientStatus
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    clientCommunication?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    clientCommunication?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
  }

  export type ClientCreateManyInput = {
    id?: string
    name: string
    mobile?: string | null
    email?: string | null
    gstNumber?: string | null
    panNumber?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    clientCommunication?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.ClientStatus
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    clientCommunication?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    clientCommunication?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    head?: string | null
    taskId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    head?: string | null
    taskId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    head?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    head?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    head?: string | null
    taskId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    head?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    head?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    occurrences?: TaskOccurrenceCreateNestedManyWithoutTaskInput
    reminders?: ReminderCreateNestedManyWithoutTaskInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    occurrences?: TaskOccurrenceUncheckedCreateNestedManyWithoutTaskInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    occurrences?: TaskOccurrenceUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUpdateManyWithoutTaskNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    occurrences?: TaskOccurrenceUncheckedUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
  }

  export type TaskCustomFieldCreateInput = {
    id?: string
    orgId: string
    name: string
    type: string
    options?: TaskCustomFieldCreateoptionsInput | string[]
    createdAt?: Date | string
    values?: TaskCustomValueCreateNestedManyWithoutFieldInput
  }

  export type TaskCustomFieldUncheckedCreateInput = {
    id?: string
    orgId: string
    name: string
    type: string
    options?: TaskCustomFieldCreateoptionsInput | string[]
    createdAt?: Date | string
    values?: TaskCustomValueUncheckedCreateNestedManyWithoutFieldInput
  }

  export type TaskCustomFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: TaskCustomFieldUpdateoptionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: TaskCustomValueUpdateManyWithoutFieldNestedInput
  }

  export type TaskCustomFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: TaskCustomFieldUpdateoptionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: TaskCustomValueUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type TaskCustomFieldCreateManyInput = {
    id?: string
    orgId: string
    name: string
    type: string
    options?: TaskCustomFieldCreateoptionsInput | string[]
    createdAt?: Date | string
  }

  export type TaskCustomFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: TaskCustomFieldUpdateoptionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCustomFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: TaskCustomFieldUpdateoptionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCustomValueCreateInput = {
    id?: string
    value: string
    task: TaskCreateNestedOneWithoutCustomValuesInput
    field: TaskCustomFieldCreateNestedOneWithoutValuesInput
  }

  export type TaskCustomValueUncheckedCreateInput = {
    id?: string
    taskId: string
    fieldId: string
    value: string
  }

  export type TaskCustomValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    task?: TaskUpdateOneRequiredWithoutCustomValuesNestedInput
    field?: TaskCustomFieldUpdateOneRequiredWithoutValuesNestedInput
  }

  export type TaskCustomValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCustomValueCreateManyInput = {
    id?: string
    taskId: string
    fieldId: string
    value: string
  }

  export type TaskCustomValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCustomValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TaskOccurrenceCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    completedBy?: string | null
    completionNote?: string | null
    clientId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sequentialId?: number
    clientMailSendCount?: number
    startEmailSent?: boolean
    startEmailSentAt?: Date | string | null
    assignees?: TaskOccurrenceAssigneeCreateNestedManyWithoutOccurrenceInput
    task: TaskCreateNestedOneWithoutOccurrencesInput
    attachments?: TaskOccurrenceAttachmentCreateNestedManyWithoutOccurrenceInput
    emailLogs?: EmailLogCreateNestedManyWithoutOccurrenceInput
  }

  export type TaskOccurrenceUncheckedCreateInput = {
    id?: string
    taskId: string
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    completedBy?: string | null
    completionNote?: string | null
    clientId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sequentialId?: number
    clientMailSendCount?: number
    startEmailSent?: boolean
    startEmailSentAt?: Date | string | null
    assignees?: TaskOccurrenceAssigneeUncheckedCreateNestedManyWithoutOccurrenceInput
    attachments?: TaskOccurrenceAttachmentUncheckedCreateNestedManyWithoutOccurrenceInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutOccurrenceInput
  }

  export type TaskOccurrenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignees?: TaskOccurrenceAssigneeUpdateManyWithoutOccurrenceNestedInput
    task?: TaskUpdateOneRequiredWithoutOccurrencesNestedInput
    attachments?: TaskOccurrenceAttachmentUpdateManyWithoutOccurrenceNestedInput
    emailLogs?: EmailLogUpdateManyWithoutOccurrenceNestedInput
  }

  export type TaskOccurrenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignees?: TaskOccurrenceAssigneeUncheckedUpdateManyWithoutOccurrenceNestedInput
    attachments?: TaskOccurrenceAttachmentUncheckedUpdateManyWithoutOccurrenceNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutOccurrenceNestedInput
  }

  export type TaskOccurrenceCreateManyInput = {
    id?: string
    taskId: string
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    completedBy?: string | null
    completionNote?: string | null
    clientId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sequentialId?: number
    clientMailSendCount?: number
    startEmailSent?: boolean
    startEmailSentAt?: Date | string | null
  }

  export type TaskOccurrenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskOccurrenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskAssigneeCreateInput = {
    id?: string
    userId: string
    task: TaskCreateNestedOneWithoutAssigneesInput
  }

  export type TaskAssigneeUncheckedCreateInput = {
    id?: string
    taskId: string
    userId: string
  }

  export type TaskAssigneeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    task?: TaskUpdateOneRequiredWithoutAssigneesNestedInput
  }

  export type TaskAssigneeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssigneeCreateManyInput = {
    id?: string
    taskId: string
    userId: string
  }

  export type TaskAssigneeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssigneeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskOccurrenceAssigneeCreateInput = {
    id?: string
    userId: string
    occurrence: TaskOccurrenceCreateNestedOneWithoutAssigneesInput
  }

  export type TaskOccurrenceAssigneeUncheckedCreateInput = {
    id?: string
    occurrenceId: string
    userId: string
  }

  export type TaskOccurrenceAssigneeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occurrence?: TaskOccurrenceUpdateOneRequiredWithoutAssigneesNestedInput
  }

  export type TaskOccurrenceAssigneeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskOccurrenceAssigneeCreateManyInput = {
    id?: string
    occurrenceId: string
    userId: string
  }

  export type TaskOccurrenceAssigneeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskOccurrenceAssigneeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAttachmentCreateInput = {
    id?: string
    key: string
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutAttachmentsInput
  }

  export type TaskAttachmentUncheckedCreateInput = {
    id?: string
    taskId: string
    key: string
    createdAt?: Date | string
  }

  export type TaskAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type TaskAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentCreateManyInput = {
    id?: string
    taskId: string
    key: string
    createdAt?: Date | string
  }

  export type TaskAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskOccurrenceAttachmentCreateInput = {
    id?: string
    key: string
    createdAt?: Date | string
    occurrence: TaskOccurrenceCreateNestedOneWithoutAttachmentsInput
  }

  export type TaskOccurrenceAttachmentUncheckedCreateInput = {
    id?: string
    occurrenceId: string
    key: string
    createdAt?: Date | string
  }

  export type TaskOccurrenceAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrence?: TaskOccurrenceUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type TaskOccurrenceAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskOccurrenceAttachmentCreateManyInput = {
    id?: string
    occurrenceId: string
    key: string
    createdAt?: Date | string
  }

  export type TaskOccurrenceAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskOccurrenceAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletionLogCreateInput = {
    id?: string
    taskId: string
    occurrenceAt: Date | string
    type?: $Enums.LogType
    completedBy?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type CompletionLogUncheckedCreateInput = {
    id?: string
    taskId: string
    occurrenceAt: Date | string
    type?: $Enums.LogType
    completedBy?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type CompletionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    occurrenceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    occurrenceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletionLogCreateManyInput = {
    id?: string
    taskId: string
    occurrenceAt: Date | string
    type?: $Enums.LogType
    completedBy?: string | null
    note?: string | null
    createdAt?: Date | string
  }

  export type CompletionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    occurrenceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    occurrenceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderCreateInput = {
    id?: string
    occurrenceAt: Date | string
    remindAt: Date | string
    channel?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: boolean
    sentAt?: Date | string | null
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutRemindersInput
  }

  export type ReminderUncheckedCreateInput = {
    id?: string
    taskId: string
    occurrenceAt: Date | string
    remindAt: Date | string
    channel?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: boolean
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReminderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutRemindersNestedInput
  }

  export type ReminderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    occurrenceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderCreateManyInput = {
    id?: string
    taskId: string
    occurrenceAt: Date | string
    remindAt: Date | string
    channel?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: boolean
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReminderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    occurrenceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEntryCreateInput = {
    id?: string
    createdById: string
    type: $Enums.CalendarEntryType
    title: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    allDay?: boolean
    freq?: $Enums.RecurrenceFreq | null
    interval?: number | null
    until?: Date | string | null
    count?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEntryUncheckedCreateInput = {
    id?: string
    createdById: string
    type: $Enums.CalendarEntryType
    title: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    allDay?: boolean
    freq?: $Enums.RecurrenceFreq | null
    interval?: number | null
    until?: Date | string | null
    count?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    type?: EnumCalendarEntryTypeFieldUpdateOperationsInput | $Enums.CalendarEntryType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allDay?: BoolFieldUpdateOperationsInput | boolean
    freq?: NullableEnumRecurrenceFreqFieldUpdateOperationsInput | $Enums.RecurrenceFreq | null
    interval?: NullableIntFieldUpdateOperationsInput | number | null
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    type?: EnumCalendarEntryTypeFieldUpdateOperationsInput | $Enums.CalendarEntryType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allDay?: BoolFieldUpdateOperationsInput | boolean
    freq?: NullableEnumRecurrenceFreqFieldUpdateOperationsInput | $Enums.RecurrenceFreq | null
    interval?: NullableIntFieldUpdateOperationsInput | number | null
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEntryCreateManyInput = {
    id?: string
    createdById: string
    type: $Enums.CalendarEntryType
    title: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    allDay?: boolean
    freq?: $Enums.RecurrenceFreq | null
    interval?: number | null
    until?: Date | string | null
    count?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    type?: EnumCalendarEntryTypeFieldUpdateOperationsInput | $Enums.CalendarEntryType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allDay?: BoolFieldUpdateOperationsInput | boolean
    freq?: NullableEnumRecurrenceFreqFieldUpdateOperationsInput | $Enums.RecurrenceFreq | null
    interval?: NullableIntFieldUpdateOperationsInput | number | null
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    type?: EnumCalendarEntryTypeFieldUpdateOperationsInput | $Enums.CalendarEntryType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allDay?: BoolFieldUpdateOperationsInput | boolean
    freq?: NullableEnumRecurrenceFreqFieldUpdateOperationsInput | $Enums.RecurrenceFreq | null
    interval?: NullableIntFieldUpdateOperationsInput | number | null
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    taskId?: string | null
    occurrenceId?: string | null
    type: string
    title: string
    body: string
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    taskId?: string | null
    occurrenceId?: string | null
    type: string
    title: string
    body: string
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    occurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    occurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    taskId?: string | null
    occurrenceId?: string | null
    type: string
    title: string
    body: string
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    occurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    occurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById: string
    updatedAt?: Date | string
    createdAt?: Date | string
    members?: ConversationMemberCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById: string
    updatedAt?: Date | string
    createdAt?: Date | string
    members?: ConversationMemberUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConversationMemberUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConversationMemberUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMemberCreateInput = {
    id?: string
    role?: string | null
    conversation: ConversationCreateNestedOneWithoutMembersInput
    user: DirectoryUserCreateNestedOneWithoutMembersInput
  }

  export type ConversationMemberUncheckedCreateInput = {
    id?: string
    conversationId: string
    userId: string
    role?: string | null
  }

  export type ConversationMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    conversation?: ConversationUpdateOneRequiredWithoutMembersNestedInput
    user?: DirectoryUserUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ConversationMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationMemberCreateManyInput = {
    id?: string
    conversationId: string
    userId: string
    role?: string | null
  }

  export type ConversationMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateInput = {
    id?: string
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: DirectoryUserCreateNestedOneWithoutMessagesSentInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: DirectoryUserUpdateOneRequiredWithoutMessagesSentNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadCreateInput = {
    id?: string
    userId: string
    readAt?: Date | string
    message: MessageCreateNestedOneWithoutReadsInput
  }

  export type MessageReadUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReadsNestedInput
  }

  export type MessageReadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectoryUserCreateInput = {
    id?: string
    userId: string
    name: string
    avatarUrl?: string | null
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConversationMemberCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type DirectoryUserUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    avatarUrl?: string | null
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConversationMemberUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type DirectoryUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConversationMemberUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type DirectoryUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConversationMemberUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type DirectoryUserCreateManyInput = {
    id?: string
    userId: string
    name: string
    avatarUrl?: string | null
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectoryUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectoryUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateInput = {
    id?: string
    recipient: string
    subject?: string | null
    body?: string | null
    provider?: string | null
    providerMessageId?: string | null
    status?: $Enums.EmailStatus
    error?: string | null
    createdAt?: Date | string
    occurrence?: TaskOccurrenceCreateNestedOneWithoutEmailLogsInput
    task?: TaskCreateNestedOneWithoutEmailLogsInput
  }

  export type EmailLogUncheckedCreateInput = {
    id?: string
    occurrenceId?: string | null
    taskId?: string | null
    recipient: string
    subject?: string | null
    body?: string | null
    provider?: string | null
    providerMessageId?: string | null
    status?: $Enums.EmailStatus
    error?: string | null
    createdAt?: Date | string
  }

  export type EmailLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrence?: TaskOccurrenceUpdateOneWithoutEmailLogsNestedInput
    task?: TaskUpdateOneWithoutEmailLogsNestedInput
  }

  export type EmailLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateManyInput = {
    id?: string
    occurrenceId?: string | null
    taskId?: string | null
    recipient: string
    subject?: string | null
    body?: string | null
    provider?: string | null
    providerMessageId?: string | null
    status?: $Enums.EmailStatus
    error?: string | null
    createdAt?: Date | string
  }

  export type EmailLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestCreateInput = {
    id?: string
    requesterId: string
    requesterName?: string | null
    requesterEmail?: string | null
    type: $Enums.LeaveType
    reason?: string | null
    startDate: Date | string
    endDate: Date | string
    days: number
    status?: $Enums.LeaveStatus
    approverId?: string | null
    adminComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestUncheckedCreateInput = {
    id?: string
    requesterId: string
    requesterName?: string | null
    requesterEmail?: string | null
    type: $Enums.LeaveType
    reason?: string | null
    startDate: Date | string
    endDate: Date | string
    days: number
    status?: $Enums.LeaveStatus
    approverId?: string | null
    adminComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    requesterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    requesterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestCreateManyInput = {
    id?: string
    requesterId: string
    requesterName?: string | null
    requesterEmail?: string | null
    type: $Enums.LeaveType
    reason?: string | null
    startDate: Date | string
    endDate: Date | string
    days: number
    status?: $Enums.LeaveStatus
    approverId?: string | null
    adminComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    requesterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    requesterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: FloatFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    adminComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseCreateInput = {
    id?: string
    title: string
    licenseNumber?: string | null
    type?: string | null
    holder?: string | null
    clientId?: string | null
    projectId?: string | null
    serviceId?: string | null
    url?: string | null
    vendorId?: string | null
    issuedOn?: Date | string | null
    validFrom?: Date | string | null
    expiresOn: Date | string
    remindOffsets?: LicenseCreateremindOffsetsInput | number[]
    gracePeriodDays?: number | null
    muted?: boolean | null
    responsibleId?: string | null
    status?: $Enums.LicenseStatus | null
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: LicenseAssigneeCreateNestedManyWithoutLicenseInput
    histories?: LicenseHistoryCreateNestedManyWithoutLicenseInput
    attachments?: LicenseAttachmentCreateNestedManyWithoutLicenseInput
    scheduledReminders?: ScheduledReminderCreateNestedManyWithoutLicenseInput
  }

  export type LicenseUncheckedCreateInput = {
    id?: string
    title: string
    licenseNumber?: string | null
    type?: string | null
    holder?: string | null
    clientId?: string | null
    projectId?: string | null
    serviceId?: string | null
    url?: string | null
    vendorId?: string | null
    issuedOn?: Date | string | null
    validFrom?: Date | string | null
    expiresOn: Date | string
    remindOffsets?: LicenseCreateremindOffsetsInput | number[]
    gracePeriodDays?: number | null
    muted?: boolean | null
    responsibleId?: string | null
    status?: $Enums.LicenseStatus | null
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: LicenseAssigneeUncheckedCreateNestedManyWithoutLicenseInput
    histories?: LicenseHistoryUncheckedCreateNestedManyWithoutLicenseInput
    attachments?: LicenseAttachmentUncheckedCreateNestedManyWithoutLicenseInput
    scheduledReminders?: ScheduledReminderUncheckedCreateNestedManyWithoutLicenseInput
  }

  export type LicenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    remindOffsets?: LicenseUpdateremindOffsetsInput | number[]
    gracePeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus | null
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: LicenseAssigneeUpdateManyWithoutLicenseNestedInput
    histories?: LicenseHistoryUpdateManyWithoutLicenseNestedInput
    attachments?: LicenseAttachmentUpdateManyWithoutLicenseNestedInput
    scheduledReminders?: ScheduledReminderUpdateManyWithoutLicenseNestedInput
  }

  export type LicenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    remindOffsets?: LicenseUpdateremindOffsetsInput | number[]
    gracePeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus | null
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: LicenseAssigneeUncheckedUpdateManyWithoutLicenseNestedInput
    histories?: LicenseHistoryUncheckedUpdateManyWithoutLicenseNestedInput
    attachments?: LicenseAttachmentUncheckedUpdateManyWithoutLicenseNestedInput
    scheduledReminders?: ScheduledReminderUncheckedUpdateManyWithoutLicenseNestedInput
  }

  export type LicenseCreateManyInput = {
    id?: string
    title: string
    licenseNumber?: string | null
    type?: string | null
    holder?: string | null
    clientId?: string | null
    projectId?: string | null
    serviceId?: string | null
    url?: string | null
    vendorId?: string | null
    issuedOn?: Date | string | null
    validFrom?: Date | string | null
    expiresOn: Date | string
    remindOffsets?: LicenseCreateremindOffsetsInput | number[]
    gracePeriodDays?: number | null
    muted?: boolean | null
    responsibleId?: string | null
    status?: $Enums.LicenseStatus | null
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LicenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    remindOffsets?: LicenseUpdateremindOffsetsInput | number[]
    gracePeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus | null
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    remindOffsets?: LicenseUpdateremindOffsetsInput | number[]
    gracePeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus | null
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseAssigneeCreateInput = {
    userId: string
    role?: $Enums.LicenseAssigneeRole
    license: LicenseCreateNestedOneWithoutAssigneesInput
  }

  export type LicenseAssigneeUncheckedCreateInput = {
    licenseId: string
    userId: string
    role?: $Enums.LicenseAssigneeRole
  }

  export type LicenseAssigneeUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumLicenseAssigneeRoleFieldUpdateOperationsInput | $Enums.LicenseAssigneeRole
    license?: LicenseUpdateOneRequiredWithoutAssigneesNestedInput
  }

  export type LicenseAssigneeUncheckedUpdateInput = {
    licenseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumLicenseAssigneeRoleFieldUpdateOperationsInput | $Enums.LicenseAssigneeRole
  }

  export type LicenseAssigneeCreateManyInput = {
    licenseId: string
    userId: string
    role?: $Enums.LicenseAssigneeRole
  }

  export type LicenseAssigneeUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumLicenseAssigneeRoleFieldUpdateOperationsInput | $Enums.LicenseAssigneeRole
  }

  export type LicenseAssigneeUncheckedUpdateManyInput = {
    licenseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumLicenseAssigneeRoleFieldUpdateOperationsInput | $Enums.LicenseAssigneeRole
  }

  export type LicenseHistoryCreateInput = {
    id?: string
    action: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: string | null
    at?: Date | string
    license: LicenseCreateNestedOneWithoutHistoriesInput
  }

  export type LicenseHistoryUncheckedCreateInput = {
    id?: string
    licenseId: string
    action: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: string | null
    at?: Date | string
  }

  export type LicenseHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    at?: DateTimeFieldUpdateOperationsInput | Date | string
    license?: LicenseUpdateOneRequiredWithoutHistoriesNestedInput
  }

  export type LicenseHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseHistoryCreateManyInput = {
    id?: string
    licenseId: string
    action: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: string | null
    at?: Date | string
  }

  export type LicenseHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseAttachmentCreateInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    spacesKey: string
    cachedUrl?: string | null
    uploadedAt?: Date | string
    license: LicenseCreateNestedOneWithoutAttachmentsInput
  }

  export type LicenseAttachmentUncheckedCreateInput = {
    id?: string
    licenseId: string
    fileName: string
    fileSize: number
    mimeType: string
    spacesKey: string
    cachedUrl?: string | null
    uploadedAt?: Date | string
  }

  export type LicenseAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    spacesKey?: StringFieldUpdateOperationsInput | string
    cachedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    license?: LicenseUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type LicenseAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    spacesKey?: StringFieldUpdateOperationsInput | string
    cachedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseAttachmentCreateManyInput = {
    id?: string
    licenseId: string
    fileName: string
    fileSize: number
    mimeType: string
    spacesKey: string
    cachedUrl?: string | null
    uploadedAt?: Date | string
  }

  export type LicenseAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    spacesKey?: StringFieldUpdateOperationsInput | string
    cachedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    spacesKey?: StringFieldUpdateOperationsInput | string
    cachedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReminderCreateInput = {
    id?: string
    orgLocalDay: Date | string
    runAt: Date | string
    offsetDays: number
    status?: $Enums.ReminderStatus
    attempts?: number
    lastError?: string | null
    sentAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    license: LicenseCreateNestedOneWithoutScheduledRemindersInput
  }

  export type ScheduledReminderUncheckedCreateInput = {
    id?: string
    licenseId: string
    orgLocalDay: Date | string
    runAt: Date | string
    offsetDays: number
    status?: $Enums.ReminderStatus
    attempts?: number
    lastError?: string | null
    sentAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledReminderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgLocalDay?: DateTimeFieldUpdateOperationsInput | Date | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offsetDays?: IntFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    license?: LicenseUpdateOneRequiredWithoutScheduledRemindersNestedInput
  }

  export type ScheduledReminderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseId?: StringFieldUpdateOperationsInput | string
    orgLocalDay?: DateTimeFieldUpdateOperationsInput | Date | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offsetDays?: IntFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledReminderCreateManyInput = {
    id?: string
    licenseId: string
    orgLocalDay: Date | string
    runAt: Date | string
    offsetDays: number
    status?: $Enums.ReminderStatus
    attempts?: number
    lastError?: string | null
    sentAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledReminderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgLocalDay?: DateTimeFieldUpdateOperationsInput | Date | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offsetDays?: IntFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledReminderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseId?: StringFieldUpdateOperationsInput | string
    orgLocalDay?: DateTimeFieldUpdateOperationsInput | Date | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offsetDays?: IntFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumClientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusFilter<$PrismaModel> | $Enums.ClientStatus
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    gstNumber?: SortOrder
    panNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    clientCommunication?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    gstNumber?: SortOrder
    panNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    clientCommunication?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
    gstNumber?: SortOrder
    panNumber?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    clientCommunication?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumClientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientStatusFilter<$PrismaModel>
    _max?: NestedEnumClientStatusFilter<$PrismaModel>
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    head?: SortOrder
    taskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    head?: SortOrder
    taskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    head?: SortOrder
    taskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TaskAssigneeListRelationFilter = {
    every?: TaskAssigneeWhereInput
    some?: TaskAssigneeWhereInput
    none?: TaskAssigneeWhereInput
  }

  export type TaskOccurrenceListRelationFilter = {
    every?: TaskOccurrenceWhereInput
    some?: TaskOccurrenceWhereInput
    none?: TaskOccurrenceWhereInput
  }

  export type ReminderListRelationFilter = {
    every?: ReminderWhereInput
    some?: ReminderWhereInput
    none?: ReminderWhereInput
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type TaskAttachmentListRelationFilter = {
    every?: TaskAttachmentWhereInput
    some?: TaskAttachmentWhereInput
    none?: TaskAttachmentWhereInput
  }

  export type TaskCustomValueListRelationFilter = {
    every?: TaskCustomValueWhereInput
    some?: TaskCustomValueWhereInput
    none?: TaskCustomValueWhereInput
  }

  export type EmailLogListRelationFilter = {
    every?: EmailLogWhereInput
    some?: EmailLogWhereInput
    none?: EmailLogWhereInput
  }

  export type TaskAssigneeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOccurrenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCustomValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskProjectIdTaskIdCompoundUniqueInput = {
    projectId: string
    taskId: number
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrder
    priority?: SortOrder
    remarks?: SortOrder
    status?: SortOrder
    recurrenceRule?: SortOrder
    recurrenceEndDate?: SortOrder
    isRecurring?: SortOrder
    lastGeneratedUntil?: SortOrder
    retainSubtasks?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientMailSendCount?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    taskId?: SortOrder
    clientMailSendCount?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrder
    priority?: SortOrder
    remarks?: SortOrder
    status?: SortOrder
    recurrenceRule?: SortOrder
    recurrenceEndDate?: SortOrder
    isRecurring?: SortOrder
    lastGeneratedUntil?: SortOrder
    retainSubtasks?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientMailSendCount?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrder
    priority?: SortOrder
    remarks?: SortOrder
    status?: SortOrder
    recurrenceRule?: SortOrder
    recurrenceEndDate?: SortOrder
    isRecurring?: SortOrder
    lastGeneratedUntil?: SortOrder
    retainSubtasks?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientMailSendCount?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    taskId?: SortOrder
    clientMailSendCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TaskCustomFieldCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    options?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskCustomFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskCustomFieldMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskCustomFieldScalarRelationFilter = {
    is?: TaskCustomFieldWhereInput
    isNot?: TaskCustomFieldWhereInput
  }

  export type TaskCustomValueCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
  }

  export type TaskCustomValueMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
  }

  export type TaskCustomValueMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
  }

  export type TaskOccurrenceAssigneeListRelationFilter = {
    every?: TaskOccurrenceAssigneeWhereInput
    some?: TaskOccurrenceAssigneeWhereInput
    none?: TaskOccurrenceAssigneeWhereInput
  }

  export type TaskOccurrenceAttachmentListRelationFilter = {
    every?: TaskOccurrenceAttachmentWhereInput
    some?: TaskOccurrenceAttachmentWhereInput
    none?: TaskOccurrenceAttachmentWhereInput
  }

  export type TaskOccurrenceAssigneeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOccurrenceAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOccurrenceTaskIdOccurrenceIndexCompoundUniqueInput = {
    taskId: string
    occurrenceIndex: number
  }

  export type TaskOccurrenceCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrder
    priority?: SortOrder
    remarks?: SortOrder
    status?: SortOrder
    occurrenceIndex?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    completedBy?: SortOrder
    completionNote?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sequentialId?: SortOrder
    clientMailSendCount?: SortOrder
    startEmailSent?: SortOrder
    startEmailSentAt?: SortOrder
  }

  export type TaskOccurrenceAvgOrderByAggregateInput = {
    occurrenceIndex?: SortOrder
    sequentialId?: SortOrder
    clientMailSendCount?: SortOrder
  }

  export type TaskOccurrenceMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrder
    priority?: SortOrder
    remarks?: SortOrder
    status?: SortOrder
    occurrenceIndex?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    completedBy?: SortOrder
    completionNote?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sequentialId?: SortOrder
    clientMailSendCount?: SortOrder
    startEmailSent?: SortOrder
    startEmailSentAt?: SortOrder
  }

  export type TaskOccurrenceMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrder
    priority?: SortOrder
    remarks?: SortOrder
    status?: SortOrder
    occurrenceIndex?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    completedBy?: SortOrder
    completionNote?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sequentialId?: SortOrder
    clientMailSendCount?: SortOrder
    startEmailSent?: SortOrder
    startEmailSentAt?: SortOrder
  }

  export type TaskOccurrenceSumOrderByAggregateInput = {
    occurrenceIndex?: SortOrder
    sequentialId?: SortOrder
    clientMailSendCount?: SortOrder
  }

  export type TaskAssigneeTaskId_userIdCompoundUniqueInput = {
    taskId: string
    userId: string
  }

  export type TaskAssigneeCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type TaskAssigneeMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type TaskAssigneeMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
  }

  export type TaskOccurrenceScalarRelationFilter = {
    is?: TaskOccurrenceWhereInput
    isNot?: TaskOccurrenceWhereInput
  }

  export type TaskOccurrenceAssigneeOccurrenceId_userIdCompoundUniqueInput = {
    occurrenceId: string
    userId: string
  }

  export type TaskOccurrenceAssigneeCountOrderByAggregateInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    userId?: SortOrder
  }

  export type TaskOccurrenceAssigneeMaxOrderByAggregateInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    userId?: SortOrder
  }

  export type TaskOccurrenceAssigneeMinOrderByAggregateInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    userId?: SortOrder
  }

  export type TaskAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskOccurrenceAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskOccurrenceAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskOccurrenceAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLogTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LogType | EnumLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLogTypeFilter<$PrismaModel> | $Enums.LogType
  }

  export type CompletionLogTaskIdOccurrenceAtCompoundUniqueInput = {
    taskId: string
    occurrenceAt: Date | string
  }

  export type CompletionLogCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    occurrenceAt?: SortOrder
    type?: SortOrder
    completedBy?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type CompletionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    occurrenceAt?: SortOrder
    type?: SortOrder
    completedBy?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type CompletionLogMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    occurrenceAt?: SortOrder
    type?: SortOrder
    completedBy?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLogTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogType | EnumLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLogTypeWithAggregatesFilter<$PrismaModel> | $Enums.LogType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogTypeFilter<$PrismaModel>
    _max?: NestedEnumLogTypeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ReminderCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    occurrenceAt?: SortOrder
    remindAt?: SortOrder
    channel?: SortOrder
    payload?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    occurrenceAt?: SortOrder
    remindAt?: SortOrder
    channel?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ReminderMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    occurrenceAt?: SortOrder
    remindAt?: SortOrder
    channel?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumCalendarEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarEntryType | EnumCalendarEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarEntryType[] | ListEnumCalendarEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarEntryType[] | ListEnumCalendarEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarEntryTypeFilter<$PrismaModel> | $Enums.CalendarEntryType
  }

  export type EnumRecurrenceFreqNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceFreq | EnumRecurrenceFreqFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurrenceFreq[] | ListEnumRecurrenceFreqFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurrenceFreq[] | ListEnumRecurrenceFreqFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrenceFreqNullableFilter<$PrismaModel> | $Enums.RecurrenceFreq | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CalendarEntryCountOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    allDay?: SortOrder
    freq?: SortOrder
    interval?: SortOrder
    until?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarEntryAvgOrderByAggregateInput = {
    interval?: SortOrder
    count?: SortOrder
  }

  export type CalendarEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    allDay?: SortOrder
    freq?: SortOrder
    interval?: SortOrder
    until?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarEntryMinOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    allDay?: SortOrder
    freq?: SortOrder
    interval?: SortOrder
    until?: SortOrder
    count?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarEntrySumOrderByAggregateInput = {
    interval?: SortOrder
    count?: SortOrder
  }

  export type EnumCalendarEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarEntryType | EnumCalendarEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarEntryType[] | ListEnumCalendarEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarEntryType[] | ListEnumCalendarEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.CalendarEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumCalendarEntryTypeFilter<$PrismaModel>
  }

  export type EnumRecurrenceFreqNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceFreq | EnumRecurrenceFreqFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurrenceFreq[] | ListEnumRecurrenceFreqFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurrenceFreq[] | ListEnumRecurrenceFreqFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrenceFreqNullableWithAggregatesFilter<$PrismaModel> | $Enums.RecurrenceFreq | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecurrenceFreqNullableFilter<$PrismaModel>
    _max?: NestedEnumRecurrenceFreqNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    actorId?: SortOrder
    taskId?: SortOrder
    occurrenceId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    actorId?: SortOrder
    taskId?: SortOrder
    occurrenceId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    actorId?: SortOrder
    taskId?: SortOrder
    occurrenceId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMemberListRelationFilter = {
    every?: ConversationMemberWhereInput
    some?: ConversationMemberWhereInput
    none?: ConversationMemberWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ConversationMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type DirectoryUserScalarRelationFilter = {
    is?: DirectoryUserWhereInput
    isNot?: DirectoryUserWhereInput
  }

  export type ConversationMemberConversationIdUserIdCompoundUniqueInput = {
    conversationId: string
    userId: string
  }

  export type ConversationMemberCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type ConversationMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type ConversationMemberMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type MessageReadListRelationFilter = {
    every?: MessageReadWhereInput
    some?: MessageReadWhereInput
    none?: MessageReadWhereInput
  }

  export type MessageReadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    body?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageReadMessageId_userIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type MessageReadCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MessageReadMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MessageReadMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type DirectoryUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectoryUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectoryUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEmailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusFilter<$PrismaModel> | $Enums.EmailStatus
  }

  export type TaskOccurrenceNullableScalarRelationFilter = {
    is?: TaskOccurrenceWhereInput | null
    isNot?: TaskOccurrenceWhereInput | null
  }

  export type TaskNullableScalarRelationFilter = {
    is?: TaskWhereInput | null
    isNot?: TaskWhereInput | null
  }

  export type EmailLogCountOrderByAggregateInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    taskId?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    provider?: SortOrder
    providerMessageId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailLogMaxOrderByAggregateInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    taskId?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    provider?: SortOrder
    providerMessageId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailLogMinOrderByAggregateInput = {
    id?: SortOrder
    occurrenceId?: SortOrder
    taskId?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    provider?: SortOrder
    providerMessageId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumEmailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailStatusFilter<$PrismaModel>
    _max?: NestedEnumEmailStatusFilter<$PrismaModel>
  }

  export type EnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type LeaveRequestCountOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    requesterName?: SortOrder
    requesterEmail?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    status?: SortOrder
    approverId?: SortOrder
    adminComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestAvgOrderByAggregateInput = {
    days?: SortOrder
  }

  export type LeaveRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    requesterName?: SortOrder
    requesterEmail?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    status?: SortOrder
    approverId?: SortOrder
    adminComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestMinOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    requesterName?: SortOrder
    requesterEmail?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    status?: SortOrder
    approverId?: SortOrder
    adminComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestSumOrderByAggregateInput = {
    days?: SortOrder
  }

  export type EnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumLicenseStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLicenseStatusNullableFilter<$PrismaModel> | $Enums.LicenseStatus | null
  }

  export type LicenseAssigneeListRelationFilter = {
    every?: LicenseAssigneeWhereInput
    some?: LicenseAssigneeWhereInput
    none?: LicenseAssigneeWhereInput
  }

  export type LicenseHistoryListRelationFilter = {
    every?: LicenseHistoryWhereInput
    some?: LicenseHistoryWhereInput
    none?: LicenseHistoryWhereInput
  }

  export type LicenseAttachmentListRelationFilter = {
    every?: LicenseAttachmentWhereInput
    some?: LicenseAttachmentWhereInput
    none?: LicenseAttachmentWhereInput
  }

  export type ScheduledReminderListRelationFilter = {
    every?: ScheduledReminderWhereInput
    some?: ScheduledReminderWhereInput
    none?: ScheduledReminderWhereInput
  }

  export type LicenseAssigneeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LicenseHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LicenseAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduledReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LicenseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    licenseNumber?: SortOrder
    type?: SortOrder
    holder?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    vendorId?: SortOrder
    issuedOn?: SortOrder
    validFrom?: SortOrder
    expiresOn?: SortOrder
    remindOffsets?: SortOrder
    gracePeriodDays?: SortOrder
    muted?: SortOrder
    responsibleId?: SortOrder
    status?: SortOrder
    nextReminderAt?: SortOrder
    lastReminderAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LicenseAvgOrderByAggregateInput = {
    remindOffsets?: SortOrder
    gracePeriodDays?: SortOrder
  }

  export type LicenseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    licenseNumber?: SortOrder
    type?: SortOrder
    holder?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    vendorId?: SortOrder
    issuedOn?: SortOrder
    validFrom?: SortOrder
    expiresOn?: SortOrder
    gracePeriodDays?: SortOrder
    muted?: SortOrder
    responsibleId?: SortOrder
    status?: SortOrder
    nextReminderAt?: SortOrder
    lastReminderAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LicenseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    licenseNumber?: SortOrder
    type?: SortOrder
    holder?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    vendorId?: SortOrder
    issuedOn?: SortOrder
    validFrom?: SortOrder
    expiresOn?: SortOrder
    gracePeriodDays?: SortOrder
    muted?: SortOrder
    responsibleId?: SortOrder
    status?: SortOrder
    nextReminderAt?: SortOrder
    lastReminderAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LicenseSumOrderByAggregateInput = {
    remindOffsets?: SortOrder
    gracePeriodDays?: SortOrder
  }

  export type EnumLicenseStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLicenseStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.LicenseStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLicenseStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumLicenseStatusNullableFilter<$PrismaModel>
  }

  export type EnumLicenseAssigneeRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseAssigneeRole | EnumLicenseAssigneeRoleFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseAssigneeRole[] | ListEnumLicenseAssigneeRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseAssigneeRole[] | ListEnumLicenseAssigneeRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseAssigneeRoleFilter<$PrismaModel> | $Enums.LicenseAssigneeRole
  }

  export type LicenseScalarRelationFilter = {
    is?: LicenseWhereInput
    isNot?: LicenseWhereInput
  }

  export type LicenseAssigneeLicenseIdUserIdCompoundUniqueInput = {
    licenseId: string
    userId: string
  }

  export type LicenseAssigneeCountOrderByAggregateInput = {
    licenseId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type LicenseAssigneeMaxOrderByAggregateInput = {
    licenseId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type LicenseAssigneeMinOrderByAggregateInput = {
    licenseId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type EnumLicenseAssigneeRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseAssigneeRole | EnumLicenseAssigneeRoleFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseAssigneeRole[] | ListEnumLicenseAssigneeRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseAssigneeRole[] | ListEnumLicenseAssigneeRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseAssigneeRoleWithAggregatesFilter<$PrismaModel> | $Enums.LicenseAssigneeRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLicenseAssigneeRoleFilter<$PrismaModel>
    _max?: NestedEnumLicenseAssigneeRoleFilter<$PrismaModel>
  }

  export type LicenseHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    licenseId?: SortOrder
    action?: SortOrder
    payload?: SortOrder
    actorId?: SortOrder
    at?: SortOrder
  }

  export type LicenseHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    licenseId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    at?: SortOrder
  }

  export type LicenseHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    licenseId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    at?: SortOrder
  }

  export type LicenseAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    licenseId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    spacesKey?: SortOrder
    cachedUrl?: SortOrder
    uploadedAt?: SortOrder
  }

  export type LicenseAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type LicenseAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    licenseId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    spacesKey?: SortOrder
    cachedUrl?: SortOrder
    uploadedAt?: SortOrder
  }

  export type LicenseAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    licenseId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    spacesKey?: SortOrder
    cachedUrl?: SortOrder
    uploadedAt?: SortOrder
  }

  export type LicenseAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumReminderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusFilter<$PrismaModel> | $Enums.ReminderStatus
  }

  export type ScheduledReminderLicenseIdOffsetDaysCompoundUniqueInput = {
    licenseId: string
    offsetDays: number
  }

  export type ScheduledReminderCountOrderByAggregateInput = {
    id?: SortOrder
    licenseId?: SortOrder
    orgLocalDay?: SortOrder
    runAt?: SortOrder
    offsetDays?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    sentAt?: SortOrder
    meta?: SortOrder
  }

  export type ScheduledReminderAvgOrderByAggregateInput = {
    offsetDays?: SortOrder
    attempts?: SortOrder
  }

  export type ScheduledReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    licenseId?: SortOrder
    orgLocalDay?: SortOrder
    runAt?: SortOrder
    offsetDays?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    sentAt?: SortOrder
  }

  export type ScheduledReminderMinOrderByAggregateInput = {
    id?: SortOrder
    licenseId?: SortOrder
    orgLocalDay?: SortOrder
    runAt?: SortOrder
    offsetDays?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    lastError?: SortOrder
    sentAt?: SortOrder
  }

  export type ScheduledReminderSumOrderByAggregateInput = {
    offsetDays?: SortOrder
    attempts?: SortOrder
  }

  export type EnumReminderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReminderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderStatusFilter<$PrismaModel>
    _max?: NestedEnumReminderStatusFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumClientStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClientStatus
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskAssigneeCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type TaskOccurrenceCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskOccurrenceCreateWithoutTaskInput, TaskOccurrenceUncheckedCreateWithoutTaskInput> | TaskOccurrenceCreateWithoutTaskInput[] | TaskOccurrenceUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskOccurrenceCreateOrConnectWithoutTaskInput | TaskOccurrenceCreateOrConnectWithoutTaskInput[]
    createMany?: TaskOccurrenceCreateManyTaskInputEnvelope
    connect?: TaskOccurrenceWhereUniqueInput | TaskOccurrenceWhereUniqueInput[]
  }

  export type ReminderCreateNestedManyWithoutTaskInput = {
    create?: XOR<ReminderCreateWithoutTaskInput, ReminderUncheckedCreateWithoutTaskInput> | ReminderCreateWithoutTaskInput[] | ReminderUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutTaskInput | ReminderCreateOrConnectWithoutTaskInput[]
    createMany?: ReminderCreateManyTaskInputEnvelope
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskAttachmentCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput> | TaskAttachmentCreateWithoutTaskInput[] | TaskAttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutTaskInput | TaskAttachmentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
  }

  export type TaskCustomValueCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCustomValueCreateWithoutTaskInput, TaskCustomValueUncheckedCreateWithoutTaskInput> | TaskCustomValueCreateWithoutTaskInput[] | TaskCustomValueUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutTaskInput | TaskCustomValueCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCustomValueCreateManyTaskInputEnvelope
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
  }

  export type EmailLogCreateNestedManyWithoutTaskInput = {
    create?: XOR<EmailLogCreateWithoutTaskInput, EmailLogUncheckedCreateWithoutTaskInput> | EmailLogCreateWithoutTaskInput[] | EmailLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutTaskInput | EmailLogCreateOrConnectWithoutTaskInput[]
    createMany?: EmailLogCreateManyTaskInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
  }

  export type TaskOccurrenceUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskOccurrenceCreateWithoutTaskInput, TaskOccurrenceUncheckedCreateWithoutTaskInput> | TaskOccurrenceCreateWithoutTaskInput[] | TaskOccurrenceUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskOccurrenceCreateOrConnectWithoutTaskInput | TaskOccurrenceCreateOrConnectWithoutTaskInput[]
    createMany?: TaskOccurrenceCreateManyTaskInputEnvelope
    connect?: TaskOccurrenceWhereUniqueInput | TaskOccurrenceWhereUniqueInput[]
  }

  export type ReminderUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<ReminderCreateWithoutTaskInput, ReminderUncheckedCreateWithoutTaskInput> | ReminderCreateWithoutTaskInput[] | ReminderUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutTaskInput | ReminderCreateOrConnectWithoutTaskInput[]
    createMany?: ReminderCreateManyTaskInputEnvelope
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
  }

  export type TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput> | TaskAttachmentCreateWithoutTaskInput[] | TaskAttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutTaskInput | TaskAttachmentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
  }

  export type TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCustomValueCreateWithoutTaskInput, TaskCustomValueUncheckedCreateWithoutTaskInput> | TaskCustomValueCreateWithoutTaskInput[] | TaskCustomValueUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutTaskInput | TaskCustomValueCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCustomValueCreateManyTaskInputEnvelope
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
  }

  export type EmailLogUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<EmailLogCreateWithoutTaskInput, EmailLogUncheckedCreateWithoutTaskInput> | EmailLogCreateWithoutTaskInput[] | EmailLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutTaskInput | EmailLogCreateOrConnectWithoutTaskInput[]
    createMany?: EmailLogCreateManyTaskInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TaskAssigneeUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput | TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput | TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutTaskInput | TaskAssigneeUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type TaskOccurrenceUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskOccurrenceCreateWithoutTaskInput, TaskOccurrenceUncheckedCreateWithoutTaskInput> | TaskOccurrenceCreateWithoutTaskInput[] | TaskOccurrenceUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskOccurrenceCreateOrConnectWithoutTaskInput | TaskOccurrenceCreateOrConnectWithoutTaskInput[]
    upsert?: TaskOccurrenceUpsertWithWhereUniqueWithoutTaskInput | TaskOccurrenceUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskOccurrenceCreateManyTaskInputEnvelope
    set?: TaskOccurrenceWhereUniqueInput | TaskOccurrenceWhereUniqueInput[]
    disconnect?: TaskOccurrenceWhereUniqueInput | TaskOccurrenceWhereUniqueInput[]
    delete?: TaskOccurrenceWhereUniqueInput | TaskOccurrenceWhereUniqueInput[]
    connect?: TaskOccurrenceWhereUniqueInput | TaskOccurrenceWhereUniqueInput[]
    update?: TaskOccurrenceUpdateWithWhereUniqueWithoutTaskInput | TaskOccurrenceUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskOccurrenceUpdateManyWithWhereWithoutTaskInput | TaskOccurrenceUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskOccurrenceScalarWhereInput | TaskOccurrenceScalarWhereInput[]
  }

  export type ReminderUpdateManyWithoutTaskNestedInput = {
    create?: XOR<ReminderCreateWithoutTaskInput, ReminderUncheckedCreateWithoutTaskInput> | ReminderCreateWithoutTaskInput[] | ReminderUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutTaskInput | ReminderCreateOrConnectWithoutTaskInput[]
    upsert?: ReminderUpsertWithWhereUniqueWithoutTaskInput | ReminderUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: ReminderCreateManyTaskInputEnvelope
    set?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    disconnect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    delete?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    update?: ReminderUpdateWithWhereUniqueWithoutTaskInput | ReminderUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: ReminderUpdateManyWithWhereWithoutTaskInput | ReminderUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
  }

  export type ProjectUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type TaskAttachmentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput> | TaskAttachmentCreateWithoutTaskInput[] | TaskAttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutTaskInput | TaskAttachmentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput | TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    update?: TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput | TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAttachmentUpdateManyWithWhereWithoutTaskInput | TaskAttachmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
  }

  export type TaskCustomValueUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCustomValueCreateWithoutTaskInput, TaskCustomValueUncheckedCreateWithoutTaskInput> | TaskCustomValueCreateWithoutTaskInput[] | TaskCustomValueUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutTaskInput | TaskCustomValueCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCustomValueUpsertWithWhereUniqueWithoutTaskInput | TaskCustomValueUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCustomValueCreateManyTaskInputEnvelope
    set?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    disconnect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    delete?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    update?: TaskCustomValueUpdateWithWhereUniqueWithoutTaskInput | TaskCustomValueUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCustomValueUpdateManyWithWhereWithoutTaskInput | TaskCustomValueUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCustomValueScalarWhereInput | TaskCustomValueScalarWhereInput[]
  }

  export type EmailLogUpdateManyWithoutTaskNestedInput = {
    create?: XOR<EmailLogCreateWithoutTaskInput, EmailLogUncheckedCreateWithoutTaskInput> | EmailLogCreateWithoutTaskInput[] | EmailLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutTaskInput | EmailLogCreateOrConnectWithoutTaskInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutTaskInput | EmailLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: EmailLogCreateManyTaskInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutTaskInput | EmailLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutTaskInput | EmailLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput> | TaskAssigneeCreateWithoutTaskInput[] | TaskAssigneeUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAssigneeCreateOrConnectWithoutTaskInput | TaskAssigneeCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput | TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAssigneeCreateManyTaskInputEnvelope
    set?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    disconnect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    delete?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    connect?: TaskAssigneeWhereUniqueInput | TaskAssigneeWhereUniqueInput[]
    update?: TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput | TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAssigneeUpdateManyWithWhereWithoutTaskInput | TaskAssigneeUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
  }

  export type TaskOccurrenceUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskOccurrenceCreateWithoutTaskInput, TaskOccurrenceUncheckedCreateWithoutTaskInput> | TaskOccurrenceCreateWithoutTaskInput[] | TaskOccurrenceUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskOccurrenceCreateOrConnectWithoutTaskInput | TaskOccurrenceCreateOrConnectWithoutTaskInput[]
    upsert?: TaskOccurrenceUpsertWithWhereUniqueWithoutTaskInput | TaskOccurrenceUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskOccurrenceCreateManyTaskInputEnvelope
    set?: TaskOccurrenceWhereUniqueInput | TaskOccurrenceWhereUniqueInput[]
    disconnect?: TaskOccurrenceWhereUniqueInput | TaskOccurrenceWhereUniqueInput[]
    delete?: TaskOccurrenceWhereUniqueInput | TaskOccurrenceWhereUniqueInput[]
    connect?: TaskOccurrenceWhereUniqueInput | TaskOccurrenceWhereUniqueInput[]
    update?: TaskOccurrenceUpdateWithWhereUniqueWithoutTaskInput | TaskOccurrenceUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskOccurrenceUpdateManyWithWhereWithoutTaskInput | TaskOccurrenceUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskOccurrenceScalarWhereInput | TaskOccurrenceScalarWhereInput[]
  }

  export type ReminderUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<ReminderCreateWithoutTaskInput, ReminderUncheckedCreateWithoutTaskInput> | ReminderCreateWithoutTaskInput[] | ReminderUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutTaskInput | ReminderCreateOrConnectWithoutTaskInput[]
    upsert?: ReminderUpsertWithWhereUniqueWithoutTaskInput | ReminderUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: ReminderCreateManyTaskInputEnvelope
    set?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    disconnect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    delete?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    update?: ReminderUpdateWithWhereUniqueWithoutTaskInput | ReminderUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: ReminderUpdateManyWithWhereWithoutTaskInput | ReminderUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
  }

  export type TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput> | TaskAttachmentCreateWithoutTaskInput[] | TaskAttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskAttachmentCreateOrConnectWithoutTaskInput | TaskAttachmentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput | TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskAttachmentCreateManyTaskInputEnvelope
    set?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    disconnect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    delete?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    connect?: TaskAttachmentWhereUniqueInput | TaskAttachmentWhereUniqueInput[]
    update?: TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput | TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskAttachmentUpdateManyWithWhereWithoutTaskInput | TaskAttachmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
  }

  export type TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCustomValueCreateWithoutTaskInput, TaskCustomValueUncheckedCreateWithoutTaskInput> | TaskCustomValueCreateWithoutTaskInput[] | TaskCustomValueUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutTaskInput | TaskCustomValueCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCustomValueUpsertWithWhereUniqueWithoutTaskInput | TaskCustomValueUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCustomValueCreateManyTaskInputEnvelope
    set?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    disconnect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    delete?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    update?: TaskCustomValueUpdateWithWhereUniqueWithoutTaskInput | TaskCustomValueUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCustomValueUpdateManyWithWhereWithoutTaskInput | TaskCustomValueUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCustomValueScalarWhereInput | TaskCustomValueScalarWhereInput[]
  }

  export type EmailLogUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<EmailLogCreateWithoutTaskInput, EmailLogUncheckedCreateWithoutTaskInput> | EmailLogCreateWithoutTaskInput[] | EmailLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutTaskInput | EmailLogCreateOrConnectWithoutTaskInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutTaskInput | EmailLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: EmailLogCreateManyTaskInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutTaskInput | EmailLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutTaskInput | EmailLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type TaskCustomFieldCreateoptionsInput = {
    set: string[]
  }

  export type TaskCustomValueCreateNestedManyWithoutFieldInput = {
    create?: XOR<TaskCustomValueCreateWithoutFieldInput, TaskCustomValueUncheckedCreateWithoutFieldInput> | TaskCustomValueCreateWithoutFieldInput[] | TaskCustomValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutFieldInput | TaskCustomValueCreateOrConnectWithoutFieldInput[]
    createMany?: TaskCustomValueCreateManyFieldInputEnvelope
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
  }

  export type TaskCustomValueUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<TaskCustomValueCreateWithoutFieldInput, TaskCustomValueUncheckedCreateWithoutFieldInput> | TaskCustomValueCreateWithoutFieldInput[] | TaskCustomValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutFieldInput | TaskCustomValueCreateOrConnectWithoutFieldInput[]
    createMany?: TaskCustomValueCreateManyFieldInputEnvelope
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
  }

  export type TaskCustomFieldUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TaskCustomValueUpdateManyWithoutFieldNestedInput = {
    create?: XOR<TaskCustomValueCreateWithoutFieldInput, TaskCustomValueUncheckedCreateWithoutFieldInput> | TaskCustomValueCreateWithoutFieldInput[] | TaskCustomValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutFieldInput | TaskCustomValueCreateOrConnectWithoutFieldInput[]
    upsert?: TaskCustomValueUpsertWithWhereUniqueWithoutFieldInput | TaskCustomValueUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: TaskCustomValueCreateManyFieldInputEnvelope
    set?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    disconnect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    delete?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    update?: TaskCustomValueUpdateWithWhereUniqueWithoutFieldInput | TaskCustomValueUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: TaskCustomValueUpdateManyWithWhereWithoutFieldInput | TaskCustomValueUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: TaskCustomValueScalarWhereInput | TaskCustomValueScalarWhereInput[]
  }

  export type TaskCustomValueUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<TaskCustomValueCreateWithoutFieldInput, TaskCustomValueUncheckedCreateWithoutFieldInput> | TaskCustomValueCreateWithoutFieldInput[] | TaskCustomValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: TaskCustomValueCreateOrConnectWithoutFieldInput | TaskCustomValueCreateOrConnectWithoutFieldInput[]
    upsert?: TaskCustomValueUpsertWithWhereUniqueWithoutFieldInput | TaskCustomValueUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: TaskCustomValueCreateManyFieldInputEnvelope
    set?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    disconnect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    delete?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    connect?: TaskCustomValueWhereUniqueInput | TaskCustomValueWhereUniqueInput[]
    update?: TaskCustomValueUpdateWithWhereUniqueWithoutFieldInput | TaskCustomValueUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: TaskCustomValueUpdateManyWithWhereWithoutFieldInput | TaskCustomValueUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: TaskCustomValueScalarWhereInput | TaskCustomValueScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutCustomValuesInput = {
    create?: XOR<TaskCreateWithoutCustomValuesInput, TaskUncheckedCreateWithoutCustomValuesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCustomValuesInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskCustomFieldCreateNestedOneWithoutValuesInput = {
    create?: XOR<TaskCustomFieldCreateWithoutValuesInput, TaskCustomFieldUncheckedCreateWithoutValuesInput>
    connectOrCreate?: TaskCustomFieldCreateOrConnectWithoutValuesInput
    connect?: TaskCustomFieldWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutCustomValuesNestedInput = {
    create?: XOR<TaskCreateWithoutCustomValuesInput, TaskUncheckedCreateWithoutCustomValuesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCustomValuesInput
    upsert?: TaskUpsertWithoutCustomValuesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCustomValuesInput, TaskUpdateWithoutCustomValuesInput>, TaskUncheckedUpdateWithoutCustomValuesInput>
  }

  export type TaskCustomFieldUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<TaskCustomFieldCreateWithoutValuesInput, TaskCustomFieldUncheckedCreateWithoutValuesInput>
    connectOrCreate?: TaskCustomFieldCreateOrConnectWithoutValuesInput
    upsert?: TaskCustomFieldUpsertWithoutValuesInput
    connect?: TaskCustomFieldWhereUniqueInput
    update?: XOR<XOR<TaskCustomFieldUpdateToOneWithWhereWithoutValuesInput, TaskCustomFieldUpdateWithoutValuesInput>, TaskCustomFieldUncheckedUpdateWithoutValuesInput>
  }

  export type TaskOccurrenceAssigneeCreateNestedManyWithoutOccurrenceInput = {
    create?: XOR<TaskOccurrenceAssigneeCreateWithoutOccurrenceInput, TaskOccurrenceAssigneeUncheckedCreateWithoutOccurrenceInput> | TaskOccurrenceAssigneeCreateWithoutOccurrenceInput[] | TaskOccurrenceAssigneeUncheckedCreateWithoutOccurrenceInput[]
    connectOrCreate?: TaskOccurrenceAssigneeCreateOrConnectWithoutOccurrenceInput | TaskOccurrenceAssigneeCreateOrConnectWithoutOccurrenceInput[]
    createMany?: TaskOccurrenceAssigneeCreateManyOccurrenceInputEnvelope
    connect?: TaskOccurrenceAssigneeWhereUniqueInput | TaskOccurrenceAssigneeWhereUniqueInput[]
  }

  export type TaskCreateNestedOneWithoutOccurrencesInput = {
    create?: XOR<TaskCreateWithoutOccurrencesInput, TaskUncheckedCreateWithoutOccurrencesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutOccurrencesInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskOccurrenceAttachmentCreateNestedManyWithoutOccurrenceInput = {
    create?: XOR<TaskOccurrenceAttachmentCreateWithoutOccurrenceInput, TaskOccurrenceAttachmentUncheckedCreateWithoutOccurrenceInput> | TaskOccurrenceAttachmentCreateWithoutOccurrenceInput[] | TaskOccurrenceAttachmentUncheckedCreateWithoutOccurrenceInput[]
    connectOrCreate?: TaskOccurrenceAttachmentCreateOrConnectWithoutOccurrenceInput | TaskOccurrenceAttachmentCreateOrConnectWithoutOccurrenceInput[]
    createMany?: TaskOccurrenceAttachmentCreateManyOccurrenceInputEnvelope
    connect?: TaskOccurrenceAttachmentWhereUniqueInput | TaskOccurrenceAttachmentWhereUniqueInput[]
  }

  export type EmailLogCreateNestedManyWithoutOccurrenceInput = {
    create?: XOR<EmailLogCreateWithoutOccurrenceInput, EmailLogUncheckedCreateWithoutOccurrenceInput> | EmailLogCreateWithoutOccurrenceInput[] | EmailLogUncheckedCreateWithoutOccurrenceInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutOccurrenceInput | EmailLogCreateOrConnectWithoutOccurrenceInput[]
    createMany?: EmailLogCreateManyOccurrenceInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type TaskOccurrenceAssigneeUncheckedCreateNestedManyWithoutOccurrenceInput = {
    create?: XOR<TaskOccurrenceAssigneeCreateWithoutOccurrenceInput, TaskOccurrenceAssigneeUncheckedCreateWithoutOccurrenceInput> | TaskOccurrenceAssigneeCreateWithoutOccurrenceInput[] | TaskOccurrenceAssigneeUncheckedCreateWithoutOccurrenceInput[]
    connectOrCreate?: TaskOccurrenceAssigneeCreateOrConnectWithoutOccurrenceInput | TaskOccurrenceAssigneeCreateOrConnectWithoutOccurrenceInput[]
    createMany?: TaskOccurrenceAssigneeCreateManyOccurrenceInputEnvelope
    connect?: TaskOccurrenceAssigneeWhereUniqueInput | TaskOccurrenceAssigneeWhereUniqueInput[]
  }

  export type TaskOccurrenceAttachmentUncheckedCreateNestedManyWithoutOccurrenceInput = {
    create?: XOR<TaskOccurrenceAttachmentCreateWithoutOccurrenceInput, TaskOccurrenceAttachmentUncheckedCreateWithoutOccurrenceInput> | TaskOccurrenceAttachmentCreateWithoutOccurrenceInput[] | TaskOccurrenceAttachmentUncheckedCreateWithoutOccurrenceInput[]
    connectOrCreate?: TaskOccurrenceAttachmentCreateOrConnectWithoutOccurrenceInput | TaskOccurrenceAttachmentCreateOrConnectWithoutOccurrenceInput[]
    createMany?: TaskOccurrenceAttachmentCreateManyOccurrenceInputEnvelope
    connect?: TaskOccurrenceAttachmentWhereUniqueInput | TaskOccurrenceAttachmentWhereUniqueInput[]
  }

  export type EmailLogUncheckedCreateNestedManyWithoutOccurrenceInput = {
    create?: XOR<EmailLogCreateWithoutOccurrenceInput, EmailLogUncheckedCreateWithoutOccurrenceInput> | EmailLogCreateWithoutOccurrenceInput[] | EmailLogUncheckedCreateWithoutOccurrenceInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutOccurrenceInput | EmailLogCreateOrConnectWithoutOccurrenceInput[]
    createMany?: EmailLogCreateManyOccurrenceInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type TaskOccurrenceAssigneeUpdateManyWithoutOccurrenceNestedInput = {
    create?: XOR<TaskOccurrenceAssigneeCreateWithoutOccurrenceInput, TaskOccurrenceAssigneeUncheckedCreateWithoutOccurrenceInput> | TaskOccurrenceAssigneeCreateWithoutOccurrenceInput[] | TaskOccurrenceAssigneeUncheckedCreateWithoutOccurrenceInput[]
    connectOrCreate?: TaskOccurrenceAssigneeCreateOrConnectWithoutOccurrenceInput | TaskOccurrenceAssigneeCreateOrConnectWithoutOccurrenceInput[]
    upsert?: TaskOccurrenceAssigneeUpsertWithWhereUniqueWithoutOccurrenceInput | TaskOccurrenceAssigneeUpsertWithWhereUniqueWithoutOccurrenceInput[]
    createMany?: TaskOccurrenceAssigneeCreateManyOccurrenceInputEnvelope
    set?: TaskOccurrenceAssigneeWhereUniqueInput | TaskOccurrenceAssigneeWhereUniqueInput[]
    disconnect?: TaskOccurrenceAssigneeWhereUniqueInput | TaskOccurrenceAssigneeWhereUniqueInput[]
    delete?: TaskOccurrenceAssigneeWhereUniqueInput | TaskOccurrenceAssigneeWhereUniqueInput[]
    connect?: TaskOccurrenceAssigneeWhereUniqueInput | TaskOccurrenceAssigneeWhereUniqueInput[]
    update?: TaskOccurrenceAssigneeUpdateWithWhereUniqueWithoutOccurrenceInput | TaskOccurrenceAssigneeUpdateWithWhereUniqueWithoutOccurrenceInput[]
    updateMany?: TaskOccurrenceAssigneeUpdateManyWithWhereWithoutOccurrenceInput | TaskOccurrenceAssigneeUpdateManyWithWhereWithoutOccurrenceInput[]
    deleteMany?: TaskOccurrenceAssigneeScalarWhereInput | TaskOccurrenceAssigneeScalarWhereInput[]
  }

  export type TaskUpdateOneRequiredWithoutOccurrencesNestedInput = {
    create?: XOR<TaskCreateWithoutOccurrencesInput, TaskUncheckedCreateWithoutOccurrencesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutOccurrencesInput
    upsert?: TaskUpsertWithoutOccurrencesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutOccurrencesInput, TaskUpdateWithoutOccurrencesInput>, TaskUncheckedUpdateWithoutOccurrencesInput>
  }

  export type TaskOccurrenceAttachmentUpdateManyWithoutOccurrenceNestedInput = {
    create?: XOR<TaskOccurrenceAttachmentCreateWithoutOccurrenceInput, TaskOccurrenceAttachmentUncheckedCreateWithoutOccurrenceInput> | TaskOccurrenceAttachmentCreateWithoutOccurrenceInput[] | TaskOccurrenceAttachmentUncheckedCreateWithoutOccurrenceInput[]
    connectOrCreate?: TaskOccurrenceAttachmentCreateOrConnectWithoutOccurrenceInput | TaskOccurrenceAttachmentCreateOrConnectWithoutOccurrenceInput[]
    upsert?: TaskOccurrenceAttachmentUpsertWithWhereUniqueWithoutOccurrenceInput | TaskOccurrenceAttachmentUpsertWithWhereUniqueWithoutOccurrenceInput[]
    createMany?: TaskOccurrenceAttachmentCreateManyOccurrenceInputEnvelope
    set?: TaskOccurrenceAttachmentWhereUniqueInput | TaskOccurrenceAttachmentWhereUniqueInput[]
    disconnect?: TaskOccurrenceAttachmentWhereUniqueInput | TaskOccurrenceAttachmentWhereUniqueInput[]
    delete?: TaskOccurrenceAttachmentWhereUniqueInput | TaskOccurrenceAttachmentWhereUniqueInput[]
    connect?: TaskOccurrenceAttachmentWhereUniqueInput | TaskOccurrenceAttachmentWhereUniqueInput[]
    update?: TaskOccurrenceAttachmentUpdateWithWhereUniqueWithoutOccurrenceInput | TaskOccurrenceAttachmentUpdateWithWhereUniqueWithoutOccurrenceInput[]
    updateMany?: TaskOccurrenceAttachmentUpdateManyWithWhereWithoutOccurrenceInput | TaskOccurrenceAttachmentUpdateManyWithWhereWithoutOccurrenceInput[]
    deleteMany?: TaskOccurrenceAttachmentScalarWhereInput | TaskOccurrenceAttachmentScalarWhereInput[]
  }

  export type EmailLogUpdateManyWithoutOccurrenceNestedInput = {
    create?: XOR<EmailLogCreateWithoutOccurrenceInput, EmailLogUncheckedCreateWithoutOccurrenceInput> | EmailLogCreateWithoutOccurrenceInput[] | EmailLogUncheckedCreateWithoutOccurrenceInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutOccurrenceInput | EmailLogCreateOrConnectWithoutOccurrenceInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutOccurrenceInput | EmailLogUpsertWithWhereUniqueWithoutOccurrenceInput[]
    createMany?: EmailLogCreateManyOccurrenceInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutOccurrenceInput | EmailLogUpdateWithWhereUniqueWithoutOccurrenceInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutOccurrenceInput | EmailLogUpdateManyWithWhereWithoutOccurrenceInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type TaskOccurrenceAssigneeUncheckedUpdateManyWithoutOccurrenceNestedInput = {
    create?: XOR<TaskOccurrenceAssigneeCreateWithoutOccurrenceInput, TaskOccurrenceAssigneeUncheckedCreateWithoutOccurrenceInput> | TaskOccurrenceAssigneeCreateWithoutOccurrenceInput[] | TaskOccurrenceAssigneeUncheckedCreateWithoutOccurrenceInput[]
    connectOrCreate?: TaskOccurrenceAssigneeCreateOrConnectWithoutOccurrenceInput | TaskOccurrenceAssigneeCreateOrConnectWithoutOccurrenceInput[]
    upsert?: TaskOccurrenceAssigneeUpsertWithWhereUniqueWithoutOccurrenceInput | TaskOccurrenceAssigneeUpsertWithWhereUniqueWithoutOccurrenceInput[]
    createMany?: TaskOccurrenceAssigneeCreateManyOccurrenceInputEnvelope
    set?: TaskOccurrenceAssigneeWhereUniqueInput | TaskOccurrenceAssigneeWhereUniqueInput[]
    disconnect?: TaskOccurrenceAssigneeWhereUniqueInput | TaskOccurrenceAssigneeWhereUniqueInput[]
    delete?: TaskOccurrenceAssigneeWhereUniqueInput | TaskOccurrenceAssigneeWhereUniqueInput[]
    connect?: TaskOccurrenceAssigneeWhereUniqueInput | TaskOccurrenceAssigneeWhereUniqueInput[]
    update?: TaskOccurrenceAssigneeUpdateWithWhereUniqueWithoutOccurrenceInput | TaskOccurrenceAssigneeUpdateWithWhereUniqueWithoutOccurrenceInput[]
    updateMany?: TaskOccurrenceAssigneeUpdateManyWithWhereWithoutOccurrenceInput | TaskOccurrenceAssigneeUpdateManyWithWhereWithoutOccurrenceInput[]
    deleteMany?: TaskOccurrenceAssigneeScalarWhereInput | TaskOccurrenceAssigneeScalarWhereInput[]
  }

  export type TaskOccurrenceAttachmentUncheckedUpdateManyWithoutOccurrenceNestedInput = {
    create?: XOR<TaskOccurrenceAttachmentCreateWithoutOccurrenceInput, TaskOccurrenceAttachmentUncheckedCreateWithoutOccurrenceInput> | TaskOccurrenceAttachmentCreateWithoutOccurrenceInput[] | TaskOccurrenceAttachmentUncheckedCreateWithoutOccurrenceInput[]
    connectOrCreate?: TaskOccurrenceAttachmentCreateOrConnectWithoutOccurrenceInput | TaskOccurrenceAttachmentCreateOrConnectWithoutOccurrenceInput[]
    upsert?: TaskOccurrenceAttachmentUpsertWithWhereUniqueWithoutOccurrenceInput | TaskOccurrenceAttachmentUpsertWithWhereUniqueWithoutOccurrenceInput[]
    createMany?: TaskOccurrenceAttachmentCreateManyOccurrenceInputEnvelope
    set?: TaskOccurrenceAttachmentWhereUniqueInput | TaskOccurrenceAttachmentWhereUniqueInput[]
    disconnect?: TaskOccurrenceAttachmentWhereUniqueInput | TaskOccurrenceAttachmentWhereUniqueInput[]
    delete?: TaskOccurrenceAttachmentWhereUniqueInput | TaskOccurrenceAttachmentWhereUniqueInput[]
    connect?: TaskOccurrenceAttachmentWhereUniqueInput | TaskOccurrenceAttachmentWhereUniqueInput[]
    update?: TaskOccurrenceAttachmentUpdateWithWhereUniqueWithoutOccurrenceInput | TaskOccurrenceAttachmentUpdateWithWhereUniqueWithoutOccurrenceInput[]
    updateMany?: TaskOccurrenceAttachmentUpdateManyWithWhereWithoutOccurrenceInput | TaskOccurrenceAttachmentUpdateManyWithWhereWithoutOccurrenceInput[]
    deleteMany?: TaskOccurrenceAttachmentScalarWhereInput | TaskOccurrenceAttachmentScalarWhereInput[]
  }

  export type EmailLogUncheckedUpdateManyWithoutOccurrenceNestedInput = {
    create?: XOR<EmailLogCreateWithoutOccurrenceInput, EmailLogUncheckedCreateWithoutOccurrenceInput> | EmailLogCreateWithoutOccurrenceInput[] | EmailLogUncheckedCreateWithoutOccurrenceInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutOccurrenceInput | EmailLogCreateOrConnectWithoutOccurrenceInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutOccurrenceInput | EmailLogUpsertWithWhereUniqueWithoutOccurrenceInput[]
    createMany?: EmailLogCreateManyOccurrenceInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutOccurrenceInput | EmailLogUpdateWithWhereUniqueWithoutOccurrenceInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutOccurrenceInput | EmailLogUpdateManyWithWhereWithoutOccurrenceInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutAssigneesInput = {
    create?: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneesInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutAssigneesNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneesInput
    upsert?: TaskUpsertWithoutAssigneesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutAssigneesInput, TaskUpdateWithoutAssigneesInput>, TaskUncheckedUpdateWithoutAssigneesInput>
  }

  export type TaskOccurrenceCreateNestedOneWithoutAssigneesInput = {
    create?: XOR<TaskOccurrenceCreateWithoutAssigneesInput, TaskOccurrenceUncheckedCreateWithoutAssigneesInput>
    connectOrCreate?: TaskOccurrenceCreateOrConnectWithoutAssigneesInput
    connect?: TaskOccurrenceWhereUniqueInput
  }

  export type TaskOccurrenceUpdateOneRequiredWithoutAssigneesNestedInput = {
    create?: XOR<TaskOccurrenceCreateWithoutAssigneesInput, TaskOccurrenceUncheckedCreateWithoutAssigneesInput>
    connectOrCreate?: TaskOccurrenceCreateOrConnectWithoutAssigneesInput
    upsert?: TaskOccurrenceUpsertWithoutAssigneesInput
    connect?: TaskOccurrenceWhereUniqueInput
    update?: XOR<XOR<TaskOccurrenceUpdateToOneWithWhereWithoutAssigneesInput, TaskOccurrenceUpdateWithoutAssigneesInput>, TaskOccurrenceUncheckedUpdateWithoutAssigneesInput>
  }

  export type TaskCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAttachmentsInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAttachmentsInput
    upsert?: TaskUpsertWithoutAttachmentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutAttachmentsInput, TaskUpdateWithoutAttachmentsInput>, TaskUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TaskOccurrenceCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TaskOccurrenceCreateWithoutAttachmentsInput, TaskOccurrenceUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskOccurrenceCreateOrConnectWithoutAttachmentsInput
    connect?: TaskOccurrenceWhereUniqueInput
  }

  export type TaskOccurrenceUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<TaskOccurrenceCreateWithoutAttachmentsInput, TaskOccurrenceUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskOccurrenceCreateOrConnectWithoutAttachmentsInput
    upsert?: TaskOccurrenceUpsertWithoutAttachmentsInput
    connect?: TaskOccurrenceWhereUniqueInput
    update?: XOR<XOR<TaskOccurrenceUpdateToOneWithWhereWithoutAttachmentsInput, TaskOccurrenceUpdateWithoutAttachmentsInput>, TaskOccurrenceUncheckedUpdateWithoutAttachmentsInput>
  }

  export type EnumLogTypeFieldUpdateOperationsInput = {
    set?: $Enums.LogType
  }

  export type TaskCreateNestedOneWithoutRemindersInput = {
    create?: XOR<TaskCreateWithoutRemindersInput, TaskUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: TaskCreateOrConnectWithoutRemindersInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutRemindersNestedInput = {
    create?: XOR<TaskCreateWithoutRemindersInput, TaskUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: TaskCreateOrConnectWithoutRemindersInput
    upsert?: TaskUpsertWithoutRemindersInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutRemindersInput, TaskUpdateWithoutRemindersInput>, TaskUncheckedUpdateWithoutRemindersInput>
  }

  export type EnumCalendarEntryTypeFieldUpdateOperationsInput = {
    set?: $Enums.CalendarEntryType
  }

  export type NullableEnumRecurrenceFreqFieldUpdateOperationsInput = {
    set?: $Enums.RecurrenceFreq | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConversationMemberCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationMemberCreateWithoutConversationInput, ConversationMemberUncheckedCreateWithoutConversationInput> | ConversationMemberCreateWithoutConversationInput[] | ConversationMemberUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMemberCreateOrConnectWithoutConversationInput | ConversationMemberCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationMemberCreateManyConversationInputEnvelope
    connect?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationMemberUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationMemberCreateWithoutConversationInput, ConversationMemberUncheckedCreateWithoutConversationInput> | ConversationMemberCreateWithoutConversationInput[] | ConversationMemberUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMemberCreateOrConnectWithoutConversationInput | ConversationMemberCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationMemberCreateManyConversationInputEnvelope
    connect?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationMemberUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationMemberCreateWithoutConversationInput, ConversationMemberUncheckedCreateWithoutConversationInput> | ConversationMemberCreateWithoutConversationInput[] | ConversationMemberUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMemberCreateOrConnectWithoutConversationInput | ConversationMemberCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationMemberUpsertWithWhereUniqueWithoutConversationInput | ConversationMemberUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationMemberCreateManyConversationInputEnvelope
    set?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    disconnect?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    delete?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    connect?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    update?: ConversationMemberUpdateWithWhereUniqueWithoutConversationInput | ConversationMemberUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationMemberUpdateManyWithWhereWithoutConversationInput | ConversationMemberUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationMemberScalarWhereInput | ConversationMemberScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationMemberUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationMemberCreateWithoutConversationInput, ConversationMemberUncheckedCreateWithoutConversationInput> | ConversationMemberCreateWithoutConversationInput[] | ConversationMemberUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMemberCreateOrConnectWithoutConversationInput | ConversationMemberCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationMemberUpsertWithWhereUniqueWithoutConversationInput | ConversationMemberUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationMemberCreateManyConversationInputEnvelope
    set?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    disconnect?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    delete?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    connect?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    update?: ConversationMemberUpdateWithWhereUniqueWithoutConversationInput | ConversationMemberUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationMemberUpdateManyWithWhereWithoutConversationInput | ConversationMemberUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationMemberScalarWhereInput | ConversationMemberScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMembersInput = {
    create?: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMembersInput
    connect?: ConversationWhereUniqueInput
  }

  export type DirectoryUserCreateNestedOneWithoutMembersInput = {
    create?: XOR<DirectoryUserCreateWithoutMembersInput, DirectoryUserUncheckedCreateWithoutMembersInput>
    connectOrCreate?: DirectoryUserCreateOrConnectWithoutMembersInput
    connect?: DirectoryUserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMembersInput
    upsert?: ConversationUpsertWithoutMembersInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMembersInput, ConversationUpdateWithoutMembersInput>, ConversationUncheckedUpdateWithoutMembersInput>
  }

  export type DirectoryUserUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<DirectoryUserCreateWithoutMembersInput, DirectoryUserUncheckedCreateWithoutMembersInput>
    connectOrCreate?: DirectoryUserCreateOrConnectWithoutMembersInput
    upsert?: DirectoryUserUpsertWithoutMembersInput
    connect?: DirectoryUserWhereUniqueInput
    update?: XOR<XOR<DirectoryUserUpdateToOneWithWhereWithoutMembersInput, DirectoryUserUpdateWithoutMembersInput>, DirectoryUserUncheckedUpdateWithoutMembersInput>
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type DirectoryUserCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<DirectoryUserCreateWithoutMessagesSentInput, DirectoryUserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: DirectoryUserCreateOrConnectWithoutMessagesSentInput
    connect?: DirectoryUserWhereUniqueInput
  }

  export type MessageReadCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type MessageReadUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type DirectoryUserUpdateOneRequiredWithoutMessagesSentNestedInput = {
    create?: XOR<DirectoryUserCreateWithoutMessagesSentInput, DirectoryUserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: DirectoryUserCreateOrConnectWithoutMessagesSentInput
    upsert?: DirectoryUserUpsertWithoutMessagesSentInput
    connect?: DirectoryUserWhereUniqueInput
    update?: XOR<XOR<DirectoryUserUpdateToOneWithWhereWithoutMessagesSentInput, DirectoryUserUpdateWithoutMessagesSentInput>, DirectoryUserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type MessageReadUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutMessageInput | MessageReadUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutMessageInput | MessageReadUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutMessageInput | MessageReadUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type MessageReadUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutMessageInput | MessageReadUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutMessageInput | MessageReadUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutMessageInput | MessageReadUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutReadsInput = {
    create?: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReadsInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutReadsNestedInput = {
    create?: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReadsInput
    upsert?: MessageUpsertWithoutReadsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutReadsInput, MessageUpdateWithoutReadsInput>, MessageUncheckedUpdateWithoutReadsInput>
  }

  export type ConversationMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationMemberCreateWithoutUserInput, ConversationMemberUncheckedCreateWithoutUserInput> | ConversationMemberCreateWithoutUserInput[] | ConversationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationMemberCreateOrConnectWithoutUserInput | ConversationMemberCreateOrConnectWithoutUserInput[]
    createMany?: ConversationMemberCreateManyUserInputEnvelope
    connect?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationMemberCreateWithoutUserInput, ConversationMemberUncheckedCreateWithoutUserInput> | ConversationMemberCreateWithoutUserInput[] | ConversationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationMemberCreateOrConnectWithoutUserInput | ConversationMemberCreateOrConnectWithoutUserInput[]
    createMany?: ConversationMemberCreateManyUserInputEnvelope
    connect?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationMemberCreateWithoutUserInput, ConversationMemberUncheckedCreateWithoutUserInput> | ConversationMemberCreateWithoutUserInput[] | ConversationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationMemberCreateOrConnectWithoutUserInput | ConversationMemberCreateOrConnectWithoutUserInput[]
    upsert?: ConversationMemberUpsertWithWhereUniqueWithoutUserInput | ConversationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationMemberCreateManyUserInputEnvelope
    set?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    disconnect?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    delete?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    connect?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    update?: ConversationMemberUpdateWithWhereUniqueWithoutUserInput | ConversationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationMemberUpdateManyWithWhereWithoutUserInput | ConversationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationMemberScalarWhereInput | ConversationMemberScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationMemberCreateWithoutUserInput, ConversationMemberUncheckedCreateWithoutUserInput> | ConversationMemberCreateWithoutUserInput[] | ConversationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationMemberCreateOrConnectWithoutUserInput | ConversationMemberCreateOrConnectWithoutUserInput[]
    upsert?: ConversationMemberUpsertWithWhereUniqueWithoutUserInput | ConversationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationMemberCreateManyUserInputEnvelope
    set?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    disconnect?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    delete?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    connect?: ConversationMemberWhereUniqueInput | ConversationMemberWhereUniqueInput[]
    update?: ConversationMemberUpdateWithWhereUniqueWithoutUserInput | ConversationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationMemberUpdateManyWithWhereWithoutUserInput | ConversationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationMemberScalarWhereInput | ConversationMemberScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TaskOccurrenceCreateNestedOneWithoutEmailLogsInput = {
    create?: XOR<TaskOccurrenceCreateWithoutEmailLogsInput, TaskOccurrenceUncheckedCreateWithoutEmailLogsInput>
    connectOrCreate?: TaskOccurrenceCreateOrConnectWithoutEmailLogsInput
    connect?: TaskOccurrenceWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutEmailLogsInput = {
    create?: XOR<TaskCreateWithoutEmailLogsInput, TaskUncheckedCreateWithoutEmailLogsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutEmailLogsInput
    connect?: TaskWhereUniqueInput
  }

  export type EnumEmailStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmailStatus
  }

  export type TaskOccurrenceUpdateOneWithoutEmailLogsNestedInput = {
    create?: XOR<TaskOccurrenceCreateWithoutEmailLogsInput, TaskOccurrenceUncheckedCreateWithoutEmailLogsInput>
    connectOrCreate?: TaskOccurrenceCreateOrConnectWithoutEmailLogsInput
    upsert?: TaskOccurrenceUpsertWithoutEmailLogsInput
    disconnect?: TaskOccurrenceWhereInput | boolean
    delete?: TaskOccurrenceWhereInput | boolean
    connect?: TaskOccurrenceWhereUniqueInput
    update?: XOR<XOR<TaskOccurrenceUpdateToOneWithWhereWithoutEmailLogsInput, TaskOccurrenceUpdateWithoutEmailLogsInput>, TaskOccurrenceUncheckedUpdateWithoutEmailLogsInput>
  }

  export type TaskUpdateOneWithoutEmailLogsNestedInput = {
    create?: XOR<TaskCreateWithoutEmailLogsInput, TaskUncheckedCreateWithoutEmailLogsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutEmailLogsInput
    upsert?: TaskUpsertWithoutEmailLogsInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutEmailLogsInput, TaskUpdateWithoutEmailLogsInput>, TaskUncheckedUpdateWithoutEmailLogsInput>
  }

  export type EnumLeaveTypeFieldUpdateOperationsInput = {
    set?: $Enums.LeaveType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumLeaveStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStatus
  }

  export type LicenseCreateremindOffsetsInput = {
    set: number[]
  }

  export type LicenseAssigneeCreateNestedManyWithoutLicenseInput = {
    create?: XOR<LicenseAssigneeCreateWithoutLicenseInput, LicenseAssigneeUncheckedCreateWithoutLicenseInput> | LicenseAssigneeCreateWithoutLicenseInput[] | LicenseAssigneeUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: LicenseAssigneeCreateOrConnectWithoutLicenseInput | LicenseAssigneeCreateOrConnectWithoutLicenseInput[]
    createMany?: LicenseAssigneeCreateManyLicenseInputEnvelope
    connect?: LicenseAssigneeWhereUniqueInput | LicenseAssigneeWhereUniqueInput[]
  }

  export type LicenseHistoryCreateNestedManyWithoutLicenseInput = {
    create?: XOR<LicenseHistoryCreateWithoutLicenseInput, LicenseHistoryUncheckedCreateWithoutLicenseInput> | LicenseHistoryCreateWithoutLicenseInput[] | LicenseHistoryUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: LicenseHistoryCreateOrConnectWithoutLicenseInput | LicenseHistoryCreateOrConnectWithoutLicenseInput[]
    createMany?: LicenseHistoryCreateManyLicenseInputEnvelope
    connect?: LicenseHistoryWhereUniqueInput | LicenseHistoryWhereUniqueInput[]
  }

  export type LicenseAttachmentCreateNestedManyWithoutLicenseInput = {
    create?: XOR<LicenseAttachmentCreateWithoutLicenseInput, LicenseAttachmentUncheckedCreateWithoutLicenseInput> | LicenseAttachmentCreateWithoutLicenseInput[] | LicenseAttachmentUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: LicenseAttachmentCreateOrConnectWithoutLicenseInput | LicenseAttachmentCreateOrConnectWithoutLicenseInput[]
    createMany?: LicenseAttachmentCreateManyLicenseInputEnvelope
    connect?: LicenseAttachmentWhereUniqueInput | LicenseAttachmentWhereUniqueInput[]
  }

  export type ScheduledReminderCreateNestedManyWithoutLicenseInput = {
    create?: XOR<ScheduledReminderCreateWithoutLicenseInput, ScheduledReminderUncheckedCreateWithoutLicenseInput> | ScheduledReminderCreateWithoutLicenseInput[] | ScheduledReminderUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: ScheduledReminderCreateOrConnectWithoutLicenseInput | ScheduledReminderCreateOrConnectWithoutLicenseInput[]
    createMany?: ScheduledReminderCreateManyLicenseInputEnvelope
    connect?: ScheduledReminderWhereUniqueInput | ScheduledReminderWhereUniqueInput[]
  }

  export type LicenseAssigneeUncheckedCreateNestedManyWithoutLicenseInput = {
    create?: XOR<LicenseAssigneeCreateWithoutLicenseInput, LicenseAssigneeUncheckedCreateWithoutLicenseInput> | LicenseAssigneeCreateWithoutLicenseInput[] | LicenseAssigneeUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: LicenseAssigneeCreateOrConnectWithoutLicenseInput | LicenseAssigneeCreateOrConnectWithoutLicenseInput[]
    createMany?: LicenseAssigneeCreateManyLicenseInputEnvelope
    connect?: LicenseAssigneeWhereUniqueInput | LicenseAssigneeWhereUniqueInput[]
  }

  export type LicenseHistoryUncheckedCreateNestedManyWithoutLicenseInput = {
    create?: XOR<LicenseHistoryCreateWithoutLicenseInput, LicenseHistoryUncheckedCreateWithoutLicenseInput> | LicenseHistoryCreateWithoutLicenseInput[] | LicenseHistoryUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: LicenseHistoryCreateOrConnectWithoutLicenseInput | LicenseHistoryCreateOrConnectWithoutLicenseInput[]
    createMany?: LicenseHistoryCreateManyLicenseInputEnvelope
    connect?: LicenseHistoryWhereUniqueInput | LicenseHistoryWhereUniqueInput[]
  }

  export type LicenseAttachmentUncheckedCreateNestedManyWithoutLicenseInput = {
    create?: XOR<LicenseAttachmentCreateWithoutLicenseInput, LicenseAttachmentUncheckedCreateWithoutLicenseInput> | LicenseAttachmentCreateWithoutLicenseInput[] | LicenseAttachmentUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: LicenseAttachmentCreateOrConnectWithoutLicenseInput | LicenseAttachmentCreateOrConnectWithoutLicenseInput[]
    createMany?: LicenseAttachmentCreateManyLicenseInputEnvelope
    connect?: LicenseAttachmentWhereUniqueInput | LicenseAttachmentWhereUniqueInput[]
  }

  export type ScheduledReminderUncheckedCreateNestedManyWithoutLicenseInput = {
    create?: XOR<ScheduledReminderCreateWithoutLicenseInput, ScheduledReminderUncheckedCreateWithoutLicenseInput> | ScheduledReminderCreateWithoutLicenseInput[] | ScheduledReminderUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: ScheduledReminderCreateOrConnectWithoutLicenseInput | ScheduledReminderCreateOrConnectWithoutLicenseInput[]
    createMany?: ScheduledReminderCreateManyLicenseInputEnvelope
    connect?: ScheduledReminderWhereUniqueInput | ScheduledReminderWhereUniqueInput[]
  }

  export type LicenseUpdateremindOffsetsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type NullableEnumLicenseStatusFieldUpdateOperationsInput = {
    set?: $Enums.LicenseStatus | null
  }

  export type LicenseAssigneeUpdateManyWithoutLicenseNestedInput = {
    create?: XOR<LicenseAssigneeCreateWithoutLicenseInput, LicenseAssigneeUncheckedCreateWithoutLicenseInput> | LicenseAssigneeCreateWithoutLicenseInput[] | LicenseAssigneeUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: LicenseAssigneeCreateOrConnectWithoutLicenseInput | LicenseAssigneeCreateOrConnectWithoutLicenseInput[]
    upsert?: LicenseAssigneeUpsertWithWhereUniqueWithoutLicenseInput | LicenseAssigneeUpsertWithWhereUniqueWithoutLicenseInput[]
    createMany?: LicenseAssigneeCreateManyLicenseInputEnvelope
    set?: LicenseAssigneeWhereUniqueInput | LicenseAssigneeWhereUniqueInput[]
    disconnect?: LicenseAssigneeWhereUniqueInput | LicenseAssigneeWhereUniqueInput[]
    delete?: LicenseAssigneeWhereUniqueInput | LicenseAssigneeWhereUniqueInput[]
    connect?: LicenseAssigneeWhereUniqueInput | LicenseAssigneeWhereUniqueInput[]
    update?: LicenseAssigneeUpdateWithWhereUniqueWithoutLicenseInput | LicenseAssigneeUpdateWithWhereUniqueWithoutLicenseInput[]
    updateMany?: LicenseAssigneeUpdateManyWithWhereWithoutLicenseInput | LicenseAssigneeUpdateManyWithWhereWithoutLicenseInput[]
    deleteMany?: LicenseAssigneeScalarWhereInput | LicenseAssigneeScalarWhereInput[]
  }

  export type LicenseHistoryUpdateManyWithoutLicenseNestedInput = {
    create?: XOR<LicenseHistoryCreateWithoutLicenseInput, LicenseHistoryUncheckedCreateWithoutLicenseInput> | LicenseHistoryCreateWithoutLicenseInput[] | LicenseHistoryUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: LicenseHistoryCreateOrConnectWithoutLicenseInput | LicenseHistoryCreateOrConnectWithoutLicenseInput[]
    upsert?: LicenseHistoryUpsertWithWhereUniqueWithoutLicenseInput | LicenseHistoryUpsertWithWhereUniqueWithoutLicenseInput[]
    createMany?: LicenseHistoryCreateManyLicenseInputEnvelope
    set?: LicenseHistoryWhereUniqueInput | LicenseHistoryWhereUniqueInput[]
    disconnect?: LicenseHistoryWhereUniqueInput | LicenseHistoryWhereUniqueInput[]
    delete?: LicenseHistoryWhereUniqueInput | LicenseHistoryWhereUniqueInput[]
    connect?: LicenseHistoryWhereUniqueInput | LicenseHistoryWhereUniqueInput[]
    update?: LicenseHistoryUpdateWithWhereUniqueWithoutLicenseInput | LicenseHistoryUpdateWithWhereUniqueWithoutLicenseInput[]
    updateMany?: LicenseHistoryUpdateManyWithWhereWithoutLicenseInput | LicenseHistoryUpdateManyWithWhereWithoutLicenseInput[]
    deleteMany?: LicenseHistoryScalarWhereInput | LicenseHistoryScalarWhereInput[]
  }

  export type LicenseAttachmentUpdateManyWithoutLicenseNestedInput = {
    create?: XOR<LicenseAttachmentCreateWithoutLicenseInput, LicenseAttachmentUncheckedCreateWithoutLicenseInput> | LicenseAttachmentCreateWithoutLicenseInput[] | LicenseAttachmentUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: LicenseAttachmentCreateOrConnectWithoutLicenseInput | LicenseAttachmentCreateOrConnectWithoutLicenseInput[]
    upsert?: LicenseAttachmentUpsertWithWhereUniqueWithoutLicenseInput | LicenseAttachmentUpsertWithWhereUniqueWithoutLicenseInput[]
    createMany?: LicenseAttachmentCreateManyLicenseInputEnvelope
    set?: LicenseAttachmentWhereUniqueInput | LicenseAttachmentWhereUniqueInput[]
    disconnect?: LicenseAttachmentWhereUniqueInput | LicenseAttachmentWhereUniqueInput[]
    delete?: LicenseAttachmentWhereUniqueInput | LicenseAttachmentWhereUniqueInput[]
    connect?: LicenseAttachmentWhereUniqueInput | LicenseAttachmentWhereUniqueInput[]
    update?: LicenseAttachmentUpdateWithWhereUniqueWithoutLicenseInput | LicenseAttachmentUpdateWithWhereUniqueWithoutLicenseInput[]
    updateMany?: LicenseAttachmentUpdateManyWithWhereWithoutLicenseInput | LicenseAttachmentUpdateManyWithWhereWithoutLicenseInput[]
    deleteMany?: LicenseAttachmentScalarWhereInput | LicenseAttachmentScalarWhereInput[]
  }

  export type ScheduledReminderUpdateManyWithoutLicenseNestedInput = {
    create?: XOR<ScheduledReminderCreateWithoutLicenseInput, ScheduledReminderUncheckedCreateWithoutLicenseInput> | ScheduledReminderCreateWithoutLicenseInput[] | ScheduledReminderUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: ScheduledReminderCreateOrConnectWithoutLicenseInput | ScheduledReminderCreateOrConnectWithoutLicenseInput[]
    upsert?: ScheduledReminderUpsertWithWhereUniqueWithoutLicenseInput | ScheduledReminderUpsertWithWhereUniqueWithoutLicenseInput[]
    createMany?: ScheduledReminderCreateManyLicenseInputEnvelope
    set?: ScheduledReminderWhereUniqueInput | ScheduledReminderWhereUniqueInput[]
    disconnect?: ScheduledReminderWhereUniqueInput | ScheduledReminderWhereUniqueInput[]
    delete?: ScheduledReminderWhereUniqueInput | ScheduledReminderWhereUniqueInput[]
    connect?: ScheduledReminderWhereUniqueInput | ScheduledReminderWhereUniqueInput[]
    update?: ScheduledReminderUpdateWithWhereUniqueWithoutLicenseInput | ScheduledReminderUpdateWithWhereUniqueWithoutLicenseInput[]
    updateMany?: ScheduledReminderUpdateManyWithWhereWithoutLicenseInput | ScheduledReminderUpdateManyWithWhereWithoutLicenseInput[]
    deleteMany?: ScheduledReminderScalarWhereInput | ScheduledReminderScalarWhereInput[]
  }

  export type LicenseAssigneeUncheckedUpdateManyWithoutLicenseNestedInput = {
    create?: XOR<LicenseAssigneeCreateWithoutLicenseInput, LicenseAssigneeUncheckedCreateWithoutLicenseInput> | LicenseAssigneeCreateWithoutLicenseInput[] | LicenseAssigneeUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: LicenseAssigneeCreateOrConnectWithoutLicenseInput | LicenseAssigneeCreateOrConnectWithoutLicenseInput[]
    upsert?: LicenseAssigneeUpsertWithWhereUniqueWithoutLicenseInput | LicenseAssigneeUpsertWithWhereUniqueWithoutLicenseInput[]
    createMany?: LicenseAssigneeCreateManyLicenseInputEnvelope
    set?: LicenseAssigneeWhereUniqueInput | LicenseAssigneeWhereUniqueInput[]
    disconnect?: LicenseAssigneeWhereUniqueInput | LicenseAssigneeWhereUniqueInput[]
    delete?: LicenseAssigneeWhereUniqueInput | LicenseAssigneeWhereUniqueInput[]
    connect?: LicenseAssigneeWhereUniqueInput | LicenseAssigneeWhereUniqueInput[]
    update?: LicenseAssigneeUpdateWithWhereUniqueWithoutLicenseInput | LicenseAssigneeUpdateWithWhereUniqueWithoutLicenseInput[]
    updateMany?: LicenseAssigneeUpdateManyWithWhereWithoutLicenseInput | LicenseAssigneeUpdateManyWithWhereWithoutLicenseInput[]
    deleteMany?: LicenseAssigneeScalarWhereInput | LicenseAssigneeScalarWhereInput[]
  }

  export type LicenseHistoryUncheckedUpdateManyWithoutLicenseNestedInput = {
    create?: XOR<LicenseHistoryCreateWithoutLicenseInput, LicenseHistoryUncheckedCreateWithoutLicenseInput> | LicenseHistoryCreateWithoutLicenseInput[] | LicenseHistoryUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: LicenseHistoryCreateOrConnectWithoutLicenseInput | LicenseHistoryCreateOrConnectWithoutLicenseInput[]
    upsert?: LicenseHistoryUpsertWithWhereUniqueWithoutLicenseInput | LicenseHistoryUpsertWithWhereUniqueWithoutLicenseInput[]
    createMany?: LicenseHistoryCreateManyLicenseInputEnvelope
    set?: LicenseHistoryWhereUniqueInput | LicenseHistoryWhereUniqueInput[]
    disconnect?: LicenseHistoryWhereUniqueInput | LicenseHistoryWhereUniqueInput[]
    delete?: LicenseHistoryWhereUniqueInput | LicenseHistoryWhereUniqueInput[]
    connect?: LicenseHistoryWhereUniqueInput | LicenseHistoryWhereUniqueInput[]
    update?: LicenseHistoryUpdateWithWhereUniqueWithoutLicenseInput | LicenseHistoryUpdateWithWhereUniqueWithoutLicenseInput[]
    updateMany?: LicenseHistoryUpdateManyWithWhereWithoutLicenseInput | LicenseHistoryUpdateManyWithWhereWithoutLicenseInput[]
    deleteMany?: LicenseHistoryScalarWhereInput | LicenseHistoryScalarWhereInput[]
  }

  export type LicenseAttachmentUncheckedUpdateManyWithoutLicenseNestedInput = {
    create?: XOR<LicenseAttachmentCreateWithoutLicenseInput, LicenseAttachmentUncheckedCreateWithoutLicenseInput> | LicenseAttachmentCreateWithoutLicenseInput[] | LicenseAttachmentUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: LicenseAttachmentCreateOrConnectWithoutLicenseInput | LicenseAttachmentCreateOrConnectWithoutLicenseInput[]
    upsert?: LicenseAttachmentUpsertWithWhereUniqueWithoutLicenseInput | LicenseAttachmentUpsertWithWhereUniqueWithoutLicenseInput[]
    createMany?: LicenseAttachmentCreateManyLicenseInputEnvelope
    set?: LicenseAttachmentWhereUniqueInput | LicenseAttachmentWhereUniqueInput[]
    disconnect?: LicenseAttachmentWhereUniqueInput | LicenseAttachmentWhereUniqueInput[]
    delete?: LicenseAttachmentWhereUniqueInput | LicenseAttachmentWhereUniqueInput[]
    connect?: LicenseAttachmentWhereUniqueInput | LicenseAttachmentWhereUniqueInput[]
    update?: LicenseAttachmentUpdateWithWhereUniqueWithoutLicenseInput | LicenseAttachmentUpdateWithWhereUniqueWithoutLicenseInput[]
    updateMany?: LicenseAttachmentUpdateManyWithWhereWithoutLicenseInput | LicenseAttachmentUpdateManyWithWhereWithoutLicenseInput[]
    deleteMany?: LicenseAttachmentScalarWhereInput | LicenseAttachmentScalarWhereInput[]
  }

  export type ScheduledReminderUncheckedUpdateManyWithoutLicenseNestedInput = {
    create?: XOR<ScheduledReminderCreateWithoutLicenseInput, ScheduledReminderUncheckedCreateWithoutLicenseInput> | ScheduledReminderCreateWithoutLicenseInput[] | ScheduledReminderUncheckedCreateWithoutLicenseInput[]
    connectOrCreate?: ScheduledReminderCreateOrConnectWithoutLicenseInput | ScheduledReminderCreateOrConnectWithoutLicenseInput[]
    upsert?: ScheduledReminderUpsertWithWhereUniqueWithoutLicenseInput | ScheduledReminderUpsertWithWhereUniqueWithoutLicenseInput[]
    createMany?: ScheduledReminderCreateManyLicenseInputEnvelope
    set?: ScheduledReminderWhereUniqueInput | ScheduledReminderWhereUniqueInput[]
    disconnect?: ScheduledReminderWhereUniqueInput | ScheduledReminderWhereUniqueInput[]
    delete?: ScheduledReminderWhereUniqueInput | ScheduledReminderWhereUniqueInput[]
    connect?: ScheduledReminderWhereUniqueInput | ScheduledReminderWhereUniqueInput[]
    update?: ScheduledReminderUpdateWithWhereUniqueWithoutLicenseInput | ScheduledReminderUpdateWithWhereUniqueWithoutLicenseInput[]
    updateMany?: ScheduledReminderUpdateManyWithWhereWithoutLicenseInput | ScheduledReminderUpdateManyWithWhereWithoutLicenseInput[]
    deleteMany?: ScheduledReminderScalarWhereInput | ScheduledReminderScalarWhereInput[]
  }

  export type LicenseCreateNestedOneWithoutAssigneesInput = {
    create?: XOR<LicenseCreateWithoutAssigneesInput, LicenseUncheckedCreateWithoutAssigneesInput>
    connectOrCreate?: LicenseCreateOrConnectWithoutAssigneesInput
    connect?: LicenseWhereUniqueInput
  }

  export type EnumLicenseAssigneeRoleFieldUpdateOperationsInput = {
    set?: $Enums.LicenseAssigneeRole
  }

  export type LicenseUpdateOneRequiredWithoutAssigneesNestedInput = {
    create?: XOR<LicenseCreateWithoutAssigneesInput, LicenseUncheckedCreateWithoutAssigneesInput>
    connectOrCreate?: LicenseCreateOrConnectWithoutAssigneesInput
    upsert?: LicenseUpsertWithoutAssigneesInput
    connect?: LicenseWhereUniqueInput
    update?: XOR<XOR<LicenseUpdateToOneWithWhereWithoutAssigneesInput, LicenseUpdateWithoutAssigneesInput>, LicenseUncheckedUpdateWithoutAssigneesInput>
  }

  export type LicenseCreateNestedOneWithoutHistoriesInput = {
    create?: XOR<LicenseCreateWithoutHistoriesInput, LicenseUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: LicenseCreateOrConnectWithoutHistoriesInput
    connect?: LicenseWhereUniqueInput
  }

  export type LicenseUpdateOneRequiredWithoutHistoriesNestedInput = {
    create?: XOR<LicenseCreateWithoutHistoriesInput, LicenseUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: LicenseCreateOrConnectWithoutHistoriesInput
    upsert?: LicenseUpsertWithoutHistoriesInput
    connect?: LicenseWhereUniqueInput
    update?: XOR<XOR<LicenseUpdateToOneWithWhereWithoutHistoriesInput, LicenseUpdateWithoutHistoriesInput>, LicenseUncheckedUpdateWithoutHistoriesInput>
  }

  export type LicenseCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<LicenseCreateWithoutAttachmentsInput, LicenseUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: LicenseCreateOrConnectWithoutAttachmentsInput
    connect?: LicenseWhereUniqueInput
  }

  export type LicenseUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<LicenseCreateWithoutAttachmentsInput, LicenseUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: LicenseCreateOrConnectWithoutAttachmentsInput
    upsert?: LicenseUpsertWithoutAttachmentsInput
    connect?: LicenseWhereUniqueInput
    update?: XOR<XOR<LicenseUpdateToOneWithWhereWithoutAttachmentsInput, LicenseUpdateWithoutAttachmentsInput>, LicenseUncheckedUpdateWithoutAttachmentsInput>
  }

  export type LicenseCreateNestedOneWithoutScheduledRemindersInput = {
    create?: XOR<LicenseCreateWithoutScheduledRemindersInput, LicenseUncheckedCreateWithoutScheduledRemindersInput>
    connectOrCreate?: LicenseCreateOrConnectWithoutScheduledRemindersInput
    connect?: LicenseWhereUniqueInput
  }

  export type EnumReminderStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReminderStatus
  }

  export type LicenseUpdateOneRequiredWithoutScheduledRemindersNestedInput = {
    create?: XOR<LicenseCreateWithoutScheduledRemindersInput, LicenseUncheckedCreateWithoutScheduledRemindersInput>
    connectOrCreate?: LicenseCreateOrConnectWithoutScheduledRemindersInput
    upsert?: LicenseUpsertWithoutScheduledRemindersInput
    connect?: LicenseWhereUniqueInput
    update?: XOR<XOR<LicenseUpdateToOneWithWhereWithoutScheduledRemindersInput, LicenseUpdateWithoutScheduledRemindersInput>, LicenseUncheckedUpdateWithoutScheduledRemindersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumClientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusFilter<$PrismaModel> | $Enums.ClientStatus
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumClientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientStatusFilter<$PrismaModel>
    _max?: NestedEnumClientStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumLogTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LogType | EnumLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLogTypeFilter<$PrismaModel> | $Enums.LogType
  }

  export type NestedEnumLogTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogType | EnumLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLogTypeWithAggregatesFilter<$PrismaModel> | $Enums.LogType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogTypeFilter<$PrismaModel>
    _max?: NestedEnumLogTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCalendarEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarEntryType | EnumCalendarEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarEntryType[] | ListEnumCalendarEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarEntryType[] | ListEnumCalendarEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarEntryTypeFilter<$PrismaModel> | $Enums.CalendarEntryType
  }

  export type NestedEnumRecurrenceFreqNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceFreq | EnumRecurrenceFreqFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurrenceFreq[] | ListEnumRecurrenceFreqFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurrenceFreq[] | ListEnumRecurrenceFreqFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrenceFreqNullableFilter<$PrismaModel> | $Enums.RecurrenceFreq | null
  }

  export type NestedEnumCalendarEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarEntryType | EnumCalendarEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarEntryType[] | ListEnumCalendarEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarEntryType[] | ListEnumCalendarEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.CalendarEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumCalendarEntryTypeFilter<$PrismaModel>
  }

  export type NestedEnumRecurrenceFreqNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceFreq | EnumRecurrenceFreqFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurrenceFreq[] | ListEnumRecurrenceFreqFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurrenceFreq[] | ListEnumRecurrenceFreqFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrenceFreqNullableWithAggregatesFilter<$PrismaModel> | $Enums.RecurrenceFreq | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecurrenceFreqNullableFilter<$PrismaModel>
    _max?: NestedEnumRecurrenceFreqNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEmailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusFilter<$PrismaModel> | $Enums.EmailStatus
  }

  export type NestedEnumEmailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailStatusFilter<$PrismaModel>
    _max?: NestedEnumEmailStatusFilter<$PrismaModel>
  }

  export type NestedEnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type NestedEnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveType[] | ListEnumLeaveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type NestedEnumLicenseStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLicenseStatusNullableFilter<$PrismaModel> | $Enums.LicenseStatus | null
  }

  export type NestedEnumLicenseStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LicenseStatus[] | ListEnumLicenseStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLicenseStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.LicenseStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLicenseStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumLicenseStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumLicenseAssigneeRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseAssigneeRole | EnumLicenseAssigneeRoleFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseAssigneeRole[] | ListEnumLicenseAssigneeRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseAssigneeRole[] | ListEnumLicenseAssigneeRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseAssigneeRoleFilter<$PrismaModel> | $Enums.LicenseAssigneeRole
  }

  export type NestedEnumLicenseAssigneeRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseAssigneeRole | EnumLicenseAssigneeRoleFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseAssigneeRole[] | ListEnumLicenseAssigneeRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseAssigneeRole[] | ListEnumLicenseAssigneeRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseAssigneeRoleWithAggregatesFilter<$PrismaModel> | $Enums.LicenseAssigneeRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLicenseAssigneeRoleFilter<$PrismaModel>
    _max?: NestedEnumLicenseAssigneeRoleFilter<$PrismaModel>
  }

  export type NestedEnumReminderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusFilter<$PrismaModel> | $Enums.ReminderStatus
  }

  export type NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReminderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderStatusFilter<$PrismaModel>
    _max?: NestedEnumReminderStatusFilter<$PrismaModel>
  }

  export type TaskCreateWithoutProjectInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    occurrences?: TaskOccurrenceCreateNestedManyWithoutTaskInput
    reminders?: ReminderCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    occurrences?: TaskOccurrenceUncheckedCreateNestedManyWithoutTaskInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    taskId?: IntFilter<"Task"> | number
    clientId?: StringNullableFilter<"Task"> | string | null
    projectId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    startDate?: DateTimeFilter<"Task"> | Date | string
    dueDate?: DateTimeFilter<"Task"> | Date | string
    assignedToId?: StringNullableFilter<"Task"> | string | null
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    remarks?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    recurrenceRule?: StringNullableFilter<"Task"> | string | null
    recurrenceEndDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    isRecurring?: BoolFilter<"Task"> | boolean
    lastGeneratedUntil?: DateTimeNullableFilter<"Task"> | Date | string | null
    retainSubtasks?: BoolFilter<"Task"> | boolean
    createdById?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    clientMailSendCount?: IntFilter<"Task"> | number
  }

  export type TaskAssigneeCreateWithoutTaskInput = {
    id?: string
    userId: string
  }

  export type TaskAssigneeUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
  }

  export type TaskAssigneeCreateOrConnectWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput
    create: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssigneeCreateManyTaskInputEnvelope = {
    data: TaskAssigneeCreateManyTaskInput | TaskAssigneeCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskOccurrenceCreateWithoutTaskInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    completedBy?: string | null
    completionNote?: string | null
    clientId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sequentialId?: number
    clientMailSendCount?: number
    startEmailSent?: boolean
    startEmailSentAt?: Date | string | null
    assignees?: TaskOccurrenceAssigneeCreateNestedManyWithoutOccurrenceInput
    attachments?: TaskOccurrenceAttachmentCreateNestedManyWithoutOccurrenceInput
    emailLogs?: EmailLogCreateNestedManyWithoutOccurrenceInput
  }

  export type TaskOccurrenceUncheckedCreateWithoutTaskInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    completedBy?: string | null
    completionNote?: string | null
    clientId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sequentialId?: number
    clientMailSendCount?: number
    startEmailSent?: boolean
    startEmailSentAt?: Date | string | null
    assignees?: TaskOccurrenceAssigneeUncheckedCreateNestedManyWithoutOccurrenceInput
    attachments?: TaskOccurrenceAttachmentUncheckedCreateNestedManyWithoutOccurrenceInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutOccurrenceInput
  }

  export type TaskOccurrenceCreateOrConnectWithoutTaskInput = {
    where: TaskOccurrenceWhereUniqueInput
    create: XOR<TaskOccurrenceCreateWithoutTaskInput, TaskOccurrenceUncheckedCreateWithoutTaskInput>
  }

  export type TaskOccurrenceCreateManyTaskInputEnvelope = {
    data: TaskOccurrenceCreateManyTaskInput | TaskOccurrenceCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type ReminderCreateWithoutTaskInput = {
    id?: string
    occurrenceAt: Date | string
    remindAt: Date | string
    channel?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: boolean
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReminderUncheckedCreateWithoutTaskInput = {
    id?: string
    occurrenceAt: Date | string
    remindAt: Date | string
    channel?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: boolean
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReminderCreateOrConnectWithoutTaskInput = {
    where: ReminderWhereUniqueInput
    create: XOR<ReminderCreateWithoutTaskInput, ReminderUncheckedCreateWithoutTaskInput>
  }

  export type ReminderCreateManyTaskInputEnvelope = {
    data: ReminderCreateManyTaskInput | ReminderCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutTasksInput = {
    id?: string
    name: string
    head?: string | null
    taskId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    head?: string | null
    taskId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type TaskAttachmentCreateWithoutTaskInput = {
    id?: string
    key: string
    createdAt?: Date | string
  }

  export type TaskAttachmentUncheckedCreateWithoutTaskInput = {
    id?: string
    key: string
    createdAt?: Date | string
  }

  export type TaskAttachmentCreateOrConnectWithoutTaskInput = {
    where: TaskAttachmentWhereUniqueInput
    create: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskAttachmentCreateManyTaskInputEnvelope = {
    data: TaskAttachmentCreateManyTaskInput | TaskAttachmentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskCustomValueCreateWithoutTaskInput = {
    id?: string
    value: string
    field: TaskCustomFieldCreateNestedOneWithoutValuesInput
  }

  export type TaskCustomValueUncheckedCreateWithoutTaskInput = {
    id?: string
    fieldId: string
    value: string
  }

  export type TaskCustomValueCreateOrConnectWithoutTaskInput = {
    where: TaskCustomValueWhereUniqueInput
    create: XOR<TaskCustomValueCreateWithoutTaskInput, TaskCustomValueUncheckedCreateWithoutTaskInput>
  }

  export type TaskCustomValueCreateManyTaskInputEnvelope = {
    data: TaskCustomValueCreateManyTaskInput | TaskCustomValueCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type EmailLogCreateWithoutTaskInput = {
    id?: string
    recipient: string
    subject?: string | null
    body?: string | null
    provider?: string | null
    providerMessageId?: string | null
    status?: $Enums.EmailStatus
    error?: string | null
    createdAt?: Date | string
    occurrence?: TaskOccurrenceCreateNestedOneWithoutEmailLogsInput
  }

  export type EmailLogUncheckedCreateWithoutTaskInput = {
    id?: string
    occurrenceId?: string | null
    recipient: string
    subject?: string | null
    body?: string | null
    provider?: string | null
    providerMessageId?: string | null
    status?: $Enums.EmailStatus
    error?: string | null
    createdAt?: Date | string
  }

  export type EmailLogCreateOrConnectWithoutTaskInput = {
    where: EmailLogWhereUniqueInput
    create: XOR<EmailLogCreateWithoutTaskInput, EmailLogUncheckedCreateWithoutTaskInput>
  }

  export type EmailLogCreateManyTaskInputEnvelope = {
    data: EmailLogCreateManyTaskInput | EmailLogCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskAssigneeUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput
    update: XOR<TaskAssigneeUpdateWithoutTaskInput, TaskAssigneeUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskAssigneeCreateWithoutTaskInput, TaskAssigneeUncheckedCreateWithoutTaskInput>
  }

  export type TaskAssigneeUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAssigneeWhereUniqueInput
    data: XOR<TaskAssigneeUpdateWithoutTaskInput, TaskAssigneeUncheckedUpdateWithoutTaskInput>
  }

  export type TaskAssigneeUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAssigneeScalarWhereInput
    data: XOR<TaskAssigneeUpdateManyMutationInput, TaskAssigneeUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskAssigneeScalarWhereInput = {
    AND?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
    OR?: TaskAssigneeScalarWhereInput[]
    NOT?: TaskAssigneeScalarWhereInput | TaskAssigneeScalarWhereInput[]
    id?: StringFilter<"TaskAssignee"> | string
    taskId?: StringFilter<"TaskAssignee"> | string
    userId?: StringFilter<"TaskAssignee"> | string
  }

  export type TaskOccurrenceUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskOccurrenceWhereUniqueInput
    update: XOR<TaskOccurrenceUpdateWithoutTaskInput, TaskOccurrenceUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskOccurrenceCreateWithoutTaskInput, TaskOccurrenceUncheckedCreateWithoutTaskInput>
  }

  export type TaskOccurrenceUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskOccurrenceWhereUniqueInput
    data: XOR<TaskOccurrenceUpdateWithoutTaskInput, TaskOccurrenceUncheckedUpdateWithoutTaskInput>
  }

  export type TaskOccurrenceUpdateManyWithWhereWithoutTaskInput = {
    where: TaskOccurrenceScalarWhereInput
    data: XOR<TaskOccurrenceUpdateManyMutationInput, TaskOccurrenceUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskOccurrenceScalarWhereInput = {
    AND?: TaskOccurrenceScalarWhereInput | TaskOccurrenceScalarWhereInput[]
    OR?: TaskOccurrenceScalarWhereInput[]
    NOT?: TaskOccurrenceScalarWhereInput | TaskOccurrenceScalarWhereInput[]
    id?: StringFilter<"TaskOccurrence"> | string
    taskId?: StringFilter<"TaskOccurrence"> | string
    title?: StringFilter<"TaskOccurrence"> | string
    description?: StringNullableFilter<"TaskOccurrence"> | string | null
    startDate?: DateTimeFilter<"TaskOccurrence"> | Date | string
    dueDate?: DateTimeFilter<"TaskOccurrence"> | Date | string
    assignedToId?: StringNullableFilter<"TaskOccurrence"> | string | null
    priority?: EnumPriorityFilter<"TaskOccurrence"> | $Enums.Priority
    remarks?: StringNullableFilter<"TaskOccurrence"> | string | null
    status?: EnumTaskStatusFilter<"TaskOccurrence"> | $Enums.TaskStatus
    occurrenceIndex?: IntFilter<"TaskOccurrence"> | number
    isCompleted?: BoolFilter<"TaskOccurrence"> | boolean
    completedAt?: DateTimeNullableFilter<"TaskOccurrence"> | Date | string | null
    completedBy?: StringNullableFilter<"TaskOccurrence"> | string | null
    completionNote?: StringNullableFilter<"TaskOccurrence"> | string | null
    clientId?: StringNullableFilter<"TaskOccurrence"> | string | null
    projectId?: StringNullableFilter<"TaskOccurrence"> | string | null
    createdAt?: DateTimeFilter<"TaskOccurrence"> | Date | string
    updatedAt?: DateTimeFilter<"TaskOccurrence"> | Date | string
    sequentialId?: IntFilter<"TaskOccurrence"> | number
    clientMailSendCount?: IntFilter<"TaskOccurrence"> | number
    startEmailSent?: BoolFilter<"TaskOccurrence"> | boolean
    startEmailSentAt?: DateTimeNullableFilter<"TaskOccurrence"> | Date | string | null
  }

  export type ReminderUpsertWithWhereUniqueWithoutTaskInput = {
    where: ReminderWhereUniqueInput
    update: XOR<ReminderUpdateWithoutTaskInput, ReminderUncheckedUpdateWithoutTaskInput>
    create: XOR<ReminderCreateWithoutTaskInput, ReminderUncheckedCreateWithoutTaskInput>
  }

  export type ReminderUpdateWithWhereUniqueWithoutTaskInput = {
    where: ReminderWhereUniqueInput
    data: XOR<ReminderUpdateWithoutTaskInput, ReminderUncheckedUpdateWithoutTaskInput>
  }

  export type ReminderUpdateManyWithWhereWithoutTaskInput = {
    where: ReminderScalarWhereInput
    data: XOR<ReminderUpdateManyMutationInput, ReminderUncheckedUpdateManyWithoutTaskInput>
  }

  export type ReminderScalarWhereInput = {
    AND?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
    OR?: ReminderScalarWhereInput[]
    NOT?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
    id?: StringFilter<"Reminder"> | string
    taskId?: StringFilter<"Reminder"> | string
    occurrenceAt?: DateTimeFilter<"Reminder"> | Date | string
    remindAt?: DateTimeFilter<"Reminder"> | Date | string
    channel?: StringNullableFilter<"Reminder"> | string | null
    payload?: JsonNullableFilter<"Reminder">
    sent?: BoolFilter<"Reminder"> | boolean
    sentAt?: DateTimeNullableFilter<"Reminder"> | Date | string | null
    createdAt?: DateTimeFilter<"Reminder"> | Date | string
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    head?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    head?: NullableStringFieldUpdateOperationsInput | string | null
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskAttachmentWhereUniqueInput
    update: XOR<TaskAttachmentUpdateWithoutTaskInput, TaskAttachmentUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskAttachmentCreateWithoutTaskInput, TaskAttachmentUncheckedCreateWithoutTaskInput>
  }

  export type TaskAttachmentUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskAttachmentWhereUniqueInput
    data: XOR<TaskAttachmentUpdateWithoutTaskInput, TaskAttachmentUncheckedUpdateWithoutTaskInput>
  }

  export type TaskAttachmentUpdateManyWithWhereWithoutTaskInput = {
    where: TaskAttachmentScalarWhereInput
    data: XOR<TaskAttachmentUpdateManyMutationInput, TaskAttachmentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskAttachmentScalarWhereInput = {
    AND?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
    OR?: TaskAttachmentScalarWhereInput[]
    NOT?: TaskAttachmentScalarWhereInput | TaskAttachmentScalarWhereInput[]
    id?: StringFilter<"TaskAttachment"> | string
    taskId?: StringFilter<"TaskAttachment"> | string
    key?: StringFilter<"TaskAttachment"> | string
    createdAt?: DateTimeFilter<"TaskAttachment"> | Date | string
  }

  export type TaskCustomValueUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskCustomValueWhereUniqueInput
    update: XOR<TaskCustomValueUpdateWithoutTaskInput, TaskCustomValueUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskCustomValueCreateWithoutTaskInput, TaskCustomValueUncheckedCreateWithoutTaskInput>
  }

  export type TaskCustomValueUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskCustomValueWhereUniqueInput
    data: XOR<TaskCustomValueUpdateWithoutTaskInput, TaskCustomValueUncheckedUpdateWithoutTaskInput>
  }

  export type TaskCustomValueUpdateManyWithWhereWithoutTaskInput = {
    where: TaskCustomValueScalarWhereInput
    data: XOR<TaskCustomValueUpdateManyMutationInput, TaskCustomValueUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskCustomValueScalarWhereInput = {
    AND?: TaskCustomValueScalarWhereInput | TaskCustomValueScalarWhereInput[]
    OR?: TaskCustomValueScalarWhereInput[]
    NOT?: TaskCustomValueScalarWhereInput | TaskCustomValueScalarWhereInput[]
    id?: StringFilter<"TaskCustomValue"> | string
    taskId?: StringFilter<"TaskCustomValue"> | string
    fieldId?: StringFilter<"TaskCustomValue"> | string
    value?: StringFilter<"TaskCustomValue"> | string
  }

  export type EmailLogUpsertWithWhereUniqueWithoutTaskInput = {
    where: EmailLogWhereUniqueInput
    update: XOR<EmailLogUpdateWithoutTaskInput, EmailLogUncheckedUpdateWithoutTaskInput>
    create: XOR<EmailLogCreateWithoutTaskInput, EmailLogUncheckedCreateWithoutTaskInput>
  }

  export type EmailLogUpdateWithWhereUniqueWithoutTaskInput = {
    where: EmailLogWhereUniqueInput
    data: XOR<EmailLogUpdateWithoutTaskInput, EmailLogUncheckedUpdateWithoutTaskInput>
  }

  export type EmailLogUpdateManyWithWhereWithoutTaskInput = {
    where: EmailLogScalarWhereInput
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyWithoutTaskInput>
  }

  export type EmailLogScalarWhereInput = {
    AND?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
    OR?: EmailLogScalarWhereInput[]
    NOT?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
    id?: StringFilter<"EmailLog"> | string
    occurrenceId?: StringNullableFilter<"EmailLog"> | string | null
    taskId?: StringNullableFilter<"EmailLog"> | string | null
    recipient?: StringFilter<"EmailLog"> | string
    subject?: StringNullableFilter<"EmailLog"> | string | null
    body?: StringNullableFilter<"EmailLog"> | string | null
    provider?: StringNullableFilter<"EmailLog"> | string | null
    providerMessageId?: StringNullableFilter<"EmailLog"> | string | null
    status?: EnumEmailStatusFilter<"EmailLog"> | $Enums.EmailStatus
    error?: StringNullableFilter<"EmailLog"> | string | null
    createdAt?: DateTimeFilter<"EmailLog"> | Date | string
  }

  export type TaskCustomValueCreateWithoutFieldInput = {
    id?: string
    value: string
    task: TaskCreateNestedOneWithoutCustomValuesInput
  }

  export type TaskCustomValueUncheckedCreateWithoutFieldInput = {
    id?: string
    taskId: string
    value: string
  }

  export type TaskCustomValueCreateOrConnectWithoutFieldInput = {
    where: TaskCustomValueWhereUniqueInput
    create: XOR<TaskCustomValueCreateWithoutFieldInput, TaskCustomValueUncheckedCreateWithoutFieldInput>
  }

  export type TaskCustomValueCreateManyFieldInputEnvelope = {
    data: TaskCustomValueCreateManyFieldInput | TaskCustomValueCreateManyFieldInput[]
    skipDuplicates?: boolean
  }

  export type TaskCustomValueUpsertWithWhereUniqueWithoutFieldInput = {
    where: TaskCustomValueWhereUniqueInput
    update: XOR<TaskCustomValueUpdateWithoutFieldInput, TaskCustomValueUncheckedUpdateWithoutFieldInput>
    create: XOR<TaskCustomValueCreateWithoutFieldInput, TaskCustomValueUncheckedCreateWithoutFieldInput>
  }

  export type TaskCustomValueUpdateWithWhereUniqueWithoutFieldInput = {
    where: TaskCustomValueWhereUniqueInput
    data: XOR<TaskCustomValueUpdateWithoutFieldInput, TaskCustomValueUncheckedUpdateWithoutFieldInput>
  }

  export type TaskCustomValueUpdateManyWithWhereWithoutFieldInput = {
    where: TaskCustomValueScalarWhereInput
    data: XOR<TaskCustomValueUpdateManyMutationInput, TaskCustomValueUncheckedUpdateManyWithoutFieldInput>
  }

  export type TaskCreateWithoutCustomValuesInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    occurrences?: TaskOccurrenceCreateNestedManyWithoutTaskInput
    reminders?: ReminderCreateNestedManyWithoutTaskInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCustomValuesInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    occurrences?: TaskOccurrenceUncheckedCreateNestedManyWithoutTaskInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCustomValuesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCustomValuesInput, TaskUncheckedCreateWithoutCustomValuesInput>
  }

  export type TaskCustomFieldCreateWithoutValuesInput = {
    id?: string
    orgId: string
    name: string
    type: string
    options?: TaskCustomFieldCreateoptionsInput | string[]
    createdAt?: Date | string
  }

  export type TaskCustomFieldUncheckedCreateWithoutValuesInput = {
    id?: string
    orgId: string
    name: string
    type: string
    options?: TaskCustomFieldCreateoptionsInput | string[]
    createdAt?: Date | string
  }

  export type TaskCustomFieldCreateOrConnectWithoutValuesInput = {
    where: TaskCustomFieldWhereUniqueInput
    create: XOR<TaskCustomFieldCreateWithoutValuesInput, TaskCustomFieldUncheckedCreateWithoutValuesInput>
  }

  export type TaskUpsertWithoutCustomValuesInput = {
    update: XOR<TaskUpdateWithoutCustomValuesInput, TaskUncheckedUpdateWithoutCustomValuesInput>
    create: XOR<TaskCreateWithoutCustomValuesInput, TaskUncheckedCreateWithoutCustomValuesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCustomValuesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCustomValuesInput, TaskUncheckedUpdateWithoutCustomValuesInput>
  }

  export type TaskUpdateWithoutCustomValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    occurrences?: TaskOccurrenceUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUpdateManyWithoutTaskNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCustomValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    occurrences?: TaskOccurrenceUncheckedUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCustomFieldUpsertWithoutValuesInput = {
    update: XOR<TaskCustomFieldUpdateWithoutValuesInput, TaskCustomFieldUncheckedUpdateWithoutValuesInput>
    create: XOR<TaskCustomFieldCreateWithoutValuesInput, TaskCustomFieldUncheckedCreateWithoutValuesInput>
    where?: TaskCustomFieldWhereInput
  }

  export type TaskCustomFieldUpdateToOneWithWhereWithoutValuesInput = {
    where?: TaskCustomFieldWhereInput
    data: XOR<TaskCustomFieldUpdateWithoutValuesInput, TaskCustomFieldUncheckedUpdateWithoutValuesInput>
  }

  export type TaskCustomFieldUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: TaskCustomFieldUpdateoptionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCustomFieldUncheckedUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: TaskCustomFieldUpdateoptionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskOccurrenceAssigneeCreateWithoutOccurrenceInput = {
    id?: string
    userId: string
  }

  export type TaskOccurrenceAssigneeUncheckedCreateWithoutOccurrenceInput = {
    id?: string
    userId: string
  }

  export type TaskOccurrenceAssigneeCreateOrConnectWithoutOccurrenceInput = {
    where: TaskOccurrenceAssigneeWhereUniqueInput
    create: XOR<TaskOccurrenceAssigneeCreateWithoutOccurrenceInput, TaskOccurrenceAssigneeUncheckedCreateWithoutOccurrenceInput>
  }

  export type TaskOccurrenceAssigneeCreateManyOccurrenceInputEnvelope = {
    data: TaskOccurrenceAssigneeCreateManyOccurrenceInput | TaskOccurrenceAssigneeCreateManyOccurrenceInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutOccurrencesInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    reminders?: ReminderCreateNestedManyWithoutTaskInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutOccurrencesInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutOccurrencesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutOccurrencesInput, TaskUncheckedCreateWithoutOccurrencesInput>
  }

  export type TaskOccurrenceAttachmentCreateWithoutOccurrenceInput = {
    id?: string
    key: string
    createdAt?: Date | string
  }

  export type TaskOccurrenceAttachmentUncheckedCreateWithoutOccurrenceInput = {
    id?: string
    key: string
    createdAt?: Date | string
  }

  export type TaskOccurrenceAttachmentCreateOrConnectWithoutOccurrenceInput = {
    where: TaskOccurrenceAttachmentWhereUniqueInput
    create: XOR<TaskOccurrenceAttachmentCreateWithoutOccurrenceInput, TaskOccurrenceAttachmentUncheckedCreateWithoutOccurrenceInput>
  }

  export type TaskOccurrenceAttachmentCreateManyOccurrenceInputEnvelope = {
    data: TaskOccurrenceAttachmentCreateManyOccurrenceInput | TaskOccurrenceAttachmentCreateManyOccurrenceInput[]
    skipDuplicates?: boolean
  }

  export type EmailLogCreateWithoutOccurrenceInput = {
    id?: string
    recipient: string
    subject?: string | null
    body?: string | null
    provider?: string | null
    providerMessageId?: string | null
    status?: $Enums.EmailStatus
    error?: string | null
    createdAt?: Date | string
    task?: TaskCreateNestedOneWithoutEmailLogsInput
  }

  export type EmailLogUncheckedCreateWithoutOccurrenceInput = {
    id?: string
    taskId?: string | null
    recipient: string
    subject?: string | null
    body?: string | null
    provider?: string | null
    providerMessageId?: string | null
    status?: $Enums.EmailStatus
    error?: string | null
    createdAt?: Date | string
  }

  export type EmailLogCreateOrConnectWithoutOccurrenceInput = {
    where: EmailLogWhereUniqueInput
    create: XOR<EmailLogCreateWithoutOccurrenceInput, EmailLogUncheckedCreateWithoutOccurrenceInput>
  }

  export type EmailLogCreateManyOccurrenceInputEnvelope = {
    data: EmailLogCreateManyOccurrenceInput | EmailLogCreateManyOccurrenceInput[]
    skipDuplicates?: boolean
  }

  export type TaskOccurrenceAssigneeUpsertWithWhereUniqueWithoutOccurrenceInput = {
    where: TaskOccurrenceAssigneeWhereUniqueInput
    update: XOR<TaskOccurrenceAssigneeUpdateWithoutOccurrenceInput, TaskOccurrenceAssigneeUncheckedUpdateWithoutOccurrenceInput>
    create: XOR<TaskOccurrenceAssigneeCreateWithoutOccurrenceInput, TaskOccurrenceAssigneeUncheckedCreateWithoutOccurrenceInput>
  }

  export type TaskOccurrenceAssigneeUpdateWithWhereUniqueWithoutOccurrenceInput = {
    where: TaskOccurrenceAssigneeWhereUniqueInput
    data: XOR<TaskOccurrenceAssigneeUpdateWithoutOccurrenceInput, TaskOccurrenceAssigneeUncheckedUpdateWithoutOccurrenceInput>
  }

  export type TaskOccurrenceAssigneeUpdateManyWithWhereWithoutOccurrenceInput = {
    where: TaskOccurrenceAssigneeScalarWhereInput
    data: XOR<TaskOccurrenceAssigneeUpdateManyMutationInput, TaskOccurrenceAssigneeUncheckedUpdateManyWithoutOccurrenceInput>
  }

  export type TaskOccurrenceAssigneeScalarWhereInput = {
    AND?: TaskOccurrenceAssigneeScalarWhereInput | TaskOccurrenceAssigneeScalarWhereInput[]
    OR?: TaskOccurrenceAssigneeScalarWhereInput[]
    NOT?: TaskOccurrenceAssigneeScalarWhereInput | TaskOccurrenceAssigneeScalarWhereInput[]
    id?: StringFilter<"TaskOccurrenceAssignee"> | string
    occurrenceId?: StringFilter<"TaskOccurrenceAssignee"> | string
    userId?: StringFilter<"TaskOccurrenceAssignee"> | string
  }

  export type TaskUpsertWithoutOccurrencesInput = {
    update: XOR<TaskUpdateWithoutOccurrencesInput, TaskUncheckedUpdateWithoutOccurrencesInput>
    create: XOR<TaskCreateWithoutOccurrencesInput, TaskUncheckedCreateWithoutOccurrencesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutOccurrencesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutOccurrencesInput, TaskUncheckedUpdateWithoutOccurrencesInput>
  }

  export type TaskUpdateWithoutOccurrencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUpdateManyWithoutTaskNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutOccurrencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskOccurrenceAttachmentUpsertWithWhereUniqueWithoutOccurrenceInput = {
    where: TaskOccurrenceAttachmentWhereUniqueInput
    update: XOR<TaskOccurrenceAttachmentUpdateWithoutOccurrenceInput, TaskOccurrenceAttachmentUncheckedUpdateWithoutOccurrenceInput>
    create: XOR<TaskOccurrenceAttachmentCreateWithoutOccurrenceInput, TaskOccurrenceAttachmentUncheckedCreateWithoutOccurrenceInput>
  }

  export type TaskOccurrenceAttachmentUpdateWithWhereUniqueWithoutOccurrenceInput = {
    where: TaskOccurrenceAttachmentWhereUniqueInput
    data: XOR<TaskOccurrenceAttachmentUpdateWithoutOccurrenceInput, TaskOccurrenceAttachmentUncheckedUpdateWithoutOccurrenceInput>
  }

  export type TaskOccurrenceAttachmentUpdateManyWithWhereWithoutOccurrenceInput = {
    where: TaskOccurrenceAttachmentScalarWhereInput
    data: XOR<TaskOccurrenceAttachmentUpdateManyMutationInput, TaskOccurrenceAttachmentUncheckedUpdateManyWithoutOccurrenceInput>
  }

  export type TaskOccurrenceAttachmentScalarWhereInput = {
    AND?: TaskOccurrenceAttachmentScalarWhereInput | TaskOccurrenceAttachmentScalarWhereInput[]
    OR?: TaskOccurrenceAttachmentScalarWhereInput[]
    NOT?: TaskOccurrenceAttachmentScalarWhereInput | TaskOccurrenceAttachmentScalarWhereInput[]
    id?: StringFilter<"TaskOccurrenceAttachment"> | string
    occurrenceId?: StringFilter<"TaskOccurrenceAttachment"> | string
    key?: StringFilter<"TaskOccurrenceAttachment"> | string
    createdAt?: DateTimeFilter<"TaskOccurrenceAttachment"> | Date | string
  }

  export type EmailLogUpsertWithWhereUniqueWithoutOccurrenceInput = {
    where: EmailLogWhereUniqueInput
    update: XOR<EmailLogUpdateWithoutOccurrenceInput, EmailLogUncheckedUpdateWithoutOccurrenceInput>
    create: XOR<EmailLogCreateWithoutOccurrenceInput, EmailLogUncheckedCreateWithoutOccurrenceInput>
  }

  export type EmailLogUpdateWithWhereUniqueWithoutOccurrenceInput = {
    where: EmailLogWhereUniqueInput
    data: XOR<EmailLogUpdateWithoutOccurrenceInput, EmailLogUncheckedUpdateWithoutOccurrenceInput>
  }

  export type EmailLogUpdateManyWithWhereWithoutOccurrenceInput = {
    where: EmailLogScalarWhereInput
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyWithoutOccurrenceInput>
  }

  export type TaskCreateWithoutAssigneesInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    occurrences?: TaskOccurrenceCreateNestedManyWithoutTaskInput
    reminders?: ReminderCreateNestedManyWithoutTaskInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAssigneesInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    occurrences?: TaskOccurrenceUncheckedCreateNestedManyWithoutTaskInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAssigneesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
  }

  export type TaskUpsertWithoutAssigneesInput = {
    update: XOR<TaskUpdateWithoutAssigneesInput, TaskUncheckedUpdateWithoutAssigneesInput>
    create: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutAssigneesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutAssigneesInput, TaskUncheckedUpdateWithoutAssigneesInput>
  }

  export type TaskUpdateWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    occurrences?: TaskOccurrenceUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUpdateManyWithoutTaskNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    occurrences?: TaskOccurrenceUncheckedUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskOccurrenceCreateWithoutAssigneesInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    completedBy?: string | null
    completionNote?: string | null
    clientId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sequentialId?: number
    clientMailSendCount?: number
    startEmailSent?: boolean
    startEmailSentAt?: Date | string | null
    task: TaskCreateNestedOneWithoutOccurrencesInput
    attachments?: TaskOccurrenceAttachmentCreateNestedManyWithoutOccurrenceInput
    emailLogs?: EmailLogCreateNestedManyWithoutOccurrenceInput
  }

  export type TaskOccurrenceUncheckedCreateWithoutAssigneesInput = {
    id?: string
    taskId: string
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    completedBy?: string | null
    completionNote?: string | null
    clientId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sequentialId?: number
    clientMailSendCount?: number
    startEmailSent?: boolean
    startEmailSentAt?: Date | string | null
    attachments?: TaskOccurrenceAttachmentUncheckedCreateNestedManyWithoutOccurrenceInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutOccurrenceInput
  }

  export type TaskOccurrenceCreateOrConnectWithoutAssigneesInput = {
    where: TaskOccurrenceWhereUniqueInput
    create: XOR<TaskOccurrenceCreateWithoutAssigneesInput, TaskOccurrenceUncheckedCreateWithoutAssigneesInput>
  }

  export type TaskOccurrenceUpsertWithoutAssigneesInput = {
    update: XOR<TaskOccurrenceUpdateWithoutAssigneesInput, TaskOccurrenceUncheckedUpdateWithoutAssigneesInput>
    create: XOR<TaskOccurrenceCreateWithoutAssigneesInput, TaskOccurrenceUncheckedCreateWithoutAssigneesInput>
    where?: TaskOccurrenceWhereInput
  }

  export type TaskOccurrenceUpdateToOneWithWhereWithoutAssigneesInput = {
    where?: TaskOccurrenceWhereInput
    data: XOR<TaskOccurrenceUpdateWithoutAssigneesInput, TaskOccurrenceUncheckedUpdateWithoutAssigneesInput>
  }

  export type TaskOccurrenceUpdateWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task?: TaskUpdateOneRequiredWithoutOccurrencesNestedInput
    attachments?: TaskOccurrenceAttachmentUpdateManyWithoutOccurrenceNestedInput
    emailLogs?: EmailLogUpdateManyWithoutOccurrenceNestedInput
  }

  export type TaskOccurrenceUncheckedUpdateWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TaskOccurrenceAttachmentUncheckedUpdateManyWithoutOccurrenceNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutOccurrenceNestedInput
  }

  export type TaskCreateWithoutAttachmentsInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    occurrences?: TaskOccurrenceCreateNestedManyWithoutTaskInput
    reminders?: ReminderCreateNestedManyWithoutTaskInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    occurrences?: TaskOccurrenceUncheckedCreateNestedManyWithoutTaskInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAttachmentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
  }

  export type TaskUpsertWithoutAttachmentsInput = {
    update: XOR<TaskUpdateWithoutAttachmentsInput, TaskUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutAttachmentsInput, TaskUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TaskUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    occurrences?: TaskOccurrenceUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUpdateManyWithoutTaskNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    occurrences?: TaskOccurrenceUncheckedUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskOccurrenceCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    completedBy?: string | null
    completionNote?: string | null
    clientId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sequentialId?: number
    clientMailSendCount?: number
    startEmailSent?: boolean
    startEmailSentAt?: Date | string | null
    assignees?: TaskOccurrenceAssigneeCreateNestedManyWithoutOccurrenceInput
    task: TaskCreateNestedOneWithoutOccurrencesInput
    emailLogs?: EmailLogCreateNestedManyWithoutOccurrenceInput
  }

  export type TaskOccurrenceUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    taskId: string
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    completedBy?: string | null
    completionNote?: string | null
    clientId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sequentialId?: number
    clientMailSendCount?: number
    startEmailSent?: boolean
    startEmailSentAt?: Date | string | null
    assignees?: TaskOccurrenceAssigneeUncheckedCreateNestedManyWithoutOccurrenceInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutOccurrenceInput
  }

  export type TaskOccurrenceCreateOrConnectWithoutAttachmentsInput = {
    where: TaskOccurrenceWhereUniqueInput
    create: XOR<TaskOccurrenceCreateWithoutAttachmentsInput, TaskOccurrenceUncheckedCreateWithoutAttachmentsInput>
  }

  export type TaskOccurrenceUpsertWithoutAttachmentsInput = {
    update: XOR<TaskOccurrenceUpdateWithoutAttachmentsInput, TaskOccurrenceUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TaskOccurrenceCreateWithoutAttachmentsInput, TaskOccurrenceUncheckedCreateWithoutAttachmentsInput>
    where?: TaskOccurrenceWhereInput
  }

  export type TaskOccurrenceUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TaskOccurrenceWhereInput
    data: XOR<TaskOccurrenceUpdateWithoutAttachmentsInput, TaskOccurrenceUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TaskOccurrenceUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignees?: TaskOccurrenceAssigneeUpdateManyWithoutOccurrenceNestedInput
    task?: TaskUpdateOneRequiredWithoutOccurrencesNestedInput
    emailLogs?: EmailLogUpdateManyWithoutOccurrenceNestedInput
  }

  export type TaskOccurrenceUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignees?: TaskOccurrenceAssigneeUncheckedUpdateManyWithoutOccurrenceNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutOccurrenceNestedInput
  }

  export type TaskCreateWithoutRemindersInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    occurrences?: TaskOccurrenceCreateNestedManyWithoutTaskInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutRemindersInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    occurrences?: TaskOccurrenceUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutRemindersInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutRemindersInput, TaskUncheckedCreateWithoutRemindersInput>
  }

  export type TaskUpsertWithoutRemindersInput = {
    update: XOR<TaskUpdateWithoutRemindersInput, TaskUncheckedUpdateWithoutRemindersInput>
    create: XOR<TaskCreateWithoutRemindersInput, TaskUncheckedCreateWithoutRemindersInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutRemindersInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutRemindersInput, TaskUncheckedUpdateWithoutRemindersInput>
  }

  export type TaskUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    occurrences?: TaskOccurrenceUpdateManyWithoutTaskNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    occurrences?: TaskOccurrenceUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ConversationMemberCreateWithoutConversationInput = {
    id?: string
    role?: string | null
    user: DirectoryUserCreateNestedOneWithoutMembersInput
  }

  export type ConversationMemberUncheckedCreateWithoutConversationInput = {
    id?: string
    userId: string
    role?: string | null
  }

  export type ConversationMemberCreateOrConnectWithoutConversationInput = {
    where: ConversationMemberWhereUniqueInput
    create: XOR<ConversationMemberCreateWithoutConversationInput, ConversationMemberUncheckedCreateWithoutConversationInput>
  }

  export type ConversationMemberCreateManyConversationInputEnvelope = {
    data: ConversationMemberCreateManyConversationInput | ConversationMemberCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sender: DirectoryUserCreateNestedOneWithoutMessagesSentInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ConversationMemberUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationMemberWhereUniqueInput
    update: XOR<ConversationMemberUpdateWithoutConversationInput, ConversationMemberUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationMemberCreateWithoutConversationInput, ConversationMemberUncheckedCreateWithoutConversationInput>
  }

  export type ConversationMemberUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationMemberWhereUniqueInput
    data: XOR<ConversationMemberUpdateWithoutConversationInput, ConversationMemberUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationMemberUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationMemberScalarWhereInput
    data: XOR<ConversationMemberUpdateManyMutationInput, ConversationMemberUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationMemberScalarWhereInput = {
    AND?: ConversationMemberScalarWhereInput | ConversationMemberScalarWhereInput[]
    OR?: ConversationMemberScalarWhereInput[]
    NOT?: ConversationMemberScalarWhereInput | ConversationMemberScalarWhereInput[]
    id?: StringFilter<"ConversationMember"> | string
    conversationId?: StringFilter<"ConversationMember"> | string
    userId?: StringFilter<"ConversationMember"> | string
    role?: StringNullableFilter<"ConversationMember"> | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    body?: StringNullableFilter<"Message"> | string | null
    attachments?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type ConversationCreateWithoutMembersInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById: string
    updatedAt?: Date | string
    createdAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMembersInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById: string
    updatedAt?: Date | string
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMembersInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput>
  }

  export type DirectoryUserCreateWithoutMembersInput = {
    id?: string
    userId: string
    name: string
    avatarUrl?: string | null
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
  }

  export type DirectoryUserUncheckedCreateWithoutMembersInput = {
    id?: string
    userId: string
    name: string
    avatarUrl?: string | null
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type DirectoryUserCreateOrConnectWithoutMembersInput = {
    where: DirectoryUserWhereUniqueInput
    create: XOR<DirectoryUserCreateWithoutMembersInput, DirectoryUserUncheckedCreateWithoutMembersInput>
  }

  export type ConversationUpsertWithoutMembersInput = {
    update: XOR<ConversationUpdateWithoutMembersInput, ConversationUncheckedUpdateWithoutMembersInput>
    create: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMembersInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMembersInput, ConversationUncheckedUpdateWithoutMembersInput>
  }

  export type ConversationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type DirectoryUserUpsertWithoutMembersInput = {
    update: XOR<DirectoryUserUpdateWithoutMembersInput, DirectoryUserUncheckedUpdateWithoutMembersInput>
    create: XOR<DirectoryUserCreateWithoutMembersInput, DirectoryUserUncheckedCreateWithoutMembersInput>
    where?: DirectoryUserWhereInput
  }

  export type DirectoryUserUpdateToOneWithWhereWithoutMembersInput = {
    where?: DirectoryUserWhereInput
    data: XOR<DirectoryUserUpdateWithoutMembersInput, DirectoryUserUncheckedUpdateWithoutMembersInput>
  }

  export type DirectoryUserUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type DirectoryUserUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById: string
    updatedAt?: Date | string
    createdAt?: Date | string
    members?: ConversationMemberCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById: string
    updatedAt?: Date | string
    createdAt?: Date | string
    members?: ConversationMemberUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type DirectoryUserCreateWithoutMessagesSentInput = {
    id?: string
    userId: string
    name: string
    avatarUrl?: string | null
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConversationMemberCreateNestedManyWithoutUserInput
  }

  export type DirectoryUserUncheckedCreateWithoutMessagesSentInput = {
    id?: string
    userId: string
    name: string
    avatarUrl?: string | null
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ConversationMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type DirectoryUserCreateOrConnectWithoutMessagesSentInput = {
    where: DirectoryUserWhereUniqueInput
    create: XOR<DirectoryUserCreateWithoutMessagesSentInput, DirectoryUserUncheckedCreateWithoutMessagesSentInput>
  }

  export type MessageReadCreateWithoutMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadCreateOrConnectWithoutMessageInput = {
    where: MessageReadWhereUniqueInput
    create: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput>
  }

  export type MessageReadCreateManyMessageInputEnvelope = {
    data: MessageReadCreateManyMessageInput | MessageReadCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConversationMemberUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConversationMemberUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type DirectoryUserUpsertWithoutMessagesSentInput = {
    update: XOR<DirectoryUserUpdateWithoutMessagesSentInput, DirectoryUserUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<DirectoryUserCreateWithoutMessagesSentInput, DirectoryUserUncheckedCreateWithoutMessagesSentInput>
    where?: DirectoryUserWhereInput
  }

  export type DirectoryUserUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: DirectoryUserWhereInput
    data: XOR<DirectoryUserUpdateWithoutMessagesSentInput, DirectoryUserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type DirectoryUserUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConversationMemberUpdateManyWithoutUserNestedInput
  }

  export type DirectoryUserUncheckedUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ConversationMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageReadUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageReadWhereUniqueInput
    update: XOR<MessageReadUpdateWithoutMessageInput, MessageReadUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput>
  }

  export type MessageReadUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageReadWhereUniqueInput
    data: XOR<MessageReadUpdateWithoutMessageInput, MessageReadUncheckedUpdateWithoutMessageInput>
  }

  export type MessageReadUpdateManyWithWhereWithoutMessageInput = {
    where: MessageReadScalarWhereInput
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageReadScalarWhereInput = {
    AND?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
    OR?: MessageReadScalarWhereInput[]
    NOT?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
    id?: StringFilter<"MessageRead"> | string
    messageId?: StringFilter<"MessageRead"> | string
    userId?: StringFilter<"MessageRead"> | string
    readAt?: DateTimeFilter<"MessageRead"> | Date | string
  }

  export type MessageCreateWithoutReadsInput = {
    id?: string
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: DirectoryUserCreateNestedOneWithoutMessagesSentInput
  }

  export type MessageUncheckedCreateWithoutReadsInput = {
    id?: string
    conversationId: string
    senderId: string
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutReadsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
  }

  export type MessageUpsertWithoutReadsInput = {
    update: XOR<MessageUpdateWithoutReadsInput, MessageUncheckedUpdateWithoutReadsInput>
    create: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutReadsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutReadsInput, MessageUncheckedUpdateWithoutReadsInput>
  }

  export type MessageUpdateWithoutReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: DirectoryUserUpdateOneRequiredWithoutMessagesSentNestedInput
  }

  export type MessageUncheckedUpdateWithoutReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMemberCreateWithoutUserInput = {
    id?: string
    role?: string | null
    conversation: ConversationCreateNestedOneWithoutMembersInput
  }

  export type ConversationMemberUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId: string
    role?: string | null
  }

  export type ConversationMemberCreateOrConnectWithoutUserInput = {
    where: ConversationMemberWhereUniqueInput
    create: XOR<ConversationMemberCreateWithoutUserInput, ConversationMemberUncheckedCreateWithoutUserInput>
  }

  export type ConversationMemberCreateManyUserInputEnvelope = {
    data: ConversationMemberCreateManyUserInput | ConversationMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type ConversationMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationMemberWhereUniqueInput
    update: XOR<ConversationMemberUpdateWithoutUserInput, ConversationMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationMemberCreateWithoutUserInput, ConversationMemberUncheckedCreateWithoutUserInput>
  }

  export type ConversationMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationMemberWhereUniqueInput
    data: XOR<ConversationMemberUpdateWithoutUserInput, ConversationMemberUncheckedUpdateWithoutUserInput>
  }

  export type ConversationMemberUpdateManyWithWhereWithoutUserInput = {
    where: ConversationMemberScalarWhereInput
    data: XOR<ConversationMemberUpdateManyMutationInput, ConversationMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type TaskOccurrenceCreateWithoutEmailLogsInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    completedBy?: string | null
    completionNote?: string | null
    clientId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sequentialId?: number
    clientMailSendCount?: number
    startEmailSent?: boolean
    startEmailSentAt?: Date | string | null
    assignees?: TaskOccurrenceAssigneeCreateNestedManyWithoutOccurrenceInput
    task: TaskCreateNestedOneWithoutOccurrencesInput
    attachments?: TaskOccurrenceAttachmentCreateNestedManyWithoutOccurrenceInput
  }

  export type TaskOccurrenceUncheckedCreateWithoutEmailLogsInput = {
    id?: string
    taskId: string
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    completedBy?: string | null
    completionNote?: string | null
    clientId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sequentialId?: number
    clientMailSendCount?: number
    startEmailSent?: boolean
    startEmailSentAt?: Date | string | null
    assignees?: TaskOccurrenceAssigneeUncheckedCreateNestedManyWithoutOccurrenceInput
    attachments?: TaskOccurrenceAttachmentUncheckedCreateNestedManyWithoutOccurrenceInput
  }

  export type TaskOccurrenceCreateOrConnectWithoutEmailLogsInput = {
    where: TaskOccurrenceWhereUniqueInput
    create: XOR<TaskOccurrenceCreateWithoutEmailLogsInput, TaskOccurrenceUncheckedCreateWithoutEmailLogsInput>
  }

  export type TaskCreateWithoutEmailLogsInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeCreateNestedManyWithoutTaskInput
    occurrences?: TaskOccurrenceCreateNestedManyWithoutTaskInput
    reminders?: ReminderCreateNestedManyWithoutTaskInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    attachments?: TaskAttachmentCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutEmailLogsInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    projectId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
    assignees?: TaskAssigneeUncheckedCreateNestedManyWithoutTaskInput
    occurrences?: TaskOccurrenceUncheckedCreateNestedManyWithoutTaskInput
    reminders?: ReminderUncheckedCreateNestedManyWithoutTaskInput
    attachments?: TaskAttachmentUncheckedCreateNestedManyWithoutTaskInput
    customValues?: TaskCustomValueUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutEmailLogsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutEmailLogsInput, TaskUncheckedCreateWithoutEmailLogsInput>
  }

  export type TaskOccurrenceUpsertWithoutEmailLogsInput = {
    update: XOR<TaskOccurrenceUpdateWithoutEmailLogsInput, TaskOccurrenceUncheckedUpdateWithoutEmailLogsInput>
    create: XOR<TaskOccurrenceCreateWithoutEmailLogsInput, TaskOccurrenceUncheckedCreateWithoutEmailLogsInput>
    where?: TaskOccurrenceWhereInput
  }

  export type TaskOccurrenceUpdateToOneWithWhereWithoutEmailLogsInput = {
    where?: TaskOccurrenceWhereInput
    data: XOR<TaskOccurrenceUpdateWithoutEmailLogsInput, TaskOccurrenceUncheckedUpdateWithoutEmailLogsInput>
  }

  export type TaskOccurrenceUpdateWithoutEmailLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignees?: TaskOccurrenceAssigneeUpdateManyWithoutOccurrenceNestedInput
    task?: TaskUpdateOneRequiredWithoutOccurrencesNestedInput
    attachments?: TaskOccurrenceAttachmentUpdateManyWithoutOccurrenceNestedInput
  }

  export type TaskOccurrenceUncheckedUpdateWithoutEmailLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignees?: TaskOccurrenceAssigneeUncheckedUpdateManyWithoutOccurrenceNestedInput
    attachments?: TaskOccurrenceAttachmentUncheckedUpdateManyWithoutOccurrenceNestedInput
  }

  export type TaskUpsertWithoutEmailLogsInput = {
    update: XOR<TaskUpdateWithoutEmailLogsInput, TaskUncheckedUpdateWithoutEmailLogsInput>
    create: XOR<TaskCreateWithoutEmailLogsInput, TaskUncheckedCreateWithoutEmailLogsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutEmailLogsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutEmailLogsInput, TaskUncheckedUpdateWithoutEmailLogsInput>
  }

  export type TaskUpdateWithoutEmailLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    occurrences?: TaskOccurrenceUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUpdateManyWithoutTaskNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutEmailLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    occurrences?: TaskOccurrenceUncheckedUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type LicenseAssigneeCreateWithoutLicenseInput = {
    userId: string
    role?: $Enums.LicenseAssigneeRole
  }

  export type LicenseAssigneeUncheckedCreateWithoutLicenseInput = {
    userId: string
    role?: $Enums.LicenseAssigneeRole
  }

  export type LicenseAssigneeCreateOrConnectWithoutLicenseInput = {
    where: LicenseAssigneeWhereUniqueInput
    create: XOR<LicenseAssigneeCreateWithoutLicenseInput, LicenseAssigneeUncheckedCreateWithoutLicenseInput>
  }

  export type LicenseAssigneeCreateManyLicenseInputEnvelope = {
    data: LicenseAssigneeCreateManyLicenseInput | LicenseAssigneeCreateManyLicenseInput[]
    skipDuplicates?: boolean
  }

  export type LicenseHistoryCreateWithoutLicenseInput = {
    id?: string
    action: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: string | null
    at?: Date | string
  }

  export type LicenseHistoryUncheckedCreateWithoutLicenseInput = {
    id?: string
    action: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: string | null
    at?: Date | string
  }

  export type LicenseHistoryCreateOrConnectWithoutLicenseInput = {
    where: LicenseHistoryWhereUniqueInput
    create: XOR<LicenseHistoryCreateWithoutLicenseInput, LicenseHistoryUncheckedCreateWithoutLicenseInput>
  }

  export type LicenseHistoryCreateManyLicenseInputEnvelope = {
    data: LicenseHistoryCreateManyLicenseInput | LicenseHistoryCreateManyLicenseInput[]
    skipDuplicates?: boolean
  }

  export type LicenseAttachmentCreateWithoutLicenseInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    spacesKey: string
    cachedUrl?: string | null
    uploadedAt?: Date | string
  }

  export type LicenseAttachmentUncheckedCreateWithoutLicenseInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    spacesKey: string
    cachedUrl?: string | null
    uploadedAt?: Date | string
  }

  export type LicenseAttachmentCreateOrConnectWithoutLicenseInput = {
    where: LicenseAttachmentWhereUniqueInput
    create: XOR<LicenseAttachmentCreateWithoutLicenseInput, LicenseAttachmentUncheckedCreateWithoutLicenseInput>
  }

  export type LicenseAttachmentCreateManyLicenseInputEnvelope = {
    data: LicenseAttachmentCreateManyLicenseInput | LicenseAttachmentCreateManyLicenseInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledReminderCreateWithoutLicenseInput = {
    id?: string
    orgLocalDay: Date | string
    runAt: Date | string
    offsetDays: number
    status?: $Enums.ReminderStatus
    attempts?: number
    lastError?: string | null
    sentAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledReminderUncheckedCreateWithoutLicenseInput = {
    id?: string
    orgLocalDay: Date | string
    runAt: Date | string
    offsetDays: number
    status?: $Enums.ReminderStatus
    attempts?: number
    lastError?: string | null
    sentAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledReminderCreateOrConnectWithoutLicenseInput = {
    where: ScheduledReminderWhereUniqueInput
    create: XOR<ScheduledReminderCreateWithoutLicenseInput, ScheduledReminderUncheckedCreateWithoutLicenseInput>
  }

  export type ScheduledReminderCreateManyLicenseInputEnvelope = {
    data: ScheduledReminderCreateManyLicenseInput | ScheduledReminderCreateManyLicenseInput[]
    skipDuplicates?: boolean
  }

  export type LicenseAssigneeUpsertWithWhereUniqueWithoutLicenseInput = {
    where: LicenseAssigneeWhereUniqueInput
    update: XOR<LicenseAssigneeUpdateWithoutLicenseInput, LicenseAssigneeUncheckedUpdateWithoutLicenseInput>
    create: XOR<LicenseAssigneeCreateWithoutLicenseInput, LicenseAssigneeUncheckedCreateWithoutLicenseInput>
  }

  export type LicenseAssigneeUpdateWithWhereUniqueWithoutLicenseInput = {
    where: LicenseAssigneeWhereUniqueInput
    data: XOR<LicenseAssigneeUpdateWithoutLicenseInput, LicenseAssigneeUncheckedUpdateWithoutLicenseInput>
  }

  export type LicenseAssigneeUpdateManyWithWhereWithoutLicenseInput = {
    where: LicenseAssigneeScalarWhereInput
    data: XOR<LicenseAssigneeUpdateManyMutationInput, LicenseAssigneeUncheckedUpdateManyWithoutLicenseInput>
  }

  export type LicenseAssigneeScalarWhereInput = {
    AND?: LicenseAssigneeScalarWhereInput | LicenseAssigneeScalarWhereInput[]
    OR?: LicenseAssigneeScalarWhereInput[]
    NOT?: LicenseAssigneeScalarWhereInput | LicenseAssigneeScalarWhereInput[]
    licenseId?: StringFilter<"LicenseAssignee"> | string
    userId?: StringFilter<"LicenseAssignee"> | string
    role?: EnumLicenseAssigneeRoleFilter<"LicenseAssignee"> | $Enums.LicenseAssigneeRole
  }

  export type LicenseHistoryUpsertWithWhereUniqueWithoutLicenseInput = {
    where: LicenseHistoryWhereUniqueInput
    update: XOR<LicenseHistoryUpdateWithoutLicenseInput, LicenseHistoryUncheckedUpdateWithoutLicenseInput>
    create: XOR<LicenseHistoryCreateWithoutLicenseInput, LicenseHistoryUncheckedCreateWithoutLicenseInput>
  }

  export type LicenseHistoryUpdateWithWhereUniqueWithoutLicenseInput = {
    where: LicenseHistoryWhereUniqueInput
    data: XOR<LicenseHistoryUpdateWithoutLicenseInput, LicenseHistoryUncheckedUpdateWithoutLicenseInput>
  }

  export type LicenseHistoryUpdateManyWithWhereWithoutLicenseInput = {
    where: LicenseHistoryScalarWhereInput
    data: XOR<LicenseHistoryUpdateManyMutationInput, LicenseHistoryUncheckedUpdateManyWithoutLicenseInput>
  }

  export type LicenseHistoryScalarWhereInput = {
    AND?: LicenseHistoryScalarWhereInput | LicenseHistoryScalarWhereInput[]
    OR?: LicenseHistoryScalarWhereInput[]
    NOT?: LicenseHistoryScalarWhereInput | LicenseHistoryScalarWhereInput[]
    id?: StringFilter<"LicenseHistory"> | string
    licenseId?: StringFilter<"LicenseHistory"> | string
    action?: StringFilter<"LicenseHistory"> | string
    payload?: JsonNullableFilter<"LicenseHistory">
    actorId?: StringNullableFilter<"LicenseHistory"> | string | null
    at?: DateTimeFilter<"LicenseHistory"> | Date | string
  }

  export type LicenseAttachmentUpsertWithWhereUniqueWithoutLicenseInput = {
    where: LicenseAttachmentWhereUniqueInput
    update: XOR<LicenseAttachmentUpdateWithoutLicenseInput, LicenseAttachmentUncheckedUpdateWithoutLicenseInput>
    create: XOR<LicenseAttachmentCreateWithoutLicenseInput, LicenseAttachmentUncheckedCreateWithoutLicenseInput>
  }

  export type LicenseAttachmentUpdateWithWhereUniqueWithoutLicenseInput = {
    where: LicenseAttachmentWhereUniqueInput
    data: XOR<LicenseAttachmentUpdateWithoutLicenseInput, LicenseAttachmentUncheckedUpdateWithoutLicenseInput>
  }

  export type LicenseAttachmentUpdateManyWithWhereWithoutLicenseInput = {
    where: LicenseAttachmentScalarWhereInput
    data: XOR<LicenseAttachmentUpdateManyMutationInput, LicenseAttachmentUncheckedUpdateManyWithoutLicenseInput>
  }

  export type LicenseAttachmentScalarWhereInput = {
    AND?: LicenseAttachmentScalarWhereInput | LicenseAttachmentScalarWhereInput[]
    OR?: LicenseAttachmentScalarWhereInput[]
    NOT?: LicenseAttachmentScalarWhereInput | LicenseAttachmentScalarWhereInput[]
    id?: StringFilter<"LicenseAttachment"> | string
    licenseId?: StringFilter<"LicenseAttachment"> | string
    fileName?: StringFilter<"LicenseAttachment"> | string
    fileSize?: IntFilter<"LicenseAttachment"> | number
    mimeType?: StringFilter<"LicenseAttachment"> | string
    spacesKey?: StringFilter<"LicenseAttachment"> | string
    cachedUrl?: StringNullableFilter<"LicenseAttachment"> | string | null
    uploadedAt?: DateTimeFilter<"LicenseAttachment"> | Date | string
  }

  export type ScheduledReminderUpsertWithWhereUniqueWithoutLicenseInput = {
    where: ScheduledReminderWhereUniqueInput
    update: XOR<ScheduledReminderUpdateWithoutLicenseInput, ScheduledReminderUncheckedUpdateWithoutLicenseInput>
    create: XOR<ScheduledReminderCreateWithoutLicenseInput, ScheduledReminderUncheckedCreateWithoutLicenseInput>
  }

  export type ScheduledReminderUpdateWithWhereUniqueWithoutLicenseInput = {
    where: ScheduledReminderWhereUniqueInput
    data: XOR<ScheduledReminderUpdateWithoutLicenseInput, ScheduledReminderUncheckedUpdateWithoutLicenseInput>
  }

  export type ScheduledReminderUpdateManyWithWhereWithoutLicenseInput = {
    where: ScheduledReminderScalarWhereInput
    data: XOR<ScheduledReminderUpdateManyMutationInput, ScheduledReminderUncheckedUpdateManyWithoutLicenseInput>
  }

  export type ScheduledReminderScalarWhereInput = {
    AND?: ScheduledReminderScalarWhereInput | ScheduledReminderScalarWhereInput[]
    OR?: ScheduledReminderScalarWhereInput[]
    NOT?: ScheduledReminderScalarWhereInput | ScheduledReminderScalarWhereInput[]
    id?: StringFilter<"ScheduledReminder"> | string
    licenseId?: StringFilter<"ScheduledReminder"> | string
    orgLocalDay?: DateTimeFilter<"ScheduledReminder"> | Date | string
    runAt?: DateTimeFilter<"ScheduledReminder"> | Date | string
    offsetDays?: IntFilter<"ScheduledReminder"> | number
    status?: EnumReminderStatusFilter<"ScheduledReminder"> | $Enums.ReminderStatus
    attempts?: IntFilter<"ScheduledReminder"> | number
    lastError?: StringNullableFilter<"ScheduledReminder"> | string | null
    sentAt?: DateTimeNullableFilter<"ScheduledReminder"> | Date | string | null
    meta?: JsonNullableFilter<"ScheduledReminder">
  }

  export type LicenseCreateWithoutAssigneesInput = {
    id?: string
    title: string
    licenseNumber?: string | null
    type?: string | null
    holder?: string | null
    clientId?: string | null
    projectId?: string | null
    serviceId?: string | null
    url?: string | null
    vendorId?: string | null
    issuedOn?: Date | string | null
    validFrom?: Date | string | null
    expiresOn: Date | string
    remindOffsets?: LicenseCreateremindOffsetsInput | number[]
    gracePeriodDays?: number | null
    muted?: boolean | null
    responsibleId?: string | null
    status?: $Enums.LicenseStatus | null
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    histories?: LicenseHistoryCreateNestedManyWithoutLicenseInput
    attachments?: LicenseAttachmentCreateNestedManyWithoutLicenseInput
    scheduledReminders?: ScheduledReminderCreateNestedManyWithoutLicenseInput
  }

  export type LicenseUncheckedCreateWithoutAssigneesInput = {
    id?: string
    title: string
    licenseNumber?: string | null
    type?: string | null
    holder?: string | null
    clientId?: string | null
    projectId?: string | null
    serviceId?: string | null
    url?: string | null
    vendorId?: string | null
    issuedOn?: Date | string | null
    validFrom?: Date | string | null
    expiresOn: Date | string
    remindOffsets?: LicenseCreateremindOffsetsInput | number[]
    gracePeriodDays?: number | null
    muted?: boolean | null
    responsibleId?: string | null
    status?: $Enums.LicenseStatus | null
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    histories?: LicenseHistoryUncheckedCreateNestedManyWithoutLicenseInput
    attachments?: LicenseAttachmentUncheckedCreateNestedManyWithoutLicenseInput
    scheduledReminders?: ScheduledReminderUncheckedCreateNestedManyWithoutLicenseInput
  }

  export type LicenseCreateOrConnectWithoutAssigneesInput = {
    where: LicenseWhereUniqueInput
    create: XOR<LicenseCreateWithoutAssigneesInput, LicenseUncheckedCreateWithoutAssigneesInput>
  }

  export type LicenseUpsertWithoutAssigneesInput = {
    update: XOR<LicenseUpdateWithoutAssigneesInput, LicenseUncheckedUpdateWithoutAssigneesInput>
    create: XOR<LicenseCreateWithoutAssigneesInput, LicenseUncheckedCreateWithoutAssigneesInput>
    where?: LicenseWhereInput
  }

  export type LicenseUpdateToOneWithWhereWithoutAssigneesInput = {
    where?: LicenseWhereInput
    data: XOR<LicenseUpdateWithoutAssigneesInput, LicenseUncheckedUpdateWithoutAssigneesInput>
  }

  export type LicenseUpdateWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    remindOffsets?: LicenseUpdateremindOffsetsInput | number[]
    gracePeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus | null
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: LicenseHistoryUpdateManyWithoutLicenseNestedInput
    attachments?: LicenseAttachmentUpdateManyWithoutLicenseNestedInput
    scheduledReminders?: ScheduledReminderUpdateManyWithoutLicenseNestedInput
  }

  export type LicenseUncheckedUpdateWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    remindOffsets?: LicenseUpdateremindOffsetsInput | number[]
    gracePeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus | null
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: LicenseHistoryUncheckedUpdateManyWithoutLicenseNestedInput
    attachments?: LicenseAttachmentUncheckedUpdateManyWithoutLicenseNestedInput
    scheduledReminders?: ScheduledReminderUncheckedUpdateManyWithoutLicenseNestedInput
  }

  export type LicenseCreateWithoutHistoriesInput = {
    id?: string
    title: string
    licenseNumber?: string | null
    type?: string | null
    holder?: string | null
    clientId?: string | null
    projectId?: string | null
    serviceId?: string | null
    url?: string | null
    vendorId?: string | null
    issuedOn?: Date | string | null
    validFrom?: Date | string | null
    expiresOn: Date | string
    remindOffsets?: LicenseCreateremindOffsetsInput | number[]
    gracePeriodDays?: number | null
    muted?: boolean | null
    responsibleId?: string | null
    status?: $Enums.LicenseStatus | null
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: LicenseAssigneeCreateNestedManyWithoutLicenseInput
    attachments?: LicenseAttachmentCreateNestedManyWithoutLicenseInput
    scheduledReminders?: ScheduledReminderCreateNestedManyWithoutLicenseInput
  }

  export type LicenseUncheckedCreateWithoutHistoriesInput = {
    id?: string
    title: string
    licenseNumber?: string | null
    type?: string | null
    holder?: string | null
    clientId?: string | null
    projectId?: string | null
    serviceId?: string | null
    url?: string | null
    vendorId?: string | null
    issuedOn?: Date | string | null
    validFrom?: Date | string | null
    expiresOn: Date | string
    remindOffsets?: LicenseCreateremindOffsetsInput | number[]
    gracePeriodDays?: number | null
    muted?: boolean | null
    responsibleId?: string | null
    status?: $Enums.LicenseStatus | null
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: LicenseAssigneeUncheckedCreateNestedManyWithoutLicenseInput
    attachments?: LicenseAttachmentUncheckedCreateNestedManyWithoutLicenseInput
    scheduledReminders?: ScheduledReminderUncheckedCreateNestedManyWithoutLicenseInput
  }

  export type LicenseCreateOrConnectWithoutHistoriesInput = {
    where: LicenseWhereUniqueInput
    create: XOR<LicenseCreateWithoutHistoriesInput, LicenseUncheckedCreateWithoutHistoriesInput>
  }

  export type LicenseUpsertWithoutHistoriesInput = {
    update: XOR<LicenseUpdateWithoutHistoriesInput, LicenseUncheckedUpdateWithoutHistoriesInput>
    create: XOR<LicenseCreateWithoutHistoriesInput, LicenseUncheckedCreateWithoutHistoriesInput>
    where?: LicenseWhereInput
  }

  export type LicenseUpdateToOneWithWhereWithoutHistoriesInput = {
    where?: LicenseWhereInput
    data: XOR<LicenseUpdateWithoutHistoriesInput, LicenseUncheckedUpdateWithoutHistoriesInput>
  }

  export type LicenseUpdateWithoutHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    remindOffsets?: LicenseUpdateremindOffsetsInput | number[]
    gracePeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus | null
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: LicenseAssigneeUpdateManyWithoutLicenseNestedInput
    attachments?: LicenseAttachmentUpdateManyWithoutLicenseNestedInput
    scheduledReminders?: ScheduledReminderUpdateManyWithoutLicenseNestedInput
  }

  export type LicenseUncheckedUpdateWithoutHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    remindOffsets?: LicenseUpdateremindOffsetsInput | number[]
    gracePeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus | null
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: LicenseAssigneeUncheckedUpdateManyWithoutLicenseNestedInput
    attachments?: LicenseAttachmentUncheckedUpdateManyWithoutLicenseNestedInput
    scheduledReminders?: ScheduledReminderUncheckedUpdateManyWithoutLicenseNestedInput
  }

  export type LicenseCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    licenseNumber?: string | null
    type?: string | null
    holder?: string | null
    clientId?: string | null
    projectId?: string | null
    serviceId?: string | null
    url?: string | null
    vendorId?: string | null
    issuedOn?: Date | string | null
    validFrom?: Date | string | null
    expiresOn: Date | string
    remindOffsets?: LicenseCreateremindOffsetsInput | number[]
    gracePeriodDays?: number | null
    muted?: boolean | null
    responsibleId?: string | null
    status?: $Enums.LicenseStatus | null
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: LicenseAssigneeCreateNestedManyWithoutLicenseInput
    histories?: LicenseHistoryCreateNestedManyWithoutLicenseInput
    scheduledReminders?: ScheduledReminderCreateNestedManyWithoutLicenseInput
  }

  export type LicenseUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    licenseNumber?: string | null
    type?: string | null
    holder?: string | null
    clientId?: string | null
    projectId?: string | null
    serviceId?: string | null
    url?: string | null
    vendorId?: string | null
    issuedOn?: Date | string | null
    validFrom?: Date | string | null
    expiresOn: Date | string
    remindOffsets?: LicenseCreateremindOffsetsInput | number[]
    gracePeriodDays?: number | null
    muted?: boolean | null
    responsibleId?: string | null
    status?: $Enums.LicenseStatus | null
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: LicenseAssigneeUncheckedCreateNestedManyWithoutLicenseInput
    histories?: LicenseHistoryUncheckedCreateNestedManyWithoutLicenseInput
    scheduledReminders?: ScheduledReminderUncheckedCreateNestedManyWithoutLicenseInput
  }

  export type LicenseCreateOrConnectWithoutAttachmentsInput = {
    where: LicenseWhereUniqueInput
    create: XOR<LicenseCreateWithoutAttachmentsInput, LicenseUncheckedCreateWithoutAttachmentsInput>
  }

  export type LicenseUpsertWithoutAttachmentsInput = {
    update: XOR<LicenseUpdateWithoutAttachmentsInput, LicenseUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<LicenseCreateWithoutAttachmentsInput, LicenseUncheckedCreateWithoutAttachmentsInput>
    where?: LicenseWhereInput
  }

  export type LicenseUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: LicenseWhereInput
    data: XOR<LicenseUpdateWithoutAttachmentsInput, LicenseUncheckedUpdateWithoutAttachmentsInput>
  }

  export type LicenseUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    remindOffsets?: LicenseUpdateremindOffsetsInput | number[]
    gracePeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus | null
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: LicenseAssigneeUpdateManyWithoutLicenseNestedInput
    histories?: LicenseHistoryUpdateManyWithoutLicenseNestedInput
    scheduledReminders?: ScheduledReminderUpdateManyWithoutLicenseNestedInput
  }

  export type LicenseUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    remindOffsets?: LicenseUpdateremindOffsetsInput | number[]
    gracePeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus | null
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: LicenseAssigneeUncheckedUpdateManyWithoutLicenseNestedInput
    histories?: LicenseHistoryUncheckedUpdateManyWithoutLicenseNestedInput
    scheduledReminders?: ScheduledReminderUncheckedUpdateManyWithoutLicenseNestedInput
  }

  export type LicenseCreateWithoutScheduledRemindersInput = {
    id?: string
    title: string
    licenseNumber?: string | null
    type?: string | null
    holder?: string | null
    clientId?: string | null
    projectId?: string | null
    serviceId?: string | null
    url?: string | null
    vendorId?: string | null
    issuedOn?: Date | string | null
    validFrom?: Date | string | null
    expiresOn: Date | string
    remindOffsets?: LicenseCreateremindOffsetsInput | number[]
    gracePeriodDays?: number | null
    muted?: boolean | null
    responsibleId?: string | null
    status?: $Enums.LicenseStatus | null
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: LicenseAssigneeCreateNestedManyWithoutLicenseInput
    histories?: LicenseHistoryCreateNestedManyWithoutLicenseInput
    attachments?: LicenseAttachmentCreateNestedManyWithoutLicenseInput
  }

  export type LicenseUncheckedCreateWithoutScheduledRemindersInput = {
    id?: string
    title: string
    licenseNumber?: string | null
    type?: string | null
    holder?: string | null
    clientId?: string | null
    projectId?: string | null
    serviceId?: string | null
    url?: string | null
    vendorId?: string | null
    issuedOn?: Date | string | null
    validFrom?: Date | string | null
    expiresOn: Date | string
    remindOffsets?: LicenseCreateremindOffsetsInput | number[]
    gracePeriodDays?: number | null
    muted?: boolean | null
    responsibleId?: string | null
    status?: $Enums.LicenseStatus | null
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: LicenseAssigneeUncheckedCreateNestedManyWithoutLicenseInput
    histories?: LicenseHistoryUncheckedCreateNestedManyWithoutLicenseInput
    attachments?: LicenseAttachmentUncheckedCreateNestedManyWithoutLicenseInput
  }

  export type LicenseCreateOrConnectWithoutScheduledRemindersInput = {
    where: LicenseWhereUniqueInput
    create: XOR<LicenseCreateWithoutScheduledRemindersInput, LicenseUncheckedCreateWithoutScheduledRemindersInput>
  }

  export type LicenseUpsertWithoutScheduledRemindersInput = {
    update: XOR<LicenseUpdateWithoutScheduledRemindersInput, LicenseUncheckedUpdateWithoutScheduledRemindersInput>
    create: XOR<LicenseCreateWithoutScheduledRemindersInput, LicenseUncheckedCreateWithoutScheduledRemindersInput>
    where?: LicenseWhereInput
  }

  export type LicenseUpdateToOneWithWhereWithoutScheduledRemindersInput = {
    where?: LicenseWhereInput
    data: XOR<LicenseUpdateWithoutScheduledRemindersInput, LicenseUncheckedUpdateWithoutScheduledRemindersInput>
  }

  export type LicenseUpdateWithoutScheduledRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    remindOffsets?: LicenseUpdateremindOffsetsInput | number[]
    gracePeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus | null
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: LicenseAssigneeUpdateManyWithoutLicenseNestedInput
    histories?: LicenseHistoryUpdateManyWithoutLicenseNestedInput
    attachments?: LicenseAttachmentUpdateManyWithoutLicenseNestedInput
  }

  export type LicenseUncheckedUpdateWithoutScheduledRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    holder?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    issuedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    remindOffsets?: LicenseUpdateremindOffsetsInput | number[]
    gracePeriodDays?: NullableIntFieldUpdateOperationsInput | number | null
    muted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus | null
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: LicenseAssigneeUncheckedUpdateManyWithoutLicenseNestedInput
    histories?: LicenseHistoryUncheckedUpdateManyWithoutLicenseNestedInput
    attachments?: LicenseAttachmentUncheckedUpdateManyWithoutLicenseNestedInput
  }

  export type TaskCreateManyProjectInput = {
    id?: string
    taskId?: number
    clientId?: string | null
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    recurrenceRule?: string | null
    recurrenceEndDate?: Date | string | null
    isRecurring?: boolean
    lastGeneratedUntil?: Date | string | null
    retainSubtasks?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientMailSendCount?: number
  }

  export type TaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUpdateManyWithoutTaskNestedInput
    occurrences?: TaskOccurrenceUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    assignees?: TaskAssigneeUncheckedUpdateManyWithoutTaskNestedInput
    occurrences?: TaskOccurrenceUncheckedUpdateManyWithoutTaskNestedInput
    reminders?: ReminderUncheckedUpdateManyWithoutTaskNestedInput
    attachments?: TaskAttachmentUncheckedUpdateManyWithoutTaskNestedInput
    customValues?: TaskCustomValueUncheckedUpdateManyWithoutTaskNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    lastGeneratedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retainSubtasks?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
  }

  export type TaskAssigneeCreateManyTaskInput = {
    id?: string
    userId: string
  }

  export type TaskOccurrenceCreateManyTaskInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    dueDate: Date | string
    assignedToId?: string | null
    priority?: $Enums.Priority
    remarks?: string | null
    status?: $Enums.TaskStatus
    occurrenceIndex: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    completedBy?: string | null
    completionNote?: string | null
    clientId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sequentialId?: number
    clientMailSendCount?: number
    startEmailSent?: boolean
    startEmailSentAt?: Date | string | null
  }

  export type ReminderCreateManyTaskInput = {
    id?: string
    occurrenceAt: Date | string
    remindAt: Date | string
    channel?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: boolean
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TaskAttachmentCreateManyTaskInput = {
    id?: string
    key: string
    createdAt?: Date | string
  }

  export type TaskCustomValueCreateManyTaskInput = {
    id?: string
    fieldId: string
    value: string
  }

  export type EmailLogCreateManyTaskInput = {
    id?: string
    occurrenceId?: string | null
    recipient: string
    subject?: string | null
    body?: string | null
    provider?: string | null
    providerMessageId?: string | null
    status?: $Enums.EmailStatus
    error?: string | null
    createdAt?: Date | string
  }

  export type TaskAssigneeUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssigneeUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskAssigneeUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskOccurrenceUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignees?: TaskOccurrenceAssigneeUpdateManyWithoutOccurrenceNestedInput
    attachments?: TaskOccurrenceAttachmentUpdateManyWithoutOccurrenceNestedInput
    emailLogs?: EmailLogUpdateManyWithoutOccurrenceNestedInput
  }

  export type TaskOccurrenceUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignees?: TaskOccurrenceAssigneeUncheckedUpdateManyWithoutOccurrenceNestedInput
    attachments?: TaskOccurrenceAttachmentUncheckedUpdateManyWithoutOccurrenceNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutOccurrenceNestedInput
  }

  export type TaskOccurrenceUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    occurrenceIndex?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completionNote?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequentialId?: IntFieldUpdateOperationsInput | number
    clientMailSendCount?: IntFieldUpdateOperationsInput | number
    startEmailSent?: BoolFieldUpdateOperationsInput | boolean
    startEmailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReminderUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remindAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskAttachmentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCustomValueUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    field?: TaskCustomFieldUpdateOneRequiredWithoutValuesNestedInput
  }

  export type TaskCustomValueUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCustomValueUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type EmailLogUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrence?: TaskOccurrenceUpdateOneWithoutEmailLogsNestedInput
  }

  export type EmailLogUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    occurrenceId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCustomValueCreateManyFieldInput = {
    id?: string
    taskId: string
    value: string
  }

  export type TaskCustomValueUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    task?: TaskUpdateOneRequiredWithoutCustomValuesNestedInput
  }

  export type TaskCustomValueUncheckedUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCustomValueUncheckedUpdateManyWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TaskOccurrenceAssigneeCreateManyOccurrenceInput = {
    id?: string
    userId: string
  }

  export type TaskOccurrenceAttachmentCreateManyOccurrenceInput = {
    id?: string
    key: string
    createdAt?: Date | string
  }

  export type EmailLogCreateManyOccurrenceInput = {
    id?: string
    taskId?: string | null
    recipient: string
    subject?: string | null
    body?: string | null
    provider?: string | null
    providerMessageId?: string | null
    status?: $Enums.EmailStatus
    error?: string | null
    createdAt?: Date | string
  }

  export type TaskOccurrenceAssigneeUpdateWithoutOccurrenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskOccurrenceAssigneeUncheckedUpdateWithoutOccurrenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskOccurrenceAssigneeUncheckedUpdateManyWithoutOccurrenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskOccurrenceAttachmentUpdateWithoutOccurrenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskOccurrenceAttachmentUncheckedUpdateWithoutOccurrenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskOccurrenceAttachmentUncheckedUpdateManyWithoutOccurrenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUpdateWithoutOccurrenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneWithoutEmailLogsNestedInput
  }

  export type EmailLogUncheckedUpdateWithoutOccurrenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateManyWithoutOccurrenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMemberCreateManyConversationInput = {
    id?: string
    userId: string
    role?: string | null
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    senderId: string
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationMemberUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    user?: DirectoryUserUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ConversationMemberUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationMemberUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: DirectoryUserUpdateOneRequiredWithoutMessagesSentNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadCreateManyMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMemberCreateManyUserInput = {
    id?: string
    conversationId: string
    role?: string | null
  }

  export type MessageCreateManySenderInput = {
    id?: string
    conversationId: string
    body?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    conversation?: ConversationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ConversationMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseAssigneeCreateManyLicenseInput = {
    userId: string
    role?: $Enums.LicenseAssigneeRole
  }

  export type LicenseHistoryCreateManyLicenseInput = {
    id?: string
    action: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: string | null
    at?: Date | string
  }

  export type LicenseAttachmentCreateManyLicenseInput = {
    id?: string
    fileName: string
    fileSize: number
    mimeType: string
    spacesKey: string
    cachedUrl?: string | null
    uploadedAt?: Date | string
  }

  export type ScheduledReminderCreateManyLicenseInput = {
    id?: string
    orgLocalDay: Date | string
    runAt: Date | string
    offsetDays: number
    status?: $Enums.ReminderStatus
    attempts?: number
    lastError?: string | null
    sentAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LicenseAssigneeUpdateWithoutLicenseInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumLicenseAssigneeRoleFieldUpdateOperationsInput | $Enums.LicenseAssigneeRole
  }

  export type LicenseAssigneeUncheckedUpdateWithoutLicenseInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumLicenseAssigneeRoleFieldUpdateOperationsInput | $Enums.LicenseAssigneeRole
  }

  export type LicenseAssigneeUncheckedUpdateManyWithoutLicenseInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumLicenseAssigneeRoleFieldUpdateOperationsInput | $Enums.LicenseAssigneeRole
  }

  export type LicenseHistoryUpdateWithoutLicenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseHistoryUncheckedUpdateWithoutLicenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseHistoryUncheckedUpdateManyWithoutLicenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseAttachmentUpdateWithoutLicenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    spacesKey?: StringFieldUpdateOperationsInput | string
    cachedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseAttachmentUncheckedUpdateWithoutLicenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    spacesKey?: StringFieldUpdateOperationsInput | string
    cachedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseAttachmentUncheckedUpdateManyWithoutLicenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    spacesKey?: StringFieldUpdateOperationsInput | string
    cachedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledReminderUpdateWithoutLicenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgLocalDay?: DateTimeFieldUpdateOperationsInput | Date | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offsetDays?: IntFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledReminderUncheckedUpdateWithoutLicenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgLocalDay?: DateTimeFieldUpdateOperationsInput | Date | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offsetDays?: IntFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledReminderUncheckedUpdateManyWithoutLicenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgLocalDay?: DateTimeFieldUpdateOperationsInput | Date | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offsetDays?: IntFieldUpdateOperationsInput | number
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    attempts?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}